"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../core-detect/dist/detectors/index.js":
/*!**********************************************!*\
  !*** ../core-detect/dist/detectors/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateConfidence: function() { return /* binding */ calculateConfidence; },\n/* harmony export */   detectCustomPatterns: function() { return /* binding */ detectCustomPatterns; },\n/* harmony export */   detectToken: function() { return /* binding */ detectToken; },\n/* harmony export */   detectTokenWithCustomPatterns: function() { return /* binding */ detectTokenWithCustomPatterns; },\n/* harmony export */   isAWSKey: function() { return /* binding */ isAWSKey; },\n/* harmony export */   isAddressComponent: function() { return /* binding */ isAddressComponent; },\n/* harmony export */   isJWT: function() { return /* binding */ isJWT; },\n/* harmony export */   isLuhnValid: function() { return /* binding */ isLuhnValid; },\n/* harmony export */   isValidIBAN: function() { return /* binding */ isValidIBAN; },\n/* harmony export */   isValidSSN: function() { return /* binding */ isValidSSN; },\n/* harmony export */   isValidUSPassport: function() { return /* binding */ isValidUSPassport; }\n/* harmony export */ });\n/**\n * Determine whether a string of digits represents a valid PAN according\n * to the Luhn checksum algorithm.  Only digits are considered; all\n * non‑numeric characters should be stripped before calling this function.\n */\nfunction isLuhnValid(value) {\n    let sum = 0;\n    let shouldDouble = false;\n    for (let i = value.length - 1; i >= 0; i--) {\n        const c = value.charCodeAt(i) - 48;\n        if (c < 0 || c > 9) {\n            return false;\n        }\n        let digit = c;\n        if (shouldDouble) {\n            digit *= 2;\n            if (digit > 9)\n                digit -= 9;\n        }\n        sum += digit;\n        shouldDouble = !shouldDouble;\n    }\n    return sum % 10 === 0;\n}\n/**\n * Validate an International Bank Account Number (IBAN) using the MOD 97\n * algorithm defined in ISO 13616.  Letters are mapped A=10, B=11, …\n * The function returns true when the IBAN appears structurally valid.  It\n * does not verify that the account exists.\n */\nfunction isValidIBAN(iban) {\n    const cleaned = iban.replace(/\\s+/g, '').toUpperCase();\n    // Basic length check: IBANs are between 15 and 34 characters long\n    if (cleaned.length < 15 || cleaned.length > 34)\n        return false;\n    // Move the four initial characters to the end of the string\n    const rearranged = cleaned.slice(4) + cleaned.slice(0, 4);\n    // Replace letters with numbers: A=10, B=11, …\n    let numeric = '';\n    for (const ch of rearranged) {\n        const code = ch.charCodeAt(0);\n        if (code >= 48 && code <= 57) {\n            numeric += ch;\n        }\n        else if (code >= 65 && code <= 90) {\n            numeric += (code - 55).toString();\n        }\n        else {\n            return false;\n        }\n    }\n    // Compute the remainder using mod 97\n    let remainder = 0;\n    for (let i = 0; i < numeric.length; i++) {\n        remainder = (remainder * 10 + Number(numeric[i])) % 97;\n    }\n    return remainder === 1;\n}\n/**\n * Validate a US Social Security Number (SSN).  Performs basic\n * structural checks: XXX-XX-XXXX where the area number is not 000,\n * 666, or between 900–999; the group number is not 00; and the serial\n * number is not 0000.\n */\nfunction isValidSSN(value) {\n    const ssnRegex = /^(\\d{3})-(\\d{2})-(\\d{4})$/;\n    const match = ssnRegex.exec(value);\n    if (!match)\n        return false;\n    const area = parseInt(match[1], 10);\n    const group = parseInt(match[2], 10);\n    const serial = parseInt(match[3], 10);\n    if (area === 0 || group === 0 || serial === 0)\n        return false;\n    if (area === 666 || area >= 900)\n        return false;\n    return true;\n}\n/**\n * Validate US passport number format. US passports are typically 9 digits\n * or 1 letter followed by 8 digits (newer format).\n */\nfunction isValidUSPassport(value) {\n    const cleaned = value.replace(/\\s+/g, '');\n    // Format 1: 9 digits (older format)\n    if (/^\\d{9}$/.test(cleaned))\n        return true;\n    // Format 2: 1 letter + 8 digits (newer format) \n    if (/^[A-Z]\\d{8}$/.test(cleaned))\n        return true;\n    return false;\n}\n/**\n * Enhanced address detection with common address components\n */\nfunction isAddressComponent(value) {\n    const token = value.trim();\n    // Street suffixes (high confidence)\n    const streetSuffixes = /^(Street|St\\.?|Avenue|Ave\\.?|Road|Rd\\.?|Lane|Ln\\.?|Boulevard|Blvd\\.?|Drive|Dr\\.?|Circle|Cir\\.?|Court|Ct\\.?|Place|Pl\\.?|Way|Parkway|Pkwy\\.?)$/i;\n    if (streetSuffixes.test(token)) {\n        return { isAddress: true, confidence: 0.95, reason: 'Street type indicator' };\n    }\n    // Directional indicators (medium confidence)\n    const directions = /^(North|N\\.?|South|S\\.?|East|E\\.?|West|W\\.?|Northeast|NE\\.?|Northwest|NW\\.?|Southeast|SE\\.?|Southwest|SW\\.?)$/i;\n    if (directions.test(token)) {\n        return { isAddress: true, confidence: 0.7, reason: 'Directional indicator' };\n    }\n    // Address with numbers (medium confidence)\n    if (/\\d/.test(token) && token.length >= 3) {\n        // House numbers, apartment numbers, ZIP codes\n        if (/^\\d{1,5}[A-Z]?$/.test(token) || /^\\d{5}(-\\d{4})?$/.test(token)) {\n            return { isAddress: true, confidence: 0.8, reason: 'House number or ZIP code pattern' };\n        }\n        if (/^#?\\d+[A-Z]?$/.test(token) || /^(Apt|Suite|Unit|Ste|#)\\s*\\d+[A-Z]?$/i.test(token)) {\n            return { isAddress: true, confidence: 0.85, reason: 'Apartment/suite number' };\n        }\n        // Generic number in address context\n        return { isAddress: true, confidence: 0.6, reason: 'Contains digits and could be part of address' };\n    }\n    // State abbreviations (high confidence)\n    const stateAbbrev = /^(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|DC)$/;\n    if (stateAbbrev.test(token.toUpperCase())) {\n        return { isAddress: true, confidence: 0.9, reason: 'US state abbreviation' };\n    }\n    return { isAddress: false, confidence: 0, reason: '' };\n}\n/**\n * Calculate confidence score for detection based on pattern strength and context\n */\nfunction calculateConfidence(kind, token, ocrConfidence = 0.9) {\n    const base = Math.min(ocrConfidence, 0.95); // Cap OCR confidence\n    switch (kind) {\n        case 'EMAIL':\n            // Higher confidence for well-formed emails\n            return token.includes('@') && token.includes('.') ? Math.min(base + 0.05, 1.0) : base * 0.8;\n        case 'PHONE':\n            const digits = token.replace(/\\D/g, '');\n            // Higher confidence for standard formats\n            if (digits.length === 10 || digits.length === 11)\n                return Math.min(base + 0.1, 1.0);\n            if (digits.length >= 7 && digits.length <= 15)\n                return base * 0.9;\n            return base * 0.7;\n        case 'PAN':\n            // Credit cards with Luhn validation get high confidence\n            return Math.min(base + 0.1, 1.0);\n        case 'SSN':\n            // SSN with proper validation gets high confidence\n            return Math.min(base + 0.15, 1.0);\n        case 'PASSPORT':\n            // Passport numbers get medium-high confidence\n            return Math.min(base + 0.05, 1.0);\n        case 'IBAN':\n            // IBAN with MOD 97 validation gets high confidence\n            return Math.min(base + 0.1, 1.0);\n        case 'ADDRESS':\n            // Address confidence varies by component type - handled in isAddressComponent\n            return base;\n        case 'NAME':\n            // Names are tricky - lower confidence to reduce false positives\n            return base * 0.7;\n        case 'BARCODE':\n            // QR codes/barcodes are typically very reliable\n            return 1.0;\n        case 'JWT':\n            // JWT format is distinctive\n            return Math.min(base + 0.05, 1.0);\n        case 'API_KEY':\n            // API keys have distinctive patterns\n            return Math.min(base + 0.1, 1.0);\n        default:\n            return base;\n    }\n}\n/** Detect whether a token is formatted like a JSON Web Token (JWT). */\nfunction isJWT(value) {\n    return /^[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+$/.test(value.trim());\n}\n/** Detect whether a token looks like an AWS access key ID.  AWS keys\n * typically start with AKIA or ASIA followed by 16 uppercase letters or\n * digits. */\nfunction isAWSKey(value) {\n    return /^(A(KIA|SIA)[A-Z0-9]{16})$/.test(value.trim());\n}\n/**\n * Perform high‑level detection for a single token.  If the token matches\n * a sensitive pattern, this function returns an object describing the\n * detection; otherwise it returns null.  Note that this function does\n * not compute bounding boxes – it only classifies the token.  Bounding\n * boxes are provided by the OCR engine.\n */\nfunction detectToken(token) {\n    const raw = token.trim();\n    if (!raw)\n        return null;\n    // PAN (credit card number) – 13–19 digits with Luhn valid (check first to avoid phone conflicts)\n    const digitsOnly = raw.replace(/\\D/g, '');\n    if (digitsOnly.length >= 13 && digitsOnly.length <= 19 && isLuhnValid(digitsOnly)) {\n        return { kind: 'PAN', reason: 'Luhn valid primary account number', confidence: 0.95 };\n    }\n    // IBAN (starts with two letters followed by digits and letters)\n    const ibanPattern = /^[A-Z]{2}[0-9A-Z]{13,32}$/i;\n    if (ibanPattern.test(raw) && isValidIBAN(raw)) {\n        return { kind: 'IBAN', reason: 'Valid IBAN checksum', confidence: 0.95 };\n    }\n    // SSN (US format) - check before general phone patterns, including invalid ones\n    const ssnPattern = /^\\d{3}-\\d{2}-\\d{4}$/;\n    if (ssnPattern.test(raw)) {\n        if (isValidSSN(raw)) {\n            return { kind: 'SSN', reason: 'Valid US SSN format', confidence: 0.95 };\n        }\n        // Don't detect invalid SSNs as other types\n        return null;\n    }\n    // Passport number (US format)\n    const passportPattern = /^[A-Z]?\\d{8,9}$/i;\n    if (passportPattern.test(raw) && isValidUSPassport(raw.toUpperCase())) {\n        return { kind: 'PASSPORT', reason: 'Valid US passport number format', confidence: 0.9 };\n    }\n    // JWT - check early to prevent JWT being detected as address (contains many digits)\n    if (isJWT(raw) && raw.length > 50) {\n        return { kind: 'JWT', reason: 'Looks like a JWT token', confidence: 0.9 };\n    }\n    // Email - more strict pattern to reduce false positives\n    const emailPattern = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i;\n    if (emailPattern.test(raw) && raw.includes('@') && raw.includes('.')) {\n        return { kind: 'EMAIL', reason: 'Matches email pattern', confidence: 0.9 };\n    }\n    // Phone number - enhanced detection with format validation\n    if (digitsOnly.length >= 7 && /\\d{3,}/.test(digitsOnly)) {\n        // North American format (10-11 digits)\n        if (digitsOnly.length === 10 || (digitsOnly.length === 11 && digitsOnly[0] === '1')) {\n            return { kind: 'PHONE', reason: 'North American phone format', confidence: 0.85 };\n        }\n        // International format (7-15 digits)\n        if (digitsOnly.length >= 7 && digitsOnly.length <= 15) {\n            return { kind: 'PHONE', reason: 'International phone format', confidence: 0.75 };\n        }\n    }\n    // Enhanced address detection\n    const addressResult = isAddressComponent(raw);\n    if (addressResult.isAddress) {\n        return { kind: 'ADDRESS', reason: addressResult.reason, confidence: addressResult.confidence };\n    }\n    // AWS access key id\n    if (isAWSKey(raw)) {\n        return { kind: 'API_KEY', reason: 'Looks like an AWS access key', confidence: 0.95 };\n    }\n    // Names (proper nouns) - enhanced with false positive reduction\n    const namePattern = /^[A-Z][a-z]{2,}$/;\n    if (namePattern.test(raw) && !/\\d/.test(raw) && raw.toUpperCase() !== raw) {\n        // Exclude common words that aren't names\n        const commonWords = /^(The|And|But|For|Are|This|That|With|Have|Will|From|They|Know|Want|Been|Good|Much|Some|Time|Very|When|Come|Here|Just|Like|Long|Make|Many|Over|Such|Take|Than|Them|Well|Were|What|Your|After|Before|Could|First|Found|Great|Other|Right|Should|These|Where|Which|While|Would|Years|Young|About|Again|Place|State|Still|Think|Three|Through|Under|Water|Write)$/i;\n        if (!commonWords.test(raw)) {\n            return { kind: 'NAME', reason: 'Likely proper name', confidence: 0.6 };\n        }\n    }\n    return null;\n}\n/**\n * Apply custom detection patterns to a token\n */\nfunction detectCustomPatterns(token, customPatterns) {\n    if (!customPatterns || customPatterns.length === 0)\n        return null;\n    for (const pattern of customPatterns) {\n        try {\n            const flags = pattern.caseSensitive === false ? 'i' : '';\n            const regex = new RegExp(pattern.pattern, flags);\n            if (regex.test(token)) {\n                return {\n                    kind: pattern.kind,\n                    reason: `Custom pattern: ${pattern.name}`,\n                    confidence: pattern.confidence\n                };\n            }\n        }\n        catch (error) {\n            // Skip invalid regex patterns\n            console.warn(`Invalid custom pattern ${pattern.id}: ${error}`);\n            continue;\n        }\n    }\n    return null;\n}\n/**\n * Enhanced detectToken that includes custom pattern support\n */\nfunction detectTokenWithCustomPatterns(token, customPatterns) {\n    // First check custom patterns (they take precedence)\n    if (customPatterns && customPatterns.length > 0) {\n        const customResult = detectCustomPatterns(token, customPatterns);\n        if (customResult)\n            return customResult;\n    }\n    // Fall back to standard detection\n    return detectToken(token);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29yZS1kZXRlY3QvZGlzdC9kZXRlY3RvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUksNkJBQTZCLEVBQUUsS0FBSyxFQUFFO0FBQzNELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsU0FBUyxNQUFNO0FBQ2pEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw0QkFBNEIsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzFDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkRBQTZELEdBQUc7QUFDaEU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVcsSUFBSSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29yZS1kZXRlY3QvZGlzdC9kZXRlY3RvcnMvaW5kZXguanM/ZGEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERldGVybWluZSB3aGV0aGVyIGEgc3RyaW5nIG9mIGRpZ2l0cyByZXByZXNlbnRzIGEgdmFsaWQgUEFOIGFjY29yZGluZ1xuICogdG8gdGhlIEx1aG4gY2hlY2tzdW0gYWxnb3JpdGhtLiAgT25seSBkaWdpdHMgYXJlIGNvbnNpZGVyZWQ7IGFsbFxuICogbm9u4oCRbnVtZXJpYyBjaGFyYWN0ZXJzIHNob3VsZCBiZSBzdHJpcHBlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMdWhuVmFsaWQodmFsdWUpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgc2hvdWxkRG91YmxlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpIC0gNDg7XG4gICAgICAgIGlmIChjIDwgMCB8fCBjID4gOSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWdpdCA9IGM7XG4gICAgICAgIGlmIChzaG91bGREb3VibGUpIHtcbiAgICAgICAgICAgIGRpZ2l0ICo9IDI7XG4gICAgICAgICAgICBpZiAoZGlnaXQgPiA5KVxuICAgICAgICAgICAgICAgIGRpZ2l0IC09IDk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtICs9IGRpZ2l0O1xuICAgICAgICBzaG91bGREb3VibGUgPSAhc2hvdWxkRG91YmxlO1xuICAgIH1cbiAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG59XG4vKipcbiAqIFZhbGlkYXRlIGFuIEludGVybmF0aW9uYWwgQmFuayBBY2NvdW50IE51bWJlciAoSUJBTikgdXNpbmcgdGhlIE1PRMKgOTdcbiAqIGFsZ29yaXRobSBkZWZpbmVkIGluIElTT8KgMTM2MTYuICBMZXR0ZXJzIGFyZSBtYXBwZWQgQT0xMCwgQj0xMSwg4oCmXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gdGhlIElCQU4gYXBwZWFycyBzdHJ1Y3R1cmFsbHkgdmFsaWQuICBJdFxuICogZG9lcyBub3QgdmVyaWZ5IHRoYXQgdGhlIGFjY291bnQgZXhpc3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZElCQU4oaWJhbikge1xuICAgIGNvbnN0IGNsZWFuZWQgPSBpYmFuLnJlcGxhY2UoL1xccysvZywgJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gQmFzaWMgbGVuZ3RoIGNoZWNrOiBJQkFOcyBhcmUgYmV0d2VlbiAxNSBhbmQgMzQgY2hhcmFjdGVycyBsb25nXG4gICAgaWYgKGNsZWFuZWQubGVuZ3RoIDwgMTUgfHwgY2xlYW5lZC5sZW5ndGggPiAzNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE1vdmUgdGhlIGZvdXIgaW5pdGlhbCBjaGFyYWN0ZXJzIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgIGNvbnN0IHJlYXJyYW5nZWQgPSBjbGVhbmVkLnNsaWNlKDQpICsgY2xlYW5lZC5zbGljZSgwLCA0KTtcbiAgICAvLyBSZXBsYWNlIGxldHRlcnMgd2l0aCBudW1iZXJzOiBBPTEwLCBCPTExLCDigKZcbiAgICBsZXQgbnVtZXJpYyA9ICcnO1xuICAgIGZvciAoY29uc3QgY2ggb2YgcmVhcnJhbmdlZCkge1xuICAgICAgICBjb25zdCBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nykge1xuICAgICAgICAgICAgbnVtZXJpYyArPSBjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIG51bWVyaWMgKz0gKGNvZGUgLSA1NSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSByZW1haW5kZXIgdXNpbmcgbW9kIDk3XG4gICAgbGV0IHJlbWFpbmRlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1lcmljLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbWFpbmRlciA9IChyZW1haW5kZXIgKiAxMCArIE51bWJlcihudW1lcmljW2ldKSkgJSA5NztcbiAgICB9XG4gICAgcmV0dXJuIHJlbWFpbmRlciA9PT0gMTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSBVUyBTb2NpYWwgU2VjdXJpdHkgTnVtYmVyIChTU04pLiAgUGVyZm9ybXMgYmFzaWNcbiAqIHN0cnVjdHVyYWwgY2hlY2tzOiBYWFgtWFgtWFhYWCB3aGVyZSB0aGUgYXJlYSBudW1iZXIgaXMgbm90IDAwMCxcbiAqIDY2Niwgb3IgYmV0d2VlbiA5MDDigJM5OTk7IHRoZSBncm91cCBudW1iZXIgaXMgbm90IDAwOyBhbmQgdGhlIHNlcmlhbFxuICogbnVtYmVyIGlzIG5vdCAwMDAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFNTTih2YWx1ZSkge1xuICAgIGNvbnN0IHNzblJlZ2V4ID0gL14oXFxkezN9KS0oXFxkezJ9KS0oXFxkezR9KSQvO1xuICAgIGNvbnN0IG1hdGNoID0gc3NuUmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGFyZWEgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIGNvbnN0IGdyb3VwID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICBjb25zdCBzZXJpYWwgPSBwYXJzZUludChtYXRjaFszXSwgMTApO1xuICAgIGlmIChhcmVhID09PSAwIHx8IGdyb3VwID09PSAwIHx8IHNlcmlhbCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhcmVhID09PSA2NjYgfHwgYXJlYSA+PSA5MDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGUgVVMgcGFzc3BvcnQgbnVtYmVyIGZvcm1hdC4gVVMgcGFzc3BvcnRzIGFyZSB0eXBpY2FsbHkgOSBkaWdpdHNcbiAqIG9yIDEgbGV0dGVyIGZvbGxvd2VkIGJ5IDggZGlnaXRzIChuZXdlciBmb3JtYXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFVTUGFzc3BvcnQodmFsdWUpIHtcbiAgICBjb25zdCBjbGVhbmVkID0gdmFsdWUucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgLy8gRm9ybWF0IDE6IDkgZGlnaXRzIChvbGRlciBmb3JtYXQpXG4gICAgaWYgKC9eXFxkezl9JC8udGVzdChjbGVhbmVkKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gRm9ybWF0IDI6IDEgbGV0dGVyICsgOCBkaWdpdHMgKG5ld2VyIGZvcm1hdCkgXG4gICAgaWYgKC9eW0EtWl1cXGR7OH0kLy50ZXN0KGNsZWFuZWQpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEVuaGFuY2VkIGFkZHJlc3MgZGV0ZWN0aW9uIHdpdGggY29tbW9uIGFkZHJlc3MgY29tcG9uZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzQ29tcG9uZW50KHZhbHVlKSB7XG4gICAgY29uc3QgdG9rZW4gPSB2YWx1ZS50cmltKCk7XG4gICAgLy8gU3RyZWV0IHN1ZmZpeGVzIChoaWdoIGNvbmZpZGVuY2UpXG4gICAgY29uc3Qgc3RyZWV0U3VmZml4ZXMgPSAvXihTdHJlZXR8U3RcXC4/fEF2ZW51ZXxBdmVcXC4/fFJvYWR8UmRcXC4/fExhbmV8TG5cXC4/fEJvdWxldmFyZHxCbHZkXFwuP3xEcml2ZXxEclxcLj98Q2lyY2xlfENpclxcLj98Q291cnR8Q3RcXC4/fFBsYWNlfFBsXFwuP3xXYXl8UGFya3dheXxQa3d5XFwuPykkL2k7XG4gICAgaWYgKHN0cmVldFN1ZmZpeGVzLnRlc3QodG9rZW4pKSB7XG4gICAgICAgIHJldHVybiB7IGlzQWRkcmVzczogdHJ1ZSwgY29uZmlkZW5jZTogMC45NSwgcmVhc29uOiAnU3RyZWV0IHR5cGUgaW5kaWNhdG9yJyB9O1xuICAgIH1cbiAgICAvLyBEaXJlY3Rpb25hbCBpbmRpY2F0b3JzIChtZWRpdW0gY29uZmlkZW5jZSlcbiAgICBjb25zdCBkaXJlY3Rpb25zID0gL14oTm9ydGh8TlxcLj98U291dGh8U1xcLj98RWFzdHxFXFwuP3xXZXN0fFdcXC4/fE5vcnRoZWFzdHxORVxcLj98Tm9ydGh3ZXN0fE5XXFwuP3xTb3V0aGVhc3R8U0VcXC4/fFNvdXRod2VzdHxTV1xcLj8pJC9pO1xuICAgIGlmIChkaXJlY3Rpb25zLnRlc3QodG9rZW4pKSB7XG4gICAgICAgIHJldHVybiB7IGlzQWRkcmVzczogdHJ1ZSwgY29uZmlkZW5jZTogMC43LCByZWFzb246ICdEaXJlY3Rpb25hbCBpbmRpY2F0b3InIH07XG4gICAgfVxuICAgIC8vIEFkZHJlc3Mgd2l0aCBudW1iZXJzIChtZWRpdW0gY29uZmlkZW5jZSlcbiAgICBpZiAoL1xcZC8udGVzdCh0b2tlbikgJiYgdG9rZW4ubGVuZ3RoID49IDMpIHtcbiAgICAgICAgLy8gSG91c2UgbnVtYmVycywgYXBhcnRtZW50IG51bWJlcnMsIFpJUCBjb2Rlc1xuICAgICAgICBpZiAoL15cXGR7MSw1fVtBLVpdPyQvLnRlc3QodG9rZW4pIHx8IC9eXFxkezV9KC1cXGR7NH0pPyQvLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc0FkZHJlc3M6IHRydWUsIGNvbmZpZGVuY2U6IDAuOCwgcmVhc29uOiAnSG91c2UgbnVtYmVyIG9yIFpJUCBjb2RlIHBhdHRlcm4nIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eIz9cXGQrW0EtWl0/JC8udGVzdCh0b2tlbikgfHwgL14oQXB0fFN1aXRlfFVuaXR8U3RlfCMpXFxzKlxcZCtbQS1aXT8kL2kudGVzdCh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlzQWRkcmVzczogdHJ1ZSwgY29uZmlkZW5jZTogMC44NSwgcmVhc29uOiAnQXBhcnRtZW50L3N1aXRlIG51bWJlcicgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmljIG51bWJlciBpbiBhZGRyZXNzIGNvbnRleHRcbiAgICAgICAgcmV0dXJuIHsgaXNBZGRyZXNzOiB0cnVlLCBjb25maWRlbmNlOiAwLjYsIHJlYXNvbjogJ0NvbnRhaW5zIGRpZ2l0cyBhbmQgY291bGQgYmUgcGFydCBvZiBhZGRyZXNzJyB9O1xuICAgIH1cbiAgICAvLyBTdGF0ZSBhYmJyZXZpYXRpb25zIChoaWdoIGNvbmZpZGVuY2UpXG4gICAgY29uc3Qgc3RhdGVBYmJyZXYgPSAvXihBTHxBS3xBWnxBUnxDQXxDT3xDVHxERXxGTHxHQXxISXxJRHxJTHxJTnxJQXxLU3xLWXxMQXxNRXxNRHxNQXxNSXxNTnxNU3xNT3xNVHxORXxOVnxOSHxOSnxOTXxOWXxOQ3xORHxPSHxPS3xPUnxQQXxSSXxTQ3xTRHxUTnxUWHxVVHxWVHxWQXxXQXxXVnxXSXxXWXxEQykkLztcbiAgICBpZiAoc3RhdGVBYmJyZXYudGVzdCh0b2tlbi50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICByZXR1cm4geyBpc0FkZHJlc3M6IHRydWUsIGNvbmZpZGVuY2U6IDAuOSwgcmVhc29uOiAnVVMgc3RhdGUgYWJicmV2aWF0aW9uJyB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpc0FkZHJlc3M6IGZhbHNlLCBjb25maWRlbmNlOiAwLCByZWFzb246ICcnIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSBjb25maWRlbmNlIHNjb3JlIGZvciBkZXRlY3Rpb24gYmFzZWQgb24gcGF0dGVybiBzdHJlbmd0aCBhbmQgY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQ29uZmlkZW5jZShraW5kLCB0b2tlbiwgb2NyQ29uZmlkZW5jZSA9IDAuOSkge1xuICAgIGNvbnN0IGJhc2UgPSBNYXRoLm1pbihvY3JDb25maWRlbmNlLCAwLjk1KTsgLy8gQ2FwIE9DUiBjb25maWRlbmNlXG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgIGNhc2UgJ0VNQUlMJzpcbiAgICAgICAgICAgIC8vIEhpZ2hlciBjb25maWRlbmNlIGZvciB3ZWxsLWZvcm1lZCBlbWFpbHNcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5pbmNsdWRlcygnQCcpICYmIHRva2VuLmluY2x1ZGVzKCcuJykgPyBNYXRoLm1pbihiYXNlICsgMC4wNSwgMS4wKSA6IGJhc2UgKiAwLjg7XG4gICAgICAgIGNhc2UgJ1BIT05FJzpcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0cyA9IHRva2VuLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICAgICAgICAvLyBIaWdoZXIgY29uZmlkZW5jZSBmb3Igc3RhbmRhcmQgZm9ybWF0c1xuICAgICAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPT09IDEwIHx8IGRpZ2l0cy5sZW5ndGggPT09IDExKVxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihiYXNlICsgMC4xLCAxLjApO1xuICAgICAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPj0gNyAmJiBkaWdpdHMubGVuZ3RoIDw9IDE1KVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICogMC45O1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UgKiAwLjc7XG4gICAgICAgIGNhc2UgJ1BBTic6XG4gICAgICAgICAgICAvLyBDcmVkaXQgY2FyZHMgd2l0aCBMdWhuIHZhbGlkYXRpb24gZ2V0IGhpZ2ggY29uZmlkZW5jZVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGJhc2UgKyAwLjEsIDEuMCk7XG4gICAgICAgIGNhc2UgJ1NTTic6XG4gICAgICAgICAgICAvLyBTU04gd2l0aCBwcm9wZXIgdmFsaWRhdGlvbiBnZXRzIGhpZ2ggY29uZmlkZW5jZVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGJhc2UgKyAwLjE1LCAxLjApO1xuICAgICAgICBjYXNlICdQQVNTUE9SVCc6XG4gICAgICAgICAgICAvLyBQYXNzcG9ydCBudW1iZXJzIGdldCBtZWRpdW0taGlnaCBjb25maWRlbmNlXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYmFzZSArIDAuMDUsIDEuMCk7XG4gICAgICAgIGNhc2UgJ0lCQU4nOlxuICAgICAgICAgICAgLy8gSUJBTiB3aXRoIE1PRCA5NyB2YWxpZGF0aW9uIGdldHMgaGlnaCBjb25maWRlbmNlXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYmFzZSArIDAuMSwgMS4wKTtcbiAgICAgICAgY2FzZSAnQUREUkVTUyc6XG4gICAgICAgICAgICAvLyBBZGRyZXNzIGNvbmZpZGVuY2UgdmFyaWVzIGJ5IGNvbXBvbmVudCB0eXBlIC0gaGFuZGxlZCBpbiBpc0FkZHJlc3NDb21wb25lbnRcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBjYXNlICdOQU1FJzpcbiAgICAgICAgICAgIC8vIE5hbWVzIGFyZSB0cmlja3kgLSBsb3dlciBjb25maWRlbmNlIHRvIHJlZHVjZSBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgICAgIHJldHVybiBiYXNlICogMC43O1xuICAgICAgICBjYXNlICdCQVJDT0RFJzpcbiAgICAgICAgICAgIC8vIFFSIGNvZGVzL2JhcmNvZGVzIGFyZSB0eXBpY2FsbHkgdmVyeSByZWxpYWJsZVxuICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgY2FzZSAnSldUJzpcbiAgICAgICAgICAgIC8vIEpXVCBmb3JtYXQgaXMgZGlzdGluY3RpdmVcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihiYXNlICsgMC4wNSwgMS4wKTtcbiAgICAgICAgY2FzZSAnQVBJX0tFWSc6XG4gICAgICAgICAgICAvLyBBUEkga2V5cyBoYXZlIGRpc3RpbmN0aXZlIHBhdHRlcm5zXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oYmFzZSArIDAuMSwgMS4wKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbi8qKiBEZXRlY3Qgd2hldGhlciBhIHRva2VuIGlzIGZvcm1hdHRlZCBsaWtlIGEgSlNPTiBXZWIgVG9rZW4gKEpXVCkuICovXG5leHBvcnQgZnVuY3Rpb24gaXNKV1QodmFsdWUpIHtcbiAgICByZXR1cm4gL15bQS1aYS16MC05Xy1dK1xcLltBLVphLXowLTlfLV0rXFwuW0EtWmEtejAtOV8tXSskLy50ZXN0KHZhbHVlLnRyaW0oKSk7XG59XG4vKiogRGV0ZWN0IHdoZXRoZXIgYSB0b2tlbiBsb29rcyBsaWtlIGFuIEFXUyBhY2Nlc3Mga2V5IElELiAgQVdTIGtleXNcbiAqIHR5cGljYWxseSBzdGFydCB3aXRoIEFLSUEgb3IgQVNJQSBmb2xsb3dlZCBieSAxNiB1cHBlcmNhc2UgbGV0dGVycyBvclxuICogZGlnaXRzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQVdTS2V5KHZhbHVlKSB7XG4gICAgcmV0dXJuIC9eKEEoS0lBfFNJQSlbQS1aMC05XXsxNn0pJC8udGVzdCh2YWx1ZS50cmltKCkpO1xufVxuLyoqXG4gKiBQZXJmb3JtIGhpZ2jigJFsZXZlbCBkZXRlY3Rpb24gZm9yIGEgc2luZ2xlIHRva2VuLiAgSWYgdGhlIHRva2VuIG1hdGNoZXNcbiAqIGEgc2Vuc2l0aXZlIHBhdHRlcm4sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGVcbiAqIGRldGVjdGlvbjsgb3RoZXJ3aXNlIGl0IHJldHVybnMgbnVsbC4gIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXNcbiAqIG5vdCBjb21wdXRlIGJvdW5kaW5nIGJveGVzIOKAkyBpdCBvbmx5IGNsYXNzaWZpZXMgdGhlIHRva2VuLiAgQm91bmRpbmdcbiAqIGJveGVzIGFyZSBwcm92aWRlZCBieSB0aGUgT0NSIGVuZ2luZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFRva2VuKHRva2VuKSB7XG4gICAgY29uc3QgcmF3ID0gdG9rZW4udHJpbSgpO1xuICAgIGlmICghcmF3KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBQQU4gKGNyZWRpdCBjYXJkIG51bWJlcikg4oCTIDEz4oCTMTkgZGlnaXRzIHdpdGggTHVobiB2YWxpZCAoY2hlY2sgZmlyc3QgdG8gYXZvaWQgcGhvbmUgY29uZmxpY3RzKVxuICAgIGNvbnN0IGRpZ2l0c09ubHkgPSByYXcucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICBpZiAoZGlnaXRzT25seS5sZW5ndGggPj0gMTMgJiYgZGlnaXRzT25seS5sZW5ndGggPD0gMTkgJiYgaXNMdWhuVmFsaWQoZGlnaXRzT25seSkpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogJ1BBTicsIHJlYXNvbjogJ0x1aG4gdmFsaWQgcHJpbWFyeSBhY2NvdW50IG51bWJlcicsIGNvbmZpZGVuY2U6IDAuOTUgfTtcbiAgICB9XG4gICAgLy8gSUJBTiAoc3RhcnRzIHdpdGggdHdvIGxldHRlcnMgZm9sbG93ZWQgYnkgZGlnaXRzIGFuZCBsZXR0ZXJzKVxuICAgIGNvbnN0IGliYW5QYXR0ZXJuID0gL15bQS1aXXsyfVswLTlBLVpdezEzLDMyfSQvaTtcbiAgICBpZiAoaWJhblBhdHRlcm4udGVzdChyYXcpICYmIGlzVmFsaWRJQkFOKHJhdykpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogJ0lCQU4nLCByZWFzb246ICdWYWxpZCBJQkFOIGNoZWNrc3VtJywgY29uZmlkZW5jZTogMC45NSB9O1xuICAgIH1cbiAgICAvLyBTU04gKFVTIGZvcm1hdCkgLSBjaGVjayBiZWZvcmUgZ2VuZXJhbCBwaG9uZSBwYXR0ZXJucywgaW5jbHVkaW5nIGludmFsaWQgb25lc1xuICAgIGNvbnN0IHNzblBhdHRlcm4gPSAvXlxcZHszfS1cXGR7Mn0tXFxkezR9JC87XG4gICAgaWYgKHNzblBhdHRlcm4udGVzdChyYXcpKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkU1NOKHJhdykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6ICdTU04nLCByZWFzb246ICdWYWxpZCBVUyBTU04gZm9ybWF0JywgY29uZmlkZW5jZTogMC45NSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGRldGVjdCBpbnZhbGlkIFNTTnMgYXMgb3RoZXIgdHlwZXNcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFBhc3Nwb3J0IG51bWJlciAoVVMgZm9ybWF0KVxuICAgIGNvbnN0IHBhc3Nwb3J0UGF0dGVybiA9IC9eW0EtWl0/XFxkezgsOX0kL2k7XG4gICAgaWYgKHBhc3Nwb3J0UGF0dGVybi50ZXN0KHJhdykgJiYgaXNWYWxpZFVTUGFzc3BvcnQocmF3LnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdQQVNTUE9SVCcsIHJlYXNvbjogJ1ZhbGlkIFVTIHBhc3Nwb3J0IG51bWJlciBmb3JtYXQnLCBjb25maWRlbmNlOiAwLjkgfTtcbiAgICB9XG4gICAgLy8gSldUIC0gY2hlY2sgZWFybHkgdG8gcHJldmVudCBKV1QgYmVpbmcgZGV0ZWN0ZWQgYXMgYWRkcmVzcyAoY29udGFpbnMgbWFueSBkaWdpdHMpXG4gICAgaWYgKGlzSldUKHJhdykgJiYgcmF3Lmxlbmd0aCA+IDUwKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdKV1QnLCByZWFzb246ICdMb29rcyBsaWtlIGEgSldUIHRva2VuJywgY29uZmlkZW5jZTogMC45IH07XG4gICAgfVxuICAgIC8vIEVtYWlsIC0gbW9yZSBzdHJpY3QgcGF0dGVybiB0byByZWR1Y2UgZmFsc2UgcG9zaXRpdmVzXG4gICAgY29uc3QgZW1haWxQYXR0ZXJuID0gL15bQS1aMC05Ll8lKy1dK0BbQS1aMC05Li1dK1xcLltBLVpdezIsfSQvaTtcbiAgICBpZiAoZW1haWxQYXR0ZXJuLnRlc3QocmF3KSAmJiByYXcuaW5jbHVkZXMoJ0AnKSAmJiByYXcuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICByZXR1cm4geyBraW5kOiAnRU1BSUwnLCByZWFzb246ICdNYXRjaGVzIGVtYWlsIHBhdHRlcm4nLCBjb25maWRlbmNlOiAwLjkgfTtcbiAgICB9XG4gICAgLy8gUGhvbmUgbnVtYmVyIC0gZW5oYW5jZWQgZGV0ZWN0aW9uIHdpdGggZm9ybWF0IHZhbGlkYXRpb25cbiAgICBpZiAoZGlnaXRzT25seS5sZW5ndGggPj0gNyAmJiAvXFxkezMsfS8udGVzdChkaWdpdHNPbmx5KSkge1xuICAgICAgICAvLyBOb3J0aCBBbWVyaWNhbiBmb3JtYXQgKDEwLTExIGRpZ2l0cylcbiAgICAgICAgaWYgKGRpZ2l0c09ubHkubGVuZ3RoID09PSAxMCB8fCAoZGlnaXRzT25seS5sZW5ndGggPT09IDExICYmIGRpZ2l0c09ubHlbMF0gPT09ICcxJykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6ICdQSE9ORScsIHJlYXNvbjogJ05vcnRoIEFtZXJpY2FuIHBob25lIGZvcm1hdCcsIGNvbmZpZGVuY2U6IDAuODUgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlcm5hdGlvbmFsIGZvcm1hdCAoNy0xNSBkaWdpdHMpXG4gICAgICAgIGlmIChkaWdpdHNPbmx5Lmxlbmd0aCA+PSA3ICYmIGRpZ2l0c09ubHkubGVuZ3RoIDw9IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4geyBraW5kOiAnUEhPTkUnLCByZWFzb246ICdJbnRlcm5hdGlvbmFsIHBob25lIGZvcm1hdCcsIGNvbmZpZGVuY2U6IDAuNzUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmhhbmNlZCBhZGRyZXNzIGRldGVjdGlvblxuICAgIGNvbnN0IGFkZHJlc3NSZXN1bHQgPSBpc0FkZHJlc3NDb21wb25lbnQocmF3KTtcbiAgICBpZiAoYWRkcmVzc1Jlc3VsdC5pc0FkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogJ0FERFJFU1MnLCByZWFzb246IGFkZHJlc3NSZXN1bHQucmVhc29uLCBjb25maWRlbmNlOiBhZGRyZXNzUmVzdWx0LmNvbmZpZGVuY2UgfTtcbiAgICB9XG4gICAgLy8gQVdTIGFjY2VzcyBrZXkgaWRcbiAgICBpZiAoaXNBV1NLZXkocmF3KSkge1xuICAgICAgICByZXR1cm4geyBraW5kOiAnQVBJX0tFWScsIHJlYXNvbjogJ0xvb2tzIGxpa2UgYW4gQVdTIGFjY2VzcyBrZXknLCBjb25maWRlbmNlOiAwLjk1IH07XG4gICAgfVxuICAgIC8vIE5hbWVzIChwcm9wZXIgbm91bnMpIC0gZW5oYW5jZWQgd2l0aCBmYWxzZSBwb3NpdGl2ZSByZWR1Y3Rpb25cbiAgICBjb25zdCBuYW1lUGF0dGVybiA9IC9eW0EtWl1bYS16XXsyLH0kLztcbiAgICBpZiAobmFtZVBhdHRlcm4udGVzdChyYXcpICYmICEvXFxkLy50ZXN0KHJhdykgJiYgcmF3LnRvVXBwZXJDYXNlKCkgIT09IHJhdykge1xuICAgICAgICAvLyBFeGNsdWRlIGNvbW1vbiB3b3JkcyB0aGF0IGFyZW4ndCBuYW1lc1xuICAgICAgICBjb25zdCBjb21tb25Xb3JkcyA9IC9eKFRoZXxBbmR8QnV0fEZvcnxBcmV8VGhpc3xUaGF0fFdpdGh8SGF2ZXxXaWxsfEZyb218VGhleXxLbm93fFdhbnR8QmVlbnxHb29kfE11Y2h8U29tZXxUaW1lfFZlcnl8V2hlbnxDb21lfEhlcmV8SnVzdHxMaWtlfExvbmd8TWFrZXxNYW55fE92ZXJ8U3VjaHxUYWtlfFRoYW58VGhlbXxXZWxsfFdlcmV8V2hhdHxZb3VyfEFmdGVyfEJlZm9yZXxDb3VsZHxGaXJzdHxGb3VuZHxHcmVhdHxPdGhlcnxSaWdodHxTaG91bGR8VGhlc2V8V2hlcmV8V2hpY2h8V2hpbGV8V291bGR8WWVhcnN8WW91bmd8QWJvdXR8QWdhaW58UGxhY2V8U3RhdGV8U3RpbGx8VGhpbmt8VGhyZWV8VGhyb3VnaHxVbmRlcnxXYXRlcnxXcml0ZSkkL2k7XG4gICAgICAgIGlmICghY29tbW9uV29yZHMudGVzdChyYXcpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBraW5kOiAnTkFNRScsIHJlYXNvbjogJ0xpa2VseSBwcm9wZXIgbmFtZScsIGNvbmZpZGVuY2U6IDAuNiB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBBcHBseSBjdXN0b20gZGV0ZWN0aW9uIHBhdHRlcm5zIHRvIGEgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEN1c3RvbVBhdHRlcm5zKHRva2VuLCBjdXN0b21QYXR0ZXJucykge1xuICAgIGlmICghY3VzdG9tUGF0dGVybnMgfHwgY3VzdG9tUGF0dGVybnMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgY3VzdG9tUGF0dGVybnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gcGF0dGVybi5jYXNlU2Vuc2l0aXZlID09PSBmYWxzZSA/ICdpJyA6ICcnO1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4ucGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogcGF0dGVybi5raW5kLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGBDdXN0b20gcGF0dGVybjogJHtwYXR0ZXJuLm5hbWV9YCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlkZW5jZTogcGF0dGVybi5jb25maWRlbmNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCByZWdleCBwYXR0ZXJuc1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGN1c3RvbSBwYXR0ZXJuICR7cGF0dGVybi5pZH06ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRW5oYW5jZWQgZGV0ZWN0VG9rZW4gdGhhdCBpbmNsdWRlcyBjdXN0b20gcGF0dGVybiBzdXBwb3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RUb2tlbldpdGhDdXN0b21QYXR0ZXJucyh0b2tlbiwgY3VzdG9tUGF0dGVybnMpIHtcbiAgICAvLyBGaXJzdCBjaGVjayBjdXN0b20gcGF0dGVybnMgKHRoZXkgdGFrZSBwcmVjZWRlbmNlKVxuICAgIGlmIChjdXN0b21QYXR0ZXJucyAmJiBjdXN0b21QYXR0ZXJucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbVJlc3VsdCA9IGRldGVjdEN1c3RvbVBhdHRlcm5zKHRva2VuLCBjdXN0b21QYXR0ZXJucyk7XG4gICAgICAgIGlmIChjdXN0b21SZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tUmVzdWx0O1xuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gc3RhbmRhcmQgZGV0ZWN0aW9uXG4gICAgcmV0dXJuIGRldGVjdFRva2VuKHRva2VuKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../core-detect/dist/detectors/index.js\n"));

/***/ })

});