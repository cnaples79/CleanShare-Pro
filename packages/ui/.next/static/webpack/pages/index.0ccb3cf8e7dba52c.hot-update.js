"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../core-detect/dist/pipeline/apply.js":
/*!*********************************************!*\
  !*** ../core-detect/dist/pipeline/apply.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDocument: function() { return /* binding */ analyzeDocument; },\n/* harmony export */   applyRedactions: function() { return /* binding */ applyRedactions; }\n/* harmony export */ });\n/* harmony import */ var _analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analyze */ \"../core-detect/dist/pipeline/analyze.js\");\n/* harmony import */ var pdf_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdf-lib */ \"../../node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/.pnpm/next@14.1.0_@babel+core@7.28.3_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n// A moduleâ€‘scoped variable to store the last analysis result.  applyRedactions()\n// uses this map to resolve detection IDs to bounding boxes.  In a real\n// application you should pass the detections directly to avoid shared\n// mutable state.  This simplified implementation is sufficient for the\n// demonstration.\nlet lastResult = null;\n/** Override the exported analyse function to capture the last result. */\nasync function analyzeDocument(file, opts = {}) {\n    const result = await (0,_analyze__WEBPACK_IMPORTED_MODULE_1__.analyzeDocument)(file, opts);\n    lastResult = result;\n    return result;\n}\n/** Internal helper: convert a canvas to a data URI. */\nfunction canvasToDataURL(canvas, mimeType = 'image/png', quality = 0.92) {\n    return canvas.toDataURL(mimeType, quality);\n}\n/** Internal helper: convert a File/Blob into a HTMLImageElement. */\nasync function fileToImage(file) {\n    const dataURL = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(file);\n    });\n    const img = new Image();\n    await new Promise(resolve => {\n        img.onload = () => resolve();\n        img.src = dataURL;\n    });\n    return img;\n}\n/** Apply redactions to an image.  Returns a Data URI. */\nasync function applyRedactionsToImage(file, actions, quality = 0.92, detectionResult) {\n    const img = await fileToImage(file);\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        throw new Error('Cannot obtain 2D context');\n    // Draw original image\n    ctx.drawImage(img, 0, 0);\n    // Build detection map\n    const map = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            map.set(det.id, det);\n        }\n    }\n    // Utility helpers for drawing various redaction styles on images\n    function drawBox(x, y, w, h, config = {}) {\n        var _a;\n        const color = config.color || 'black';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const cornerRadius = config.cornerRadius || 0;\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        ctx.fillStyle = color;\n        if (cornerRadius > 0) {\n            // Draw rounded rectangle\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        // Add border if specified\n        if (config.borderWidth && config.borderColor) {\n            ctx.lineWidth = config.borderWidth;\n            ctx.strokeStyle = config.borderColor;\n            if (cornerRadius > 0) {\n                ctx.beginPath();\n                ctx.roundRect(x, y, w, h, cornerRadius);\n                ctx.stroke();\n            }\n            else {\n                ctx.strokeRect(x, y, w, h);\n            }\n        }\n        ctx.restore();\n    }\n    // Enhanced solid color redaction with configuration support\n    function drawSolidColor(x, y, w, h, config = {}) {\n        drawBox(x, y, w, h, config);\n    }\n    // Gradient redaction\n    function drawGradient(x, y, w, h, config = {}) {\n        var _a;\n        const color1 = config.color || 'black';\n        const color2 = config.secondaryColor || 'gray';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        const gradient = ctx.createLinearGradient(x, y, x + w, y + h);\n        gradient.addColorStop(0, color1);\n        gradient.addColorStop(1, color2);\n        ctx.fillStyle = gradient;\n        if (config.cornerRadius && config.cornerRadius > 0) {\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, config.cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        ctx.restore();\n    }\n    // Pattern redaction\n    function drawPattern(x, y, w, h, config = {}) {\n        var _a;\n        const color = config.color || 'black';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const patternType = config.patternType || 'diagonal';\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        // Fill background first\n        ctx.fillStyle = config.secondaryColor || '#f0f0f0';\n        ctx.fillRect(x, y, w, h);\n        // Draw pattern\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2;\n        switch (patternType) {\n            case 'diagonal':\n                for (let i = -h; i < w + h; i += 8) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y);\n                    ctx.lineTo(x + i + h, y + h);\n                    ctx.stroke();\n                }\n                break;\n            case 'dots':\n                const dotSize = 3;\n                const spacing = 8;\n                ctx.fillStyle = color;\n                for (let dx = 0; dx < w; dx += spacing) {\n                    for (let dy = 0; dy < h; dy += spacing) {\n                        ctx.beginPath();\n                        ctx.arc(x + dx + spacing / 2, y + dy + spacing / 2, dotSize / 2, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                }\n                break;\n            case 'cross-hatch':\n                // Diagonal lines one way\n                for (let i = -h; i < w + h; i += 6) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y);\n                    ctx.lineTo(x + i + h, y + h);\n                    ctx.stroke();\n                }\n                // Diagonal lines the other way\n                for (let i = 0; i < w + h; i += 6) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y + h);\n                    ctx.lineTo(x + i - h, y);\n                    ctx.stroke();\n                }\n                break;\n            case 'waves':\n                ctx.beginPath();\n                for (let i = 0; i < w; i += 2) {\n                    const wave = Math.sin((i / w) * Math.PI * 4) * (h * 0.2);\n                    if (i === 0) {\n                        ctx.moveTo(x + i, y + h / 2 + wave);\n                    }\n                    else {\n                        ctx.lineTo(x + i, y + h / 2 + wave);\n                    }\n                }\n                ctx.stroke();\n                break;\n            case 'noise':\n                ctx.fillStyle = color;\n                for (let i = 0; i < w * h / 20; i++) {\n                    const nx = x + Math.random() * w;\n                    const ny = y + Math.random() * h;\n                    ctx.beginPath();\n                    ctx.arc(nx, ny, 1, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                break;\n        }\n        ctx.restore();\n    }\n    // Apply a CSS blur filter to a region by drawing the original image with\n    // the filter enabled only for that region.  Canvas 2D `filter` is\n    // supported in modern browsers.  We temporarily clip the context to\n    // restrict the blur effect to the redaction box.\n    function drawBlur(x, y, w, h) {\n        ctx.save();\n        ctx.filter = 'blur(8px)';\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n        ctx.drawImage(img, 0, 0);\n        ctx.restore();\n    }\n    // Pixelate by drawing the region scaled down and back up.  Choose a\n    // pixel size relative to region size to maintain some obfuscation but\n    // not degrade performance too much.\n    function drawPixelate(x, y, w, h) {\n        const pixelSize = Math.max(4, Math.floor(Math.min(w, h) / 10));\n        // Create a temporary canvas to hold the region scaled down\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = Math.max(1, Math.floor(w / pixelSize));\n        tempCanvas.height = Math.max(1, Math.floor(h / pixelSize));\n        const tctx = tempCanvas.getContext('2d');\n        if (!tctx) {\n            drawBox(x, y, w, h);\n            return;\n        }\n        // Draw the region scaled down onto the temp canvas\n        tctx.drawImage(img, x, y, w, h, 0, 0, tempCanvas.width, tempCanvas.height);\n        // Now draw the scaled up version onto the main canvas to pixelate\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, x, y, w, h);\n        ctx.imageSmoothingEnabled = true;\n    }\n    // Enhanced label drawing with configuration support\n    function drawLabel(x, y, w, h, text, config = {}) {\n        var _a;\n        ctx.save();\n        const bgColor = config.color || 'black';\n        const textColor = config.secondaryColor || 'white';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const fontSize = config.fontSize || Math.max(10, Math.floor(h * 0.6));\n        const fontFamily = config.fontFamily || 'sans-serif';\n        const cornerRadius = config.cornerRadius || 0;\n        ctx.globalAlpha = opacity;\n        // Draw background with optional rounded corners\n        ctx.fillStyle = bgColor;\n        if (cornerRadius > 0) {\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        // Add shadow if specified\n        if (config.shadow) {\n            ctx.shadowOffsetX = config.shadow.offsetX;\n            ctx.shadowOffsetY = config.shadow.offsetY;\n            ctx.shadowBlur = config.shadow.blur;\n            ctx.shadowColor = config.shadow.color;\n        }\n        // Draw text\n        ctx.fillStyle = textColor;\n        ctx.font = `${fontSize}px ${fontFamily}`;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        // Truncate text if it won't fit\n        let label = text;\n        const maxWidth = w - 8; // More padding for better appearance\n        while (ctx.measureText(label).width > maxWidth && label.length > 1) {\n            label = label.slice(0, -1);\n        }\n        if (label !== text && label.length > 0) {\n            label = label.slice(0, -1) + 'â€¦';\n        }\n        ctx.fillText(label, x + w / 2, y + h / 2);\n        ctx.restore();\n    }\n    // Draw a mask that obscures all but the last four characters of the\n    // provided preview text.  The mask uses asterisks for the hidden\n    // portion.  Nonâ€‘digit characters are preserved in their positions.\n    function drawMaskLast4(x, y, w, h, preview) {\n        const text = preview || '';\n        // Keep only last 4 alphanumeric characters; replace preceding\n        // characters (letters or digits) with asterisks but preserve spaces and other symbols.\n        let masked = '';\n        let remaining = 4;\n        for (let i = text.length - 1; i >= 0; i--) {\n            const ch = text[i];\n            if (/\\w/.test(ch) && remaining > 0) {\n                masked = ch + masked;\n                remaining--;\n            }\n            else if (/\\w/.test(ch)) {\n                masked = '*' + masked;\n            }\n            else {\n                masked = ch + masked;\n            }\n        }\n        drawLabel(x, y, w, h, masked);\n    }\n    // Draw redactions using the selected style for each action.  If the\n    // style is not recognised, fallback to a solid box.\n    actions.forEach(action => {\n        const det = map.get(action.detectionId);\n        if (!det)\n            return;\n        const { box } = det;\n        const x = box.x * canvas.width;\n        const y = box.y * canvas.height;\n        const w = box.w * canvas.width;\n        const h = box.h * canvas.height;\n        const config = action.config || {};\n        switch (action.style) {\n            case 'BLUR':\n                drawBlur(x, y, w, h);\n                break;\n            case 'PIXELATE':\n                drawPixelate(x, y, w, h);\n                break;\n            case 'LABEL':\n                const labelText = config.labelText || action.labelText || det.kind;\n                drawLabel(x, y, w, h, labelText, config);\n                break;\n            case 'MASK_LAST4':\n                drawMaskLast4(x, y, w, h, det.preview);\n                break;\n            case 'PATTERN':\n                drawPattern(x, y, w, h, config);\n                break;\n            case 'GRADIENT':\n                drawGradient(x, y, w, h, config);\n                break;\n            case 'SOLID_COLOR':\n                drawSolidColor(x, y, w, h, config);\n                break;\n            case 'VECTOR_OVERLAY':\n                // Vector overlay for images - for now, fall back to enhanced box\n                drawBox(x, y, w, h, config);\n                break;\n            case 'REMOVE_METADATA':\n                // Metadata removal is handled by reâ€‘encoding the image; no\n                // drawing needed for this redaction.\n                break;\n            case 'BOX':\n            default:\n                drawBox(x, y, w, h, config);\n        }\n    });\n    // Apply image sanitization options\n    let outputFormat = 'image/jpeg';\n    let outputQuality = quality;\n    // Always re-encode to strip EXIF/metadata by default\n    // The canvas.toDataURL() method automatically strips metadata\n    return canvas.toDataURL(outputFormat, outputQuality);\n}\n/** Enhanced vector-based PDF redaction with advanced styling support */\nasync function applyRedactionsToPdf(file, actions, detectionResult, options = {}) {\n    var _a, _b;\n    const origBytes = await file.arrayBuffer();\n    const origPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.load(origBytes);\n    const newPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.create();\n    const detectionMap = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            detectionMap.set(det.id, det);\n        }\n    }\n    // Helper function to parse hex color to RGB\n    function parseColor(hexColor) {\n        const hex = hexColor.replace('#', '');\n        const r = parseInt(hex.substr(0, 2), 16) / 255;\n        const g = parseInt(hex.substr(2, 2), 16) / 255;\n        const b = parseInt(hex.substr(4, 2), 16) / 255;\n        return { r, g, b };\n    }\n    // Apply document sanitization if requested\n    if (options.sanitization) {\n        if (options.sanitization.removeMetadata) {\n            // Remove PDF metadata\n            newPdf.setTitle('');\n            newPdf.setAuthor('');\n            newPdf.setSubject('');\n            newPdf.setKeywords('');\n            newPdf.setProducer('');\n            newPdf.setCreator('');\n            newPdf.setCreationDate(new Date(0));\n            newPdf.setModificationDate(new Date(0));\n        }\n    }\n    const total = origPdf.getPageCount();\n    for (let i = 0; i < total; i++) {\n        const [copiedPage] = await newPdf.copyPages(origPdf, [i]);\n        const page = newPdf.addPage(copiedPage);\n        const { width, height } = page.getSize();\n        // Remove annotations if requested\n        if ((_a = options.sanitization) === null || _a === void 0 ? void 0 : _a.removeAnnotations) {\n            // Note: pdf-lib doesn't have direct annotation removal API\n            // This would need custom implementation or different library\n        }\n        // Filter actions for this page\n        const pageActions = actions.filter(act => {\n            var _a;\n            const det = detectionMap.get(act.detectionId);\n            return det && ((_a = det.box.page) !== null && _a !== void 0 ? _a : 0) === i;\n        });\n        // Apply vector-based redactions\n        for (const action of pageActions) {\n            const det = detectionMap.get(action.detectionId);\n            if (!det)\n                continue;\n            const { box } = det;\n            const config = action.config || {};\n            const x = box.x * width;\n            // Convert from top-left origin to PDF bottom-left origin\n            const y = (1 - box.y - box.h) * height;\n            const w = box.w * width;\n            const h = box.h * height;\n            // Parse colors\n            const primaryColor = config.color ? parseColor(config.color) : { r: 0, g: 0, b: 0 };\n            const secondaryColor = config.secondaryColor ? parseColor(config.secondaryColor) : { r: 1, g: 1, b: 1 };\n            const opacity = (_b = config.opacity) !== null && _b !== void 0 ? _b : 1.0;\n            switch (action.style) {\n                case 'BOX':\n                case 'SOLID_COLOR':\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity,\n                        borderColor: config.borderColor ? parseColor(config.borderColor) : undefined,\n                        borderWidth: config.borderWidth || 0\n                    });\n                    break;\n                case 'GRADIENT':\n                    // PDF gradients are complex - use solid color for now\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity\n                    });\n                    break;\n                case 'PATTERN':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryColor.r, secondaryColor.g, secondaryColor.b),\n                        opacity\n                    });\n                    // Add pattern overlay\n                    const patternType = config.patternType || 'diagonal';\n                    const lineColor = (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b);\n                    if (patternType === 'diagonal') {\n                        for (let offset = -h; offset < w + h; offset += 8) {\n                            page.drawLine({\n                                start: { x: x + offset, y: y },\n                                end: { x: x + offset + h, y: y + h },\n                                color: lineColor,\n                                thickness: 2,\n                                opacity\n                            });\n                        }\n                    }\n                    break;\n                case 'VECTOR_OVERLAY':\n                    // Enhanced vector redaction with proper PDF vector operations\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity,\n                        borderColor: config.borderColor ? parseColor(config.borderColor) : undefined,\n                        borderWidth: config.borderWidth || 0\n                    });\n                    break;\n                case 'LABEL':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity\n                    });\n                    // Draw text\n                    const labelText = config.labelText || action.labelText || det.kind;\n                    const fontSize = config.fontSize || Math.max(8, h * 0.6);\n                    const maxChars = Math.floor((w - 8) / (fontSize * 0.6));\n                    let label = labelText;\n                    if (label.length > maxChars) {\n                        label = label.slice(0, maxChars > 3 ? maxChars - 1 : 0) + 'â€¦';\n                    }\n                    const estTextWidth = label.length * fontSize * 0.6;\n                    const xOffset = (w - estTextWidth) / 2;\n                    page.drawText(label, {\n                        x: x + Math.max(0, xOffset),\n                        y: y + h / 2 - fontSize / 2,\n                        size: fontSize,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryColor.r, secondaryColor.g, secondaryColor.b),\n                        opacity\n                    });\n                    break;\n                case 'MASK_LAST4':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity\n                    });\n                    // Create masked text\n                    const preview = det.preview || '';\n                    let masked = '';\n                    let remaining = 4;\n                    for (let i = preview.length - 1; i >= 0; i--) {\n                        const ch = preview[i];\n                        if (/\\w/.test(ch) && remaining > 0) {\n                            masked = ch + masked;\n                            remaining--;\n                        }\n                        else if (/\\w/.test(ch)) {\n                            masked = '*' + masked;\n                        }\n                        else {\n                            masked = ch + masked;\n                        }\n                    }\n                    const maskFontSize = Math.max(8, h * 0.6);\n                    const maskTextWidth = masked.length * maskFontSize * 0.6;\n                    const maskXOffset = (w - maskTextWidth) / 2;\n                    page.drawText(masked, {\n                        x: x + Math.max(0, maskXOffset),\n                        y: y + h / 2 - maskFontSize / 2,\n                        size: maskFontSize,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryColor.r, secondaryColor.g, secondaryColor.b),\n                        opacity\n                    });\n                    break;\n                default:\n                    // Default to solid rectangle\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryColor.r, primaryColor.g, primaryColor.b),\n                        opacity: opacity\n                    });\n            }\n        }\n    }\n    const pdfBytes = await newPdf.save();\n    const base64 = typeof Buffer !== 'undefined' ? Buffer.from(pdfBytes).toString('base64') : btoa(String.fromCharCode(...new Uint8Array(pdfBytes)));\n    return `data:application/pdf;base64,${base64}`;\n}\n/**\n * Apply redactions to a file using the previously analysed detections.\n *\n * Note: This implementation relies on `lastResult` set by analyzeDocument().\n * In a real application you should pass the detections explicitly to avoid\n * hidden state.\n */\nasync function applyRedactions(file, actions, opts, detections) {\n    var _a;\n    // If detections are provided directly, create a temporary result object\n    let result = lastResult;\n    if (detections && detections.length > 0) {\n        result = {\n            detections: detections,\n            pages: Math.max(...detections.map(d => { var _a; return (_a = d.box.page) !== null && _a !== void 0 ? _a : 0; })) + 1 || 1\n        };\n    }\n    if (!result) {\n        throw new Error('No analysis result available.  Call analyzeDocument() first.');\n    }\n    const mime = file.type || '';\n    let fileUri;\n    if (mime === 'application/pdf' || opts.output === 'pdf') {\n        fileUri = await applyRedactionsToPdf(file, actions, result, opts);\n    }\n    else {\n        const quality = (_a = opts.quality) !== null && _a !== void 0 ? _a : 0.92;\n        fileUri = await applyRedactionsToImage(file, actions, quality, result);\n    }\n    // Build a simple report summarising redactions\n    const report = {};\n    if (result) {\n        report.totalDetections = result.detections.length;\n        report.redactedCount = actions.length;\n        const counts = {};\n        for (const action of actions) {\n            const det = result.detections.find(d => d.id === action.detectionId);\n            if (det) {\n                counts[det.kind] = (counts[det.kind] || 0) + 1;\n            }\n        }\n        report.byKind = counts;\n    }\n    return { fileUri, report };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vY29yZS1kZXRlY3QvZGlzdC9waXBlbGluZS9hcHBseS5qcz8xMzczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFuYWx5emVEb2N1bWVudCBhcyBhbmFseXplIH0gZnJvbSAnLi9hbmFseXplJztcbmltcG9ydCB7IFBERkRvY3VtZW50LCByZ2IgfSBmcm9tICdwZGYtbGliJztcbi8vIEEgbW9kdWxl4oCRc2NvcGVkIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBsYXN0IGFuYWx5c2lzIHJlc3VsdC4gIGFwcGx5UmVkYWN0aW9ucygpXG4vLyB1c2VzIHRoaXMgbWFwIHRvIHJlc29sdmUgZGV0ZWN0aW9uIElEcyB0byBib3VuZGluZyBib3hlcy4gIEluIGEgcmVhbFxuLy8gYXBwbGljYXRpb24geW91IHNob3VsZCBwYXNzIHRoZSBkZXRlY3Rpb25zIGRpcmVjdGx5IHRvIGF2b2lkIHNoYXJlZFxuLy8gbXV0YWJsZSBzdGF0ZS4gIFRoaXMgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBpcyBzdWZmaWNpZW50IGZvciB0aGVcbi8vIGRlbW9uc3RyYXRpb24uXG5sZXQgbGFzdFJlc3VsdCA9IG51bGw7XG4vKiogT3ZlcnJpZGUgdGhlIGV4cG9ydGVkIGFuYWx5c2UgZnVuY3Rpb24gdG8gY2FwdHVyZSB0aGUgbGFzdCByZXN1bHQuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZURvY3VtZW50KGZpbGUsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emUoZmlsZSwgb3B0cyk7XG4gICAgbGFzdFJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEludGVybmFsIGhlbHBlcjogY29udmVydCBhIGNhbnZhcyB0byBhIGRhdGEgVVJJLiAqL1xuZnVuY3Rpb24gY2FudmFzVG9EYXRhVVJMKGNhbnZhcywgbWltZVR5cGUgPSAnaW1hZ2UvcG5nJywgcXVhbGl0eSA9IDAuOTIpIHtcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG59XG4vKiogSW50ZXJuYWwgaGVscGVyOiBjb252ZXJ0IGEgRmlsZS9CbG9iIGludG8gYSBIVE1MSW1hZ2VFbGVtZW50LiAqL1xuYXN5bmMgZnVuY3Rpb24gZmlsZVRvSW1hZ2UoZmlsZSkge1xuICAgIGNvbnN0IGRhdGFVUkwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9KTtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgICAgaW1nLnNyYyA9IGRhdGFVUkw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGltZztcbn1cbi8qKiBBcHBseSByZWRhY3Rpb25zIHRvIGFuIGltYWdlLiAgUmV0dXJucyBhIERhdGEgVVJJLiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlSZWRhY3Rpb25zVG9JbWFnZShmaWxlLCBhY3Rpb25zLCBxdWFsaXR5ID0gMC45MiwgZGV0ZWN0aW9uUmVzdWx0KSB7XG4gICAgY29uc3QgaW1nID0gYXdhaXQgZmlsZVRvSW1hZ2UoZmlsZSk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICghY3R4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvYnRhaW4gMkQgY29udGV4dCcpO1xuICAgIC8vIERyYXcgb3JpZ2luYWwgaW1hZ2VcbiAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgLy8gQnVpbGQgZGV0ZWN0aW9uIG1hcFxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZXRlY3Rpb25zVG9Vc2UgPSBkZXRlY3Rpb25SZXN1bHQgfHwgbGFzdFJlc3VsdDtcbiAgICBpZiAoZGV0ZWN0aW9uc1RvVXNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGV0IG9mIGRldGVjdGlvbnNUb1VzZS5kZXRlY3Rpb25zKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGRldC5pZCwgZGV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVdGlsaXR5IGhlbHBlcnMgZm9yIGRyYXdpbmcgdmFyaW91cyByZWRhY3Rpb24gc3R5bGVzIG9uIGltYWdlc1xuICAgIGZ1bmN0aW9uIGRyYXdCb3goeCwgeSwgdywgaCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbmZpZy5jb2xvciB8fCAnYmxhY2snO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKF9hID0gY29uZmlnLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEuMDtcbiAgICAgICAgY29uc3QgY29ybmVyUmFkaXVzID0gY29uZmlnLmNvcm5lclJhZGl1cyB8fCAwO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGlmIChjb3JuZXJSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBEcmF3IHJvdW5kZWQgcmVjdGFuZ2xlXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucm91bmRSZWN0KHgsIHksIHcsIGgsIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBib3JkZXIgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChjb25maWcuYm9yZGVyV2lkdGggJiYgY29uZmlnLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gY29uZmlnLmJvcmRlcldpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29uZmlnLmJvcmRlckNvbG9yO1xuICAgICAgICAgICAgaWYgKGNvcm5lclJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCh4LCB5LCB3LCBoLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2VSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIEVuaGFuY2VkIHNvbGlkIGNvbG9yIHJlZGFjdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gc3VwcG9ydFxuICAgIGZ1bmN0aW9uIGRyYXdTb2xpZENvbG9yKHgsIHksIHcsIGgsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGRyYXdCb3goeCwgeSwgdywgaCwgY29uZmlnKTtcbiAgICB9XG4gICAgLy8gR3JhZGllbnQgcmVkYWN0aW9uXG4gICAgZnVuY3Rpb24gZHJhd0dyYWRpZW50KHgsIHksIHcsIGgsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29sb3IxID0gY29uZmlnLmNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgIGNvbnN0IGNvbG9yMiA9IGNvbmZpZy5zZWNvbmRhcnlDb2xvciB8fCAnZ3JheSc7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAoX2EgPSBjb25maWcub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMS4wO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4ICsgdywgeSArIGgpO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgY29sb3IxKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGNvbG9yMik7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgaWYgKGNvbmZpZy5jb3JuZXJSYWRpdXMgJiYgY29uZmlnLmNvcm5lclJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgY29uZmlnLmNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIFBhdHRlcm4gcmVkYWN0aW9uXG4gICAgZnVuY3Rpb24gZHJhd1BhdHRlcm4oeCwgeSwgdywgaCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb2xvciA9IGNvbmZpZy5jb2xvciB8fCAnYmxhY2snO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKF9hID0gY29uZmlnLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEuMDtcbiAgICAgICAgY29uc3QgcGF0dGVyblR5cGUgPSBjb25maWcucGF0dGVyblR5cGUgfHwgJ2RpYWdvbmFsJztcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgLy8gRmlsbCBiYWNrZ3JvdW5kIGZpcnN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb25maWcuc2Vjb25kYXJ5Q29sb3IgfHwgJyNmMGYwZjAnO1xuICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIC8vIERyYXcgcGF0dGVyblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIHN3aXRjaCAocGF0dGVyblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpYWdvbmFsJzpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gLWg7IGkgPCB3ICsgaDsgaSArPSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgaSwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGkgKyBoLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3RzJzpcbiAgICAgICAgICAgICAgICBjb25zdCBkb3RTaXplID0gMztcbiAgICAgICAgICAgICAgICBjb25zdCBzcGFjaW5nID0gODtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZHggPSAwOyBkeCA8IHc7IGR4ICs9IHNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZHkgPSAwOyBkeSA8IGg7IGR5ICs9IHNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCArIGR4ICsgc3BhY2luZyAvIDIsIHkgKyBkeSArIHNwYWNpbmcgLyAyLCBkb3RTaXplIC8gMiwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nyb3NzLWhhdGNoJzpcbiAgICAgICAgICAgICAgICAvLyBEaWFnb25hbCBsaW5lcyBvbmUgd2F5XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC1oOyBpIDwgdyArIGg7IGkgKz0gNikge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGksIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBpICsgaCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERpYWdvbmFsIGxpbmVzIHRoZSBvdGhlciB3YXlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHcgKyBoOyBpICs9IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyBpLCB5ICsgaCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGkgLSBoLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dhdmVzJzpcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2F2ZSA9IE1hdGguc2luKChpIC8gdykgKiBNYXRoLlBJICogNCkgKiAoaCAqIDAuMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyBpLCB5ICsgaCAvIDIgKyB3YXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGksIHkgKyBoIC8gMiArIHdhdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vaXNlJzpcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ICogaCAvIDIwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnggPSB4ICsgTWF0aC5yYW5kb20oKSAqIHc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG55ID0geSArIE1hdGgucmFuZG9tKCkgKiBoO1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5hcmMobngsIG55LCAxLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgQ1NTIGJsdXIgZmlsdGVyIHRvIGEgcmVnaW9uIGJ5IGRyYXdpbmcgdGhlIG9yaWdpbmFsIGltYWdlIHdpdGhcbiAgICAvLyB0aGUgZmlsdGVyIGVuYWJsZWQgb25seSBmb3IgdGhhdCByZWdpb24uICBDYW52YXMgMkQgYGZpbHRlcmAgaXNcbiAgICAvLyBzdXBwb3J0ZWQgaW4gbW9kZXJuIGJyb3dzZXJzLiAgV2UgdGVtcG9yYXJpbHkgY2xpcCB0aGUgY29udGV4dCB0b1xuICAgIC8vIHJlc3RyaWN0IHRoZSBibHVyIGVmZmVjdCB0byB0aGUgcmVkYWN0aW9uIGJveC5cbiAgICBmdW5jdGlvbiBkcmF3Qmx1cih4LCB5LCB3LCBoKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5maWx0ZXIgPSAnYmx1cig4cHgpJztcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvLyBQaXhlbGF0ZSBieSBkcmF3aW5nIHRoZSByZWdpb24gc2NhbGVkIGRvd24gYW5kIGJhY2sgdXAuICBDaG9vc2UgYVxuICAgIC8vIHBpeGVsIHNpemUgcmVsYXRpdmUgdG8gcmVnaW9uIHNpemUgdG8gbWFpbnRhaW4gc29tZSBvYmZ1c2NhdGlvbiBidXRcbiAgICAvLyBub3QgZGVncmFkZSBwZXJmb3JtYW5jZSB0b28gbXVjaC5cbiAgICBmdW5jdGlvbiBkcmF3UGl4ZWxhdGUoeCwgeSwgdywgaCkge1xuICAgICAgICBjb25zdCBwaXhlbFNpemUgPSBNYXRoLm1heCg0LCBNYXRoLmZsb29yKE1hdGgubWluKHcsIGgpIC8gMTApKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyB0byBob2xkIHRoZSByZWdpb24gc2NhbGVkIGRvd25cbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3IC8gcGl4ZWxTaXplKSk7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihoIC8gcGl4ZWxTaXplKSk7XG4gICAgICAgIGNvbnN0IHRjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghdGN0eCkge1xuICAgICAgICAgICAgZHJhd0JveCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEcmF3IHRoZSByZWdpb24gc2NhbGVkIGRvd24gb250byB0aGUgdGVtcCBjYW52YXNcbiAgICAgICAgdGN0eC5kcmF3SW1hZ2UoaW1nLCB4LCB5LCB3LCBoLCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIC8vIE5vdyBkcmF3IHRoZSBzY2FsZWQgdXAgdmVyc2lvbiBvbnRvIHRoZSBtYWluIGNhbnZhcyB0byBwaXhlbGF0ZVxuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGVtcENhbnZhcywgMCwgMCwgdGVtcENhbnZhcy53aWR0aCwgdGVtcENhbnZhcy5oZWlnaHQsIHgsIHksIHcsIGgpO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRW5oYW5jZWQgbGFiZWwgZHJhd2luZyB3aXRoIGNvbmZpZ3VyYXRpb24gc3VwcG9ydFxuICAgIGZ1bmN0aW9uIGRyYXdMYWJlbCh4LCB5LCB3LCBoLCB0ZXh0LCBjb25maWcgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGNvbnN0IGJnQ29sb3IgPSBjb25maWcuY29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgY29uc3QgdGV4dENvbG9yID0gY29uZmlnLnNlY29uZGFyeUNvbG9yIHx8ICd3aGl0ZSc7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAoX2EgPSBjb25maWcub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMS4wO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGNvbmZpZy5mb250U2l6ZSB8fCBNYXRoLm1heCgxMCwgTWF0aC5mbG9vcihoICogMC42KSk7XG4gICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBjb25maWcuZm9udEZhbWlseSB8fCAnc2Fucy1zZXJpZic7XG4gICAgICAgIGNvbnN0IGNvcm5lclJhZGl1cyA9IGNvbmZpZy5jb3JuZXJSYWRpdXMgfHwgMDtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kIHdpdGggb3B0aW9uYWwgcm91bmRlZCBjb3JuZXJzXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgICBpZiAoY29ybmVyUmFkaXVzID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCh4LCB5LCB3LCBoLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgc2hhZG93IGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAoY29uZmlnLnNoYWRvdykge1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBjb25maWcuc2hhZG93Lm9mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IGNvbmZpZy5zaGFkb3cub2Zmc2V0WTtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gY29uZmlnLnNoYWRvdy5ibHVyO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gY29uZmlnLnNoYWRvdy5jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEcmF3IHRleHRcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgICAgY3R4LmZvbnQgPSBgJHtmb250U2l6ZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIC8vIFRydW5jYXRlIHRleHQgaWYgaXQgd29uJ3QgZml0XG4gICAgICAgIGxldCBsYWJlbCA9IHRleHQ7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gdyAtIDg7IC8vIE1vcmUgcGFkZGluZyBmb3IgYmV0dGVyIGFwcGVhcmFuY2VcbiAgICAgICAgd2hpbGUgKGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGggPiBtYXhXaWR0aCAmJiBsYWJlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwgIT09IHRleHQgJiYgbGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCAtMSkgKyAn4oCmJztcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFRleHQobGFiZWwsIHggKyB3IC8gMiwgeSArIGggLyAyKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLy8gRHJhdyBhIG1hc2sgdGhhdCBvYnNjdXJlcyBhbGwgYnV0IHRoZSBsYXN0IGZvdXIgY2hhcmFjdGVycyBvZiB0aGVcbiAgICAvLyBwcm92aWRlZCBwcmV2aWV3IHRleHQuICBUaGUgbWFzayB1c2VzIGFzdGVyaXNrcyBmb3IgdGhlIGhpZGRlblxuICAgIC8vIHBvcnRpb24uICBOb27igJFkaWdpdCBjaGFyYWN0ZXJzIGFyZSBwcmVzZXJ2ZWQgaW4gdGhlaXIgcG9zaXRpb25zLlxuICAgIGZ1bmN0aW9uIGRyYXdNYXNrTGFzdDQoeCwgeSwgdywgaCwgcHJldmlldykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gcHJldmlldyB8fCAnJztcbiAgICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgNCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyczsgcmVwbGFjZSBwcmVjZWRpbmdcbiAgICAgICAgLy8gY2hhcmFjdGVycyAobGV0dGVycyBvciBkaWdpdHMpIHdpdGggYXN0ZXJpc2tzIGJ1dCBwcmVzZXJ2ZSBzcGFjZXMgYW5kIG90aGVyIHN5bWJvbHMuXG4gICAgICAgIGxldCBtYXNrZWQgPSAnJztcbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSB0ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHRbaV07XG4gICAgICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgJiYgcmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgIG1hc2tlZCA9IGNoICsgbWFza2VkO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL1xcdy8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICBtYXNrZWQgPSAnKicgKyBtYXNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXNrZWQgPSBjaCArIG1hc2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkcmF3TGFiZWwoeCwgeSwgdywgaCwgbWFza2VkKTtcbiAgICB9XG4gICAgLy8gRHJhdyByZWRhY3Rpb25zIHVzaW5nIHRoZSBzZWxlY3RlZCBzdHlsZSBmb3IgZWFjaCBhY3Rpb24uICBJZiB0aGVcbiAgICAvLyBzdHlsZSBpcyBub3QgcmVjb2duaXNlZCwgZmFsbGJhY2sgdG8gYSBzb2xpZCBib3guXG4gICAgYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGRldCA9IG1hcC5nZXQoYWN0aW9uLmRldGVjdGlvbklkKTtcbiAgICAgICAgaWYgKCFkZXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYm94IH0gPSBkZXQ7XG4gICAgICAgIGNvbnN0IHggPSBib3gueCAqIGNhbnZhcy53aWR0aDtcbiAgICAgICAgY29uc3QgeSA9IGJveC55ICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgY29uc3QgdyA9IGJveC53ICogY2FudmFzLndpZHRoO1xuICAgICAgICBjb25zdCBoID0gYm94LmggKiBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjb25maWcgPSBhY3Rpb24uY29uZmlnIHx8IHt9O1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbi5zdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnQkxVUic6XG4gICAgICAgICAgICAgICAgZHJhd0JsdXIoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQSVhFTEFURSc6XG4gICAgICAgICAgICAgICAgZHJhd1BpeGVsYXRlKHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEFCRUwnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IGNvbmZpZy5sYWJlbFRleHQgfHwgYWN0aW9uLmxhYmVsVGV4dCB8fCBkZXQua2luZDtcbiAgICAgICAgICAgICAgICBkcmF3TGFiZWwoeCwgeSwgdywgaCwgbGFiZWxUZXh0LCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTUFTS19MQVNUNCc6XG4gICAgICAgICAgICAgICAgZHJhd01hc2tMYXN0NCh4LCB5LCB3LCBoLCBkZXQucHJldmlldyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQQVRURVJOJzpcbiAgICAgICAgICAgICAgICBkcmF3UGF0dGVybih4LCB5LCB3LCBoLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1JBRElFTlQnOlxuICAgICAgICAgICAgICAgIGRyYXdHcmFkaWVudCh4LCB5LCB3LCBoLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU09MSURfQ09MT1InOlxuICAgICAgICAgICAgICAgIGRyYXdTb2xpZENvbG9yKHgsIHksIHcsIGgsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWRUNUT1JfT1ZFUkxBWSc6XG4gICAgICAgICAgICAgICAgLy8gVmVjdG9yIG92ZXJsYXkgZm9yIGltYWdlcyAtIGZvciBub3csIGZhbGwgYmFjayB0byBlbmhhbmNlZCBib3hcbiAgICAgICAgICAgICAgICBkcmF3Qm94KHgsIHksIHcsIGgsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfTUVUQURBVEEnOlxuICAgICAgICAgICAgICAgIC8vIE1ldGFkYXRhIHJlbW92YWwgaXMgaGFuZGxlZCBieSByZeKAkWVuY29kaW5nIHRoZSBpbWFnZTsgbm9cbiAgICAgICAgICAgICAgICAvLyBkcmF3aW5nIG5lZWRlZCBmb3IgdGhpcyByZWRhY3Rpb24uXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdCT1gnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkcmF3Qm94KHgsIHksIHcsIGgsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBcHBseSBpbWFnZSBzYW5pdGl6YXRpb24gb3B0aW9uc1xuICAgIGxldCBvdXRwdXRGb3JtYXQgPSAnaW1hZ2UvanBlZyc7XG4gICAgbGV0IG91dHB1dFF1YWxpdHkgPSBxdWFsaXR5O1xuICAgIC8vIEFsd2F5cyByZS1lbmNvZGUgdG8gc3RyaXAgRVhJRi9tZXRhZGF0YSBieSBkZWZhdWx0XG4gICAgLy8gVGhlIGNhbnZhcy50b0RhdGFVUkwoKSBtZXRob2QgYXV0b21hdGljYWxseSBzdHJpcHMgbWV0YWRhdGFcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChvdXRwdXRGb3JtYXQsIG91dHB1dFF1YWxpdHkpO1xufVxuLyoqIEVuaGFuY2VkIHZlY3Rvci1iYXNlZCBQREYgcmVkYWN0aW9uIHdpdGggYWR2YW5jZWQgc3R5bGluZyBzdXBwb3J0ICovXG5hc3luYyBmdW5jdGlvbiBhcHBseVJlZGFjdGlvbnNUb1BkZihmaWxlLCBhY3Rpb25zLCBkZXRlY3Rpb25SZXN1bHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3Qgb3JpZ0J5dGVzID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IG9yaWdQZGYgPSBhd2FpdCBQREZEb2N1bWVudC5sb2FkKG9yaWdCeXRlcyk7XG4gICAgY29uc3QgbmV3UGRmID0gYXdhaXQgUERGRG9jdW1lbnQuY3JlYXRlKCk7XG4gICAgY29uc3QgZGV0ZWN0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRldGVjdGlvbnNUb1VzZSA9IGRldGVjdGlvblJlc3VsdCB8fCBsYXN0UmVzdWx0O1xuICAgIGlmIChkZXRlY3Rpb25zVG9Vc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXQgb2YgZGV0ZWN0aW9uc1RvVXNlLmRldGVjdGlvbnMpIHtcbiAgICAgICAgICAgIGRldGVjdGlvbk1hcC5zZXQoZGV0LmlkLCBkZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBoZXggY29sb3IgdG8gUkdCXG4gICAgZnVuY3Rpb24gcGFyc2VDb2xvcihoZXhDb2xvcikge1xuICAgICAgICBjb25zdCBoZXggPSBoZXhDb2xvci5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cigwLCAyKSwgMTYpIC8gMjU1O1xuICAgICAgICBjb25zdCBnID0gcGFyc2VJbnQoaGV4LnN1YnN0cigyLCAyKSwgMTYpIC8gMjU1O1xuICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cig0LCAyKSwgMTYpIC8gMjU1O1xuICAgICAgICByZXR1cm4geyByLCBnLCBiIH07XG4gICAgfVxuICAgIC8vIEFwcGx5IGRvY3VtZW50IHNhbml0aXphdGlvbiBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy5zYW5pdGl6YXRpb24pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2FuaXRpemF0aW9uLnJlbW92ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgUERGIG1ldGFkYXRhXG4gICAgICAgICAgICBuZXdQZGYuc2V0VGl0bGUoJycpO1xuICAgICAgICAgICAgbmV3UGRmLnNldEF1dGhvcignJyk7XG4gICAgICAgICAgICBuZXdQZGYuc2V0U3ViamVjdCgnJyk7XG4gICAgICAgICAgICBuZXdQZGYuc2V0S2V5d29yZHMoJycpO1xuICAgICAgICAgICAgbmV3UGRmLnNldFByb2R1Y2VyKCcnKTtcbiAgICAgICAgICAgIG5ld1BkZi5zZXRDcmVhdG9yKCcnKTtcbiAgICAgICAgICAgIG5ld1BkZi5zZXRDcmVhdGlvbkRhdGUobmV3IERhdGUoMCkpO1xuICAgICAgICAgICAgbmV3UGRmLnNldE1vZGlmaWNhdGlvbkRhdGUobmV3IERhdGUoMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsID0gb3JpZ1BkZi5nZXRQYWdlQ291bnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgY29uc3QgW2NvcGllZFBhZ2VdID0gYXdhaXQgbmV3UGRmLmNvcHlQYWdlcyhvcmlnUGRmLCBbaV0pO1xuICAgICAgICBjb25zdCBwYWdlID0gbmV3UGRmLmFkZFBhZ2UoY29waWVkUGFnZSk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcGFnZS5nZXRTaXplKCk7XG4gICAgICAgIC8vIFJlbW92ZSBhbm5vdGF0aW9ucyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuc2FuaXRpemF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHBkZi1saWIgZG9lc24ndCBoYXZlIGRpcmVjdCBhbm5vdGF0aW9uIHJlbW92YWwgQVBJXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIG5lZWQgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9yIGRpZmZlcmVudCBsaWJyYXJ5XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlsdGVyIGFjdGlvbnMgZm9yIHRoaXMgcGFnZVxuICAgICAgICBjb25zdCBwYWdlQWN0aW9ucyA9IGFjdGlvbnMuZmlsdGVyKGFjdCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSBkZXRlY3Rpb25NYXAuZ2V0KGFjdC5kZXRlY3Rpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4gZGV0ICYmICgoX2EgPSBkZXQuYm94LnBhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID09PSBpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwbHkgdmVjdG9yLWJhc2VkIHJlZGFjdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgcGFnZUFjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldCA9IGRldGVjdGlvbk1hcC5nZXQoYWN0aW9uLmRldGVjdGlvbklkKTtcbiAgICAgICAgICAgIGlmICghZGV0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgeyBib3ggfSA9IGRldDtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGFjdGlvbi5jb25maWcgfHwge307XG4gICAgICAgICAgICBjb25zdCB4ID0gYm94LnggKiB3aWR0aDtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZnJvbSB0b3AtbGVmdCBvcmlnaW4gdG8gUERGIGJvdHRvbS1sZWZ0IG9yaWdpblxuICAgICAgICAgICAgY29uc3QgeSA9ICgxIC0gYm94LnkgLSBib3guaCkgKiBoZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3ID0gYm94LncgKiB3aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGggPSBib3guaCAqIGhlaWdodDtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUNvbG9yID0gY29uZmlnLmNvbG9yID8gcGFyc2VDb2xvcihjb25maWcuY29sb3IpIDogeyByOiAwLCBnOiAwLCBiOiAwIH07XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRhcnlDb2xvciA9IGNvbmZpZy5zZWNvbmRhcnlDb2xvciA/IHBhcnNlQ29sb3IoY29uZmlnLnNlY29uZGFyeUNvbG9yKSA6IHsgcjogMSwgZzogMSwgYjogMSB9O1xuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IChfYiA9IGNvbmZpZy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxLjA7XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0JPWCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU09MSURfQ09MT1InOlxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZ2IocHJpbWFyeUNvbG9yLnIsIHByaW1hcnlDb2xvci5nLCBwcmltYXJ5Q29sb3IuYiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbmZpZy5ib3JkZXJDb2xvciA/IHBhcnNlQ29sb3IoY29uZmlnLmJvcmRlckNvbG9yKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiBjb25maWcuYm9yZGVyV2lkdGggfHwgMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnR1JBRElFTlQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBQREYgZ3JhZGllbnRzIGFyZSBjb21wbGV4IC0gdXNlIHNvbGlkIGNvbG9yIGZvciBub3dcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3UmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiKHByaW1hcnlDb2xvci5yLCBwcmltYXJ5Q29sb3IuZywgcHJpbWFyeUNvbG9yLmIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUEFUVEVSTic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZ2Ioc2Vjb25kYXJ5Q29sb3Iuciwgc2Vjb25kYXJ5Q29sb3IuZywgc2Vjb25kYXJ5Q29sb3IuYiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgcGF0dGVybiBvdmVybGF5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5UeXBlID0gY29uZmlnLnBhdHRlcm5UeXBlIHx8ICdkaWFnb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVDb2xvciA9IHJnYihwcmltYXJ5Q29sb3IuciwgcHJpbWFyeUNvbG9yLmcsIHByaW1hcnlDb2xvci5iKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5UeXBlID09PSAnZGlhZ29uYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAtaDsgb2Zmc2V0IDwgdyArIGg7IG9mZnNldCArPSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3TGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHg6IHggKyBvZmZzZXQsIHk6IHkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB7IHg6IHggKyBvZmZzZXQgKyBoLCB5OiB5ICsgaCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdWRUNUT1JfT1ZFUkxBWSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuaGFuY2VkIHZlY3RvciByZWRhY3Rpb24gd2l0aCBwcm9wZXIgUERGIHZlY3RvciBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1JlY3RhbmdsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihwcmltYXJ5Q29sb3IuciwgcHJpbWFyeUNvbG9yLmcsIHByaW1hcnlDb2xvci5iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogY29uZmlnLmJvcmRlckNvbG9yID8gcGFyc2VDb2xvcihjb25maWcuYm9yZGVyQ29sb3IpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGNvbmZpZy5ib3JkZXJXaWR0aCB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdMQUJFTCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZ2IocHJpbWFyeUNvbG9yLnIsIHByaW1hcnlDb2xvci5nLCBwcmltYXJ5Q29sb3IuYiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gY29uZmlnLmxhYmVsVGV4dCB8fCBhY3Rpb24ubGFiZWxUZXh0IHx8IGRldC5raW5kO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IGNvbmZpZy5mb250U2l6ZSB8fCBNYXRoLm1heCg4LCBoICogMC42KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4Q2hhcnMgPSBNYXRoLmZsb29yKCh3IC0gOCkgLyAoZm9udFNpemUgKiAwLjYpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxUZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwubGVuZ3RoID4gbWF4Q2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgbWF4Q2hhcnMgPiAzID8gbWF4Q2hhcnMgLSAxIDogMCkgKyAn4oCmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RUZXh0V2lkdGggPSBsYWJlbC5sZW5ndGggKiBmb250U2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeE9mZnNldCA9ICh3IC0gZXN0VGV4dFdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1RleHQobGFiZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKyBNYXRoLm1heCgwLCB4T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHkgKyBoIC8gMiAtIGZvbnRTaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihzZWNvbmRhcnlDb2xvci5yLCBzZWNvbmRhcnlDb2xvci5nLCBzZWNvbmRhcnlDb2xvci5iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ01BU0tfTEFTVDQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3UmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiKHByaW1hcnlDb2xvci5yLCBwcmltYXJ5Q29sb3IuZywgcHJpbWFyeUNvbG9yLmIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG1hc2tlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBkZXQucHJldmlldyB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2tlZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpZXcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcHJldmlld1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSAmJiByZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkID0gY2ggKyBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFx3Ly50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZCA9ICcqJyArIG1hc2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZCA9IGNoICsgbWFza2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tGb250U2l6ZSA9IE1hdGgubWF4KDgsIGggKiAwLjYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrVGV4dFdpZHRoID0gbWFza2VkLmxlbmd0aCAqIG1hc2tGb250U2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza1hPZmZzZXQgPSAodyAtIG1hc2tUZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3VGV4dChtYXNrZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKyBNYXRoLm1heCgwLCBtYXNrWE9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5ICsgaCAvIDIgLSBtYXNrRm9udFNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogbWFza0ZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihzZWNvbmRhcnlDb2xvci5yLCBzZWNvbmRhcnlDb2xvci5nLCBzZWNvbmRhcnlDb2xvci5iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gc29saWQgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1JlY3RhbmdsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihwcmltYXJ5Q29sb3IuciwgcHJpbWFyeUNvbG9yLmcsIHByaW1hcnlDb2xvci5iKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGRmQnl0ZXMgPSBhd2FpdCBuZXdQZGYuc2F2ZSgpO1xuICAgIGNvbnN0IGJhc2U2NCA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gQnVmZmVyLmZyb20ocGRmQnl0ZXMpLnRvU3RyaW5nKCdiYXNlNjQnKSA6IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShwZGZCeXRlcykpKTtcbiAgICByZXR1cm4gYGRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwke2Jhc2U2NH1gO1xufVxuLyoqXG4gKiBBcHBseSByZWRhY3Rpb25zIHRvIGEgZmlsZSB1c2luZyB0aGUgcHJldmlvdXNseSBhbmFseXNlZCBkZXRlY3Rpb25zLlxuICpcbiAqIE5vdGU6IFRoaXMgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIGBsYXN0UmVzdWx0YCBzZXQgYnkgYW5hbHl6ZURvY3VtZW50KCkuXG4gKiBJbiBhIHJlYWwgYXBwbGljYXRpb24geW91IHNob3VsZCBwYXNzIHRoZSBkZXRlY3Rpb25zIGV4cGxpY2l0bHkgdG8gYXZvaWRcbiAqIGhpZGRlbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5UmVkYWN0aW9ucyhmaWxlLCBhY3Rpb25zLCBvcHRzLCBkZXRlY3Rpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIElmIGRldGVjdGlvbnMgYXJlIHByb3ZpZGVkIGRpcmVjdGx5LCBjcmVhdGUgYSB0ZW1wb3JhcnkgcmVzdWx0IG9iamVjdFxuICAgIGxldCByZXN1bHQgPSBsYXN0UmVzdWx0O1xuICAgIGlmIChkZXRlY3Rpb25zICYmIGRldGVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBkZXRlY3Rpb25zOiBkZXRlY3Rpb25zLFxuICAgICAgICAgICAgcGFnZXM6IE1hdGgubWF4KC4uLmRldGVjdGlvbnMubWFwKGQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBkLmJveC5wYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwOyB9KSkgKyAxIHx8IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhbmFseXNpcyByZXN1bHQgYXZhaWxhYmxlLiAgQ2FsbCBhbmFseXplRG9jdW1lbnQoKSBmaXJzdC4nKTtcbiAgICB9XG4gICAgY29uc3QgbWltZSA9IGZpbGUudHlwZSB8fCAnJztcbiAgICBsZXQgZmlsZVVyaTtcbiAgICBpZiAobWltZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicgfHwgb3B0cy5vdXRwdXQgPT09ICdwZGYnKSB7XG4gICAgICAgIGZpbGVVcmkgPSBhd2FpdCBhcHBseVJlZGFjdGlvbnNUb1BkZihmaWxlLCBhY3Rpb25zLCByZXN1bHQsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IChfYSA9IG9wdHMucXVhbGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC45MjtcbiAgICAgICAgZmlsZVVyaSA9IGF3YWl0IGFwcGx5UmVkYWN0aW9uc1RvSW1hZ2UoZmlsZSwgYWN0aW9ucywgcXVhbGl0eSwgcmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQnVpbGQgYSBzaW1wbGUgcmVwb3J0IHN1bW1hcmlzaW5nIHJlZGFjdGlvbnNcbiAgICBjb25zdCByZXBvcnQgPSB7fTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlcG9ydC50b3RhbERldGVjdGlvbnMgPSByZXN1bHQuZGV0ZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJlcG9ydC5yZWRhY3RlZENvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSByZXN1bHQuZGV0ZWN0aW9ucy5maW5kKGQgPT4gZC5pZCA9PT0gYWN0aW9uLmRldGVjdGlvbklkKTtcbiAgICAgICAgICAgIGlmIChkZXQpIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbZGV0LmtpbmRdID0gKGNvdW50c1tkZXQua2luZF0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydC5ieUtpbmQgPSBjb3VudHM7XG4gICAgfVxuICAgIHJldHVybiB7IGZpbGVVcmksIHJlcG9ydCB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../core-detect/dist/pipeline/apply.js\n"));

/***/ })

});