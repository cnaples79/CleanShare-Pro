"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../core-detect/dist/presets.js":
/*!**************************************!*\
  !*** ../core-detect/dist/presets.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PRESETS: function() { return /* binding */ PRESETS; },\n/* harmony export */   createPreset: function() { return /* binding */ createPreset; },\n/* harmony export */   deletePreset: function() { return /* binding */ deletePreset; },\n/* harmony export */   duplicatePreset: function() { return /* binding */ duplicatePreset; },\n/* harmony export */   exportAllUserPresets: function() { return /* binding */ exportAllUserPresets; },\n/* harmony export */   exportPreset: function() { return /* binding */ exportPreset; },\n/* harmony export */   getPreset: function() { return /* binding */ getPreset; },\n/* harmony export */   importMultiplePresets: function() { return /* binding */ importMultiplePresets; },\n/* harmony export */   importPreset: function() { return /* binding */ importPreset; },\n/* harmony export */   listBuiltinPresets: function() { return /* binding */ listBuiltinPresets; },\n/* harmony export */   listPresets: function() { return /* binding */ listPresets; },\n/* harmony export */   listPresetsByDomain: function() { return /* binding */ listPresetsByDomain; },\n/* harmony export */   listUserPresets: function() { return /* binding */ listUserPresets; },\n/* harmony export */   resetUserPresets: function() { return /* binding */ resetUserPresets; },\n/* harmony export */   savePreset: function() { return /* binding */ savePreset; },\n/* harmony export */   validatePreset: function() { return /* binding */ validatePreset; }\n/* harmony export */ });\n// Predefined presets.  These can be customised by the user at runtime via the UI.\nconst PRESETS = [\n    {\n        id: 'developer',\n        name: 'Developer Secrets',\n        description: 'Detects technical secrets like API keys, tokens, and database credentials',\n        domain: 'Technology',\n        enabledKinds: ['EMAIL', 'PHONE', 'PAN', 'JWT', 'API_KEY', 'IBAN', 'SSN', 'PASSPORT'],\n        styleMap: {\n            'JWT': 'BOX',\n            'API_KEY': 'BOX',\n            'EMAIL': 'BLUR',\n            'PHONE': 'PIXELATE'\n        },\n        defaultRedactionConfig: {\n            color: '#ff0000',\n            opacity: 0.8\n        },\n        confidenceThreshold: 0.7,\n        customRegex: [],\n        version: '1.0.0'\n    },\n    {\n        id: 'work',\n        name: 'Work Screenshot',\n        description: 'Professional document sanitization for workplace sharing',\n        domain: 'General',\n        enabledKinds: ['EMAIL', 'PHONE', 'PAN', 'JWT', 'API_KEY', 'NAME', 'ADDRESS', 'PASSPORT'],\n        styleMap: {\n            'NAME': 'LABEL',\n            'EMAIL': 'BLUR',\n            'PHONE': 'MASK_LAST4',\n            'ADDRESS': 'BOX'\n        },\n        defaultRedactionConfig: {\n            color: '#000000',\n            opacity: 1.0,\n            labelText: '[REDACTED]'\n        },\n        confidenceThreshold: 0.6,\n        customRegex: [],\n        version: '1.0.0'\n    },\n    {\n        id: 'all',\n        name: 'All Detectors',\n        description: 'Maximum security - detects all types of sensitive information',\n        domain: 'General',\n        enabledKinds: ['FACE', 'EMAIL', 'PHONE', 'PAN', 'IBAN', 'SSN', 'PASSPORT', 'JWT', 'API_KEY', 'BARCODE', 'NAME', 'ADDRESS', 'OTHER'],\n        styleMap: {},\n        defaultRedactionConfig: {\n            color: '#000000',\n            opacity: 0.9\n        },\n        confidenceThreshold: 0.5,\n        customRegex: [],\n        version: '1.0.0'\n    },\n    // Domain-specific preset templates\n    {\n        id: 'healthcare',\n        name: 'Healthcare (HIPAA)',\n        description: 'HIPAA-compliant sanitization for medical documents and communications',\n        domain: 'Healthcare',\n        enabledKinds: ['NAME', 'SSN', 'PHONE', 'EMAIL', 'ADDRESS', 'OTHER'],\n        styleMap: {\n            'SSN': 'BOX',\n            'NAME': 'LABEL',\n            'PHONE': 'MASK_LAST4',\n            'EMAIL': 'BLUR',\n            'ADDRESS': 'BOX'\n        },\n        customPatterns: [\n            {\n                id: 'mrn',\n                name: 'Medical Record Number',\n                pattern: '\\\\b(MRN|Medical Record|Patient ID)\\\\s*:?\\\\s*([A-Z0-9]{6,12})\\\\b',\n                kind: 'OTHER',\n                confidence: 0.9,\n                description: 'Medical record numbers and patient identifiers',\n                caseSensitive: false\n            },\n            {\n                id: 'dob',\n                name: 'Date of Birth',\n                pattern: '\\\\b(DOB|Date of Birth|Born)\\\\s*:?\\\\s*(\\\\d{1,2}[/-]\\\\d{1,2}[/-]\\\\d{2,4})\\\\b',\n                kind: 'OTHER',\n                confidence: 0.8,\n                description: 'Date of birth patterns',\n                caseSensitive: false\n            }\n        ],\n        defaultRedactionConfig: {\n            color: '#000000',\n            opacity: 1.0,\n            labelText: '[PHI REDACTED]'\n        },\n        confidenceThreshold: 0.8,\n        version: '1.0.0'\n    },\n    {\n        id: 'finance',\n        name: 'Financial Services',\n        description: 'Financial document sanitization including PCI DSS compliance',\n        domain: 'Finance',\n        enabledKinds: ['PAN', 'IBAN', 'SSN', 'NAME', 'PHONE', 'EMAIL', 'ADDRESS'],\n        styleMap: {\n            'PAN': 'MASK_LAST4',\n            'IBAN': 'MASK_LAST4',\n            'SSN': 'BOX',\n            'NAME': 'LABEL',\n            'PHONE': 'PIXELATE',\n            'EMAIL': 'BLUR'\n        },\n        customPatterns: [\n            {\n                id: 'account_number',\n                name: 'Account Number',\n                pattern: '\\\\b(Account|Acct)\\\\s*#?:?\\\\s*([0-9]{8,16})\\\\b',\n                kind: 'PAN',\n                confidence: 0.85,\n                description: 'Bank account numbers',\n                caseSensitive: false\n            },\n            {\n                id: 'routing_number',\n                name: 'Routing Number',\n                pattern: '\\\\b(Routing|ABA)\\\\s*#?:?\\\\s*([0-9]{9})\\\\b',\n                kind: 'OTHER',\n                confidence: 0.9,\n                description: 'Bank routing numbers',\n                caseSensitive: false\n            }\n        ],\n        defaultRedactionConfig: {\n            color: '#000000',\n            opacity: 0.95,\n            labelText: '[FINANCIAL INFO]'\n        },\n        confidenceThreshold: 0.75,\n        version: '1.0.0'\n    },\n    {\n        id: 'legal',\n        name: 'Legal Documents',\n        description: 'Attorney-client privilege and legal document sanitization',\n        domain: 'Legal',\n        enabledKinds: ['NAME', 'SSN', 'PHONE', 'EMAIL', 'ADDRESS', 'OTHER'],\n        styleMap: {\n            'NAME': 'LABEL',\n            'SSN': 'BOX',\n            'PHONE': 'BLUR',\n            'EMAIL': 'BLUR',\n            'ADDRESS': 'LABEL'\n        },\n        customPatterns: [\n            {\n                id: 'case_number',\n                name: 'Case Number',\n                pattern: '\\\\b(Case|Cause|Docket)\\\\s*(No\\\\.?|Number|#)\\\\s*:?\\\\s*([A-Z0-9-]{6,20})\\\\b',\n                kind: 'OTHER',\n                confidence: 0.9,\n                description: 'Legal case and docket numbers',\n                caseSensitive: false\n            },\n            {\n                id: 'bar_number',\n                name: 'Bar Number',\n                pattern: '\\\\b(Bar|Attorney)\\\\s*(No\\\\.?|Number|#)\\\\s*:?\\\\s*([A-Z0-9]{5,12})\\\\b',\n                kind: 'OTHER',\n                confidence: 0.85,\n                description: 'Attorney bar numbers',\n                caseSensitive: false\n            }\n        ],\n        defaultRedactionConfig: {\n            color: '#000000',\n            opacity: 1.0,\n            labelText: '[CONFIDENTIAL]'\n        },\n        confidenceThreshold: 0.7,\n        version: '1.0.0'\n    }\n];\n// Local storage key for user presets\nconst USER_PRESETS_KEY = 'cleanshare_user_presets';\n// Load user presets from localStorage on startup\nlet userPresets = [];\ntry {\n    if (typeof localStorage !== 'undefined') {\n        const stored = localStorage.getItem(USER_PRESETS_KEY);\n        if (stored) {\n            userPresets = JSON.parse(stored);\n        }\n    }\n}\ncatch (error) {\n    console.warn('Failed to load user presets from localStorage:', error);\n}\n/** Return all registered presets (built-in + user-created). */\nfunction listPresets() {\n    return [...PRESETS, ...userPresets];\n}\n/** Return only built-in presets. */\nfunction listBuiltinPresets() {\n    return PRESETS.slice();\n}\n/** Return only user-created presets. */\nfunction listUserPresets() {\n    return userPresets.slice();\n}\n/** Return presets filtered by domain. */\nfunction listPresetsByDomain(domain) {\n    return listPresets().filter(p => p.domain === domain);\n}\n/** Lookup a preset by its ID. */\nfunction getPreset(id) {\n    return listPresets().find(p => p.id === id);\n}\n/** Generate a unique preset ID */\nfunction generatePresetId() {\n    return `preset_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n/** Save user presets to localStorage */\nfunction saveUserPresetsToStorage() {\n    try {\n        if (typeof localStorage !== 'undefined') {\n            localStorage.setItem(USER_PRESETS_KEY, JSON.stringify(userPresets));\n        }\n    }\n    catch (error) {\n        console.warn('Failed to save user presets to localStorage:', error);\n    }\n}\n/** Save or update a preset.  If the ID exists, it will be replaced; otherwise it is added. */\nfunction savePreset(preset) {\n    // Ensure preset has required metadata\n    const now = new Date().toISOString();\n    const enhancedPreset = {\n        ...preset,\n        id: preset.id || generatePresetId(),\n        isUserCreated: true,\n        updatedAt: now,\n        createdAt: preset.createdAt || now,\n        version: preset.version || '1.0.0'\n    };\n    // Check if it's a built-in preset\n    const builtinIndex = PRESETS.findIndex(p => p.id === enhancedPreset.id);\n    if (builtinIndex >= 0) {\n        // Don't allow overwriting built-in presets, create a copy instead\n        enhancedPreset.id = generatePresetId();\n        enhancedPreset.name = `${enhancedPreset.name} (Custom)`;\n    }\n    // Save to user presets\n    const userIndex = userPresets.findIndex(p => p.id === enhancedPreset.id);\n    if (userIndex >= 0) {\n        userPresets[userIndex] = enhancedPreset;\n    }\n    else {\n        userPresets.push(enhancedPreset);\n    }\n    saveUserPresetsToStorage();\n}\n/** Create a new preset from scratch */\nfunction createPreset(name, options = {}) {\n    const preset = {\n        id: generatePresetId(),\n        name,\n        description: options.description || '',\n        domain: options.domain || 'General',\n        enabledKinds: options.enabledKinds || [],\n        styleMap: options.styleMap || {},\n        customRegex: options.customRegex || [],\n        customPatterns: options.customPatterns || [],\n        defaultRedactionConfig: options.defaultRedactionConfig || {\n            color: '#000000',\n            opacity: 0.9\n        },\n        confidenceThreshold: options.confidenceThreshold || 0.6,\n        isUserCreated: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        version: '1.0.0'\n    };\n    savePreset(preset);\n    return preset;\n}\n/** Duplicate an existing preset */\nfunction duplicatePreset(id, newName) {\n    const original = getPreset(id);\n    if (!original)\n        return undefined;\n    const preset = {\n        ...original,\n        id: generatePresetId(),\n        name: newName || `${original.name} (Copy)`,\n        isUserCreated: true,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    savePreset(preset);\n    return preset;\n}\n/** Delete a preset by its ID.  Built-in presets cannot be deleted. */\nfunction deletePreset(id) {\n    // Don't allow deleting built-in presets\n    const isBuiltin = PRESETS.some(p => p.id === id);\n    if (isBuiltin)\n        return false;\n    const index = userPresets.findIndex(p => p.id === id);\n    if (index >= 0) {\n        userPresets.splice(index, 1);\n        saveUserPresetsToStorage();\n        return true;\n    }\n    return false;\n}\n/** Validate a preset object */\nfunction validatePreset(preset) {\n    const errors = [];\n    const warnings = [];\n    // Required fields\n    if (!preset.id || typeof preset.id !== 'string') {\n        errors.push('Preset must have a valid ID');\n    }\n    if (!preset.name || typeof preset.name !== 'string') {\n        errors.push('Preset must have a valid name');\n    }\n    if (!Array.isArray(preset.enabledKinds)) {\n        errors.push('Preset must have an enabledKinds array');\n    }\n    // Validate detection kinds\n    const validKinds = ['FACE', 'EMAIL', 'PHONE', 'PAN', 'IBAN', 'SSN', 'PASSPORT', 'JWT', 'API_KEY', 'BARCODE', 'NAME', 'ADDRESS', 'OTHER'];\n    if (preset.enabledKinds) {\n        const invalidKinds = preset.enabledKinds.filter((kind) => !validKinds.includes(kind));\n        if (invalidKinds.length > 0) {\n            warnings.push(`Unknown detection kinds: ${invalidKinds.join(', ')}`);\n        }\n    }\n    // Validate custom patterns\n    if (preset.customPatterns && Array.isArray(preset.customPatterns)) {\n        preset.customPatterns.forEach((pattern, index) => {\n            if (!pattern.id || !pattern.name || !pattern.pattern) {\n                errors.push(`Custom pattern ${index + 1} is missing required fields (id, name, pattern)`);\n            }\n            if (pattern.pattern) {\n                try {\n                    new RegExp(pattern.pattern);\n                }\n                catch (error) {\n                    errors.push(`Custom pattern ${index + 1} has invalid regex: ${pattern.pattern}`);\n                }\n            }\n        });\n    }\n    // Validate confidence threshold\n    if (preset.confidenceThreshold !== undefined) {\n        if (typeof preset.confidenceThreshold !== 'number' || preset.confidenceThreshold < 0 || preset.confidenceThreshold > 1) {\n            warnings.push('Confidence threshold should be a number between 0 and 1');\n        }\n    }\n    return {\n        success: errors.length === 0,\n        preset: errors.length === 0 ? preset : undefined,\n        errors,\n        warnings\n    };\n}\n/** Import a preset from JSON */\nfunction importPreset(json) {\n    try {\n        const data = JSON.parse(json);\n        const validation = validatePreset(data);\n        if (validation.success && validation.preset) {\n            // Check for ID conflicts and generate new ID if needed\n            const existingPreset = getPreset(validation.preset.id);\n            if (existingPreset) {\n                validation.preset.id = generatePresetId();\n                validation.preset.name = `${validation.preset.name} (Imported)`;\n                validation.warnings.push('Preset ID already exists, generated new ID');\n            }\n            // Mark as user-created and update timestamps\n            validation.preset.isUserCreated = true;\n            validation.preset.createdAt = new Date().toISOString();\n            validation.preset.updatedAt = new Date().toISOString();\n            savePreset(validation.preset);\n        }\n        return validation;\n    }\n    catch (error) {\n        return {\n            success: false,\n            errors: [`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown error'}`],\n            warnings: []\n        };\n    }\n}\n/** Export a preset to JSON */\nfunction exportPreset(id, options = {}) {\n    const preset = getPreset(id);\n    if (!preset)\n        return null;\n    const exportData = { ...preset };\n    // Remove metadata if requested\n    if (!options.includeMetadata) {\n        delete exportData.createdAt;\n        delete exportData.updatedAt;\n        delete exportData.isUserCreated;\n    }\n    if (options.format === 'compact') {\n        return JSON.stringify(exportData);\n    }\n    else {\n        return JSON.stringify(exportData, null, 2);\n    }\n}\n/** Export all user presets */\nfunction exportAllUserPresets(options = {}) {\n    const presets = listUserPresets();\n    const exportData = presets.map(preset => {\n        const data = { ...preset };\n        if (!options.includeMetadata) {\n            delete data.createdAt;\n            delete data.updatedAt;\n            delete data.isUserCreated;\n        }\n        return data;\n    });\n    if (options.format === 'compact') {\n        return JSON.stringify(exportData);\n    }\n    else {\n        return JSON.stringify(exportData, null, 2);\n    }\n}\n/** Import multiple presets from JSON array */\nfunction importMultiplePresets(json) {\n    try {\n        const data = JSON.parse(json);\n        if (!Array.isArray(data)) {\n            return [{\n                    success: false,\n                    errors: ['Expected JSON array of presets'],\n                    warnings: []\n                }];\n        }\n        return data.map(presetData => importPreset(JSON.stringify(presetData)));\n    }\n    catch (error) {\n        return [{\n                success: false,\n                errors: [`Invalid JSON: ${error instanceof Error ? error.message : 'Unknown error'}`],\n                warnings: []\n            }];\n    }\n}\n/** Reset all user presets (clear localStorage) */\nfunction resetUserPresets() {\n    userPresets = [];\n    saveUserPresetsToStorage();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseURBQXlEO0FBQ25HO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi9jb3JlLWRldGVjdC9kaXN0L3ByZXNldHMuanM/MjI4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcmVkZWZpbmVkIHByZXNldHMuICBUaGVzZSBjYW4gYmUgY3VzdG9taXNlZCBieSB0aGUgdXNlciBhdCBydW50aW1lIHZpYSB0aGUgVUkuXG5leHBvcnQgY29uc3QgUFJFU0VUUyA9IFtcbiAgICB7XG4gICAgICAgIGlkOiAnZGV2ZWxvcGVyJyxcbiAgICAgICAgbmFtZTogJ0RldmVsb3BlciBTZWNyZXRzJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEZXRlY3RzIHRlY2huaWNhbCBzZWNyZXRzIGxpa2UgQVBJIGtleXMsIHRva2VucywgYW5kIGRhdGFiYXNlIGNyZWRlbnRpYWxzJyxcbiAgICAgICAgZG9tYWluOiAnVGVjaG5vbG9neScsXG4gICAgICAgIGVuYWJsZWRLaW5kczogWydFTUFJTCcsICdQSE9ORScsICdQQU4nLCAnSldUJywgJ0FQSV9LRVknLCAnSUJBTicsICdTU04nLCAnUEFTU1BPUlQnXSxcbiAgICAgICAgc3R5bGVNYXA6IHtcbiAgICAgICAgICAgICdKV1QnOiAnQk9YJyxcbiAgICAgICAgICAgICdBUElfS0VZJzogJ0JPWCcsXG4gICAgICAgICAgICAnRU1BSUwnOiAnQkxVUicsXG4gICAgICAgICAgICAnUEhPTkUnOiAnUElYRUxBVEUnXG4gICAgICAgIH0sXG4gICAgICAgIGRlZmF1bHRSZWRhY3Rpb25Db25maWc6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI2ZmMDAwMCcsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjhcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlkZW5jZVRocmVzaG9sZDogMC43LFxuICAgICAgICBjdXN0b21SZWdleDogW10sXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6ICd3b3JrJyxcbiAgICAgICAgbmFtZTogJ1dvcmsgU2NyZWVuc2hvdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUHJvZmVzc2lvbmFsIGRvY3VtZW50IHNhbml0aXphdGlvbiBmb3Igd29ya3BsYWNlIHNoYXJpbmcnLFxuICAgICAgICBkb21haW46ICdHZW5lcmFsJyxcbiAgICAgICAgZW5hYmxlZEtpbmRzOiBbJ0VNQUlMJywgJ1BIT05FJywgJ1BBTicsICdKV1QnLCAnQVBJX0tFWScsICdOQU1FJywgJ0FERFJFU1MnLCAnUEFTU1BPUlQnXSxcbiAgICAgICAgc3R5bGVNYXA6IHtcbiAgICAgICAgICAgICdOQU1FJzogJ0xBQkVMJyxcbiAgICAgICAgICAgICdFTUFJTCc6ICdCTFVSJyxcbiAgICAgICAgICAgICdQSE9ORSc6ICdNQVNLX0xBU1Q0JyxcbiAgICAgICAgICAgICdBRERSRVNTJzogJ0JPWCdcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFJlZGFjdGlvbkNvbmZpZzoge1xuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ1tSRURBQ1RFRF0nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuNixcbiAgICAgICAgY3VzdG9tUmVnZXg6IFtdLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkOiAnYWxsJyxcbiAgICAgICAgbmFtZTogJ0FsbCBEZXRlY3RvcnMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01heGltdW0gc2VjdXJpdHkgLSBkZXRlY3RzIGFsbCB0eXBlcyBvZiBzZW5zaXRpdmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBkb21haW46ICdHZW5lcmFsJyxcbiAgICAgICAgZW5hYmxlZEtpbmRzOiBbJ0ZBQ0UnLCAnRU1BSUwnLCAnUEhPTkUnLCAnUEFOJywgJ0lCQU4nLCAnU1NOJywgJ1BBU1NQT1JUJywgJ0pXVCcsICdBUElfS0VZJywgJ0JBUkNPREUnLCAnTkFNRScsICdBRERSRVNTJywgJ09USEVSJ10sXG4gICAgICAgIHN0eWxlTWFwOiB7fSxcbiAgICAgICAgZGVmYXVsdFJlZGFjdGlvbkNvbmZpZzoge1xuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICB9LFxuICAgICAgICBjb25maWRlbmNlVGhyZXNob2xkOiAwLjUsXG4gICAgICAgIGN1c3RvbVJlZ2V4OiBbXSxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJ1xuICAgIH0sXG4gICAgLy8gRG9tYWluLXNwZWNpZmljIHByZXNldCB0ZW1wbGF0ZXNcbiAgICB7XG4gICAgICAgIGlkOiAnaGVhbHRoY2FyZScsXG4gICAgICAgIG5hbWU6ICdIZWFsdGhjYXJlIChISVBBQSknLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0hJUEFBLWNvbXBsaWFudCBzYW5pdGl6YXRpb24gZm9yIG1lZGljYWwgZG9jdW1lbnRzIGFuZCBjb21tdW5pY2F0aW9ucycsXG4gICAgICAgIGRvbWFpbjogJ0hlYWx0aGNhcmUnLFxuICAgICAgICBlbmFibGVkS2luZHM6IFsnTkFNRScsICdTU04nLCAnUEhPTkUnLCAnRU1BSUwnLCAnQUREUkVTUycsICdPVEhFUiddLFxuICAgICAgICBzdHlsZU1hcDoge1xuICAgICAgICAgICAgJ1NTTic6ICdCT1gnLFxuICAgICAgICAgICAgJ05BTUUnOiAnTEFCRUwnLFxuICAgICAgICAgICAgJ1BIT05FJzogJ01BU0tfTEFTVDQnLFxuICAgICAgICAgICAgJ0VNQUlMJzogJ0JMVVInLFxuICAgICAgICAgICAgJ0FERFJFU1MnOiAnQk9YJ1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b21QYXR0ZXJuczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnbXJuJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWVkaWNhbCBSZWNvcmQgTnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiAnXFxcXGIoTVJOfE1lZGljYWwgUmVjb3JkfFBhdGllbnQgSUQpXFxcXHMqOj9cXFxccyooW0EtWjAtOV17NiwxMn0pXFxcXGInLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdPVEhFUicsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWVkaWNhbCByZWNvcmQgbnVtYmVycyBhbmQgcGF0aWVudCBpZGVudGlmaWVycycsXG4gICAgICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICdkb2InLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdEYXRlIG9mIEJpcnRoJyxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiAnXFxcXGIoRE9CfERhdGUgb2YgQmlydGh8Qm9ybilcXFxccyo6P1xcXFxzKihcXFxcZHsxLDJ9Wy8tXVxcXFxkezEsMn1bLy1dXFxcXGR7Miw0fSlcXFxcYicsXG4gICAgICAgICAgICAgICAga2luZDogJ09USEVSJyxcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEYXRlIG9mIGJpcnRoIHBhdHRlcm5zJyxcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0UmVkYWN0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wLFxuICAgICAgICAgICAgbGFiZWxUZXh0OiAnW1BISSBSRURBQ1RFRF0nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuOCxcbiAgICAgICAgdmVyc2lvbjogJzEuMC4wJ1xuICAgIH0sXG4gICAge1xuICAgICAgICBpZDogJ2ZpbmFuY2UnLFxuICAgICAgICBuYW1lOiAnRmluYW5jaWFsIFNlcnZpY2VzJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdGaW5hbmNpYWwgZG9jdW1lbnQgc2FuaXRpemF0aW9uIGluY2x1ZGluZyBQQ0kgRFNTIGNvbXBsaWFuY2UnLFxuICAgICAgICBkb21haW46ICdGaW5hbmNlJyxcbiAgICAgICAgZW5hYmxlZEtpbmRzOiBbJ1BBTicsICdJQkFOJywgJ1NTTicsICdOQU1FJywgJ1BIT05FJywgJ0VNQUlMJywgJ0FERFJFU1MnXSxcbiAgICAgICAgc3R5bGVNYXA6IHtcbiAgICAgICAgICAgICdQQU4nOiAnTUFTS19MQVNUNCcsXG4gICAgICAgICAgICAnSUJBTic6ICdNQVNLX0xBU1Q0JyxcbiAgICAgICAgICAgICdTU04nOiAnQk9YJyxcbiAgICAgICAgICAgICdOQU1FJzogJ0xBQkVMJyxcbiAgICAgICAgICAgICdQSE9ORSc6ICdQSVhFTEFURScsXG4gICAgICAgICAgICAnRU1BSUwnOiAnQkxVUidcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tUGF0dGVybnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJ2FjY291bnRfbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQWNjb3VudCBOdW1iZXInLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46ICdcXFxcYihBY2NvdW50fEFjY3QpXFxcXHMqIz86P1xcXFxzKihbMC05XXs4LDE2fSlcXFxcYicsXG4gICAgICAgICAgICAgICAga2luZDogJ1BBTicsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC44NSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0JhbmsgYWNjb3VudCBudW1iZXJzJyxcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJ3JvdXRpbmdfbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnUm91dGluZyBOdW1iZXInLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46ICdcXFxcYihSb3V0aW5nfEFCQSlcXFxccyojPzo/XFxcXHMqKFswLTldezl9KVxcXFxiJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnT1RIRVInLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Jhbmsgcm91dGluZyBudW1iZXJzJyxcbiAgICAgICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0UmVkYWN0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45NSxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ1tGSU5BTkNJQUwgSU5GT10nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZGVuY2VUaHJlc2hvbGQ6IDAuNzUsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWQ6ICdsZWdhbCcsXG4gICAgICAgIG5hbWU6ICdMZWdhbCBEb2N1bWVudHMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0F0dG9ybmV5LWNsaWVudCBwcml2aWxlZ2UgYW5kIGxlZ2FsIGRvY3VtZW50IHNhbml0aXphdGlvbicsXG4gICAgICAgIGRvbWFpbjogJ0xlZ2FsJyxcbiAgICAgICAgZW5hYmxlZEtpbmRzOiBbJ05BTUUnLCAnU1NOJywgJ1BIT05FJywgJ0VNQUlMJywgJ0FERFJFU1MnLCAnT1RIRVInXSxcbiAgICAgICAgc3R5bGVNYXA6IHtcbiAgICAgICAgICAgICdOQU1FJzogJ0xBQkVMJyxcbiAgICAgICAgICAgICdTU04nOiAnQk9YJyxcbiAgICAgICAgICAgICdQSE9ORSc6ICdCTFVSJyxcbiAgICAgICAgICAgICdFTUFJTCc6ICdCTFVSJyxcbiAgICAgICAgICAgICdBRERSRVNTJzogJ0xBQkVMJ1xuICAgICAgICB9LFxuICAgICAgICBjdXN0b21QYXR0ZXJuczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnY2FzZV9udW1iZXInLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdDYXNlIE51bWJlcicsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogJ1xcXFxiKENhc2V8Q2F1c2V8RG9ja2V0KVxcXFxzKihOb1xcXFwuP3xOdW1iZXJ8IylcXFxccyo6P1xcXFxzKihbQS1aMC05LV17NiwyMH0pXFxcXGInLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICdPVEhFUicsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZTogMC45LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGVnYWwgY2FzZSBhbmQgZG9ja2V0IG51bWJlcnMnLFxuICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAnYmFyX251bWJlcicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JhciBOdW1iZXInLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46ICdcXFxcYihCYXJ8QXR0b3JuZXkpXFxcXHMqKE5vXFxcXC4/fE51bWJlcnwjKVxcXFxzKjo/XFxcXHMqKFtBLVowLTldezUsMTJ9KVxcXFxiJyxcbiAgICAgICAgICAgICAgICBraW5kOiAnT1RIRVInLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuODUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdBdHRvcm5leSBiYXIgbnVtYmVycycsXG4gICAgICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdFJlZGFjdGlvbkNvbmZpZzoge1xuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMCxcbiAgICAgICAgICAgIGxhYmVsVGV4dDogJ1tDT05GSURFTlRJQUxdJ1xuICAgICAgICB9LFxuICAgICAgICBjb25maWRlbmNlVGhyZXNob2xkOiAwLjcsXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICB9XG5dO1xuLy8gTG9jYWwgc3RvcmFnZSBrZXkgZm9yIHVzZXIgcHJlc2V0c1xuY29uc3QgVVNFUl9QUkVTRVRTX0tFWSA9ICdjbGVhbnNoYXJlX3VzZXJfcHJlc2V0cyc7XG4vLyBMb2FkIHVzZXIgcHJlc2V0cyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBzdGFydHVwXG5sZXQgdXNlclByZXNldHMgPSBbXTtcbnRyeSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFVTRVJfUFJFU0VUU19LRVkpO1xuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICB1c2VyUHJlc2V0cyA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgdXNlciBwcmVzZXRzIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbn1cbi8qKiBSZXR1cm4gYWxsIHJlZ2lzdGVyZWQgcHJlc2V0cyAoYnVpbHQtaW4gKyB1c2VyLWNyZWF0ZWQpLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RQcmVzZXRzKCkge1xuICAgIHJldHVybiBbLi4uUFJFU0VUUywgLi4udXNlclByZXNldHNdO1xufVxuLyoqIFJldHVybiBvbmx5IGJ1aWx0LWluIHByZXNldHMuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdEJ1aWx0aW5QcmVzZXRzKCkge1xuICAgIHJldHVybiBQUkVTRVRTLnNsaWNlKCk7XG59XG4vKiogUmV0dXJuIG9ubHkgdXNlci1jcmVhdGVkIHByZXNldHMuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdFVzZXJQcmVzZXRzKCkge1xuICAgIHJldHVybiB1c2VyUHJlc2V0cy5zbGljZSgpO1xufVxuLyoqIFJldHVybiBwcmVzZXRzIGZpbHRlcmVkIGJ5IGRvbWFpbi4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0UHJlc2V0c0J5RG9tYWluKGRvbWFpbikge1xuICAgIHJldHVybiBsaXN0UHJlc2V0cygpLmZpbHRlcihwID0+IHAuZG9tYWluID09PSBkb21haW4pO1xufVxuLyoqIExvb2t1cCBhIHByZXNldCBieSBpdHMgSUQuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlc2V0KGlkKSB7XG4gICAgcmV0dXJuIGxpc3RQcmVzZXRzKCkuZmluZChwID0+IHAuaWQgPT09IGlkKTtcbn1cbi8qKiBHZW5lcmF0ZSBhIHVuaXF1ZSBwcmVzZXQgSUQgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJlc2V0SWQoKSB7XG4gICAgcmV0dXJuIGBwcmVzZXRfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xufVxuLyoqIFNhdmUgdXNlciBwcmVzZXRzIHRvIGxvY2FsU3RvcmFnZSAqL1xuZnVuY3Rpb24gc2F2ZVVzZXJQcmVzZXRzVG9TdG9yYWdlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUl9QUkVTRVRTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlclByZXNldHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSB1c2VyIHByZXNldHMgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG59XG4vKiogU2F2ZSBvciB1cGRhdGUgYSBwcmVzZXQuICBJZiB0aGUgSUQgZXhpc3RzLCBpdCB3aWxsIGJlIHJlcGxhY2VkOyBvdGhlcndpc2UgaXQgaXMgYWRkZWQuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVByZXNldChwcmVzZXQpIHtcbiAgICAvLyBFbnN1cmUgcHJlc2V0IGhhcyByZXF1aXJlZCBtZXRhZGF0YVxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBlbmhhbmNlZFByZXNldCA9IHtcbiAgICAgICAgLi4ucHJlc2V0LFxuICAgICAgICBpZDogcHJlc2V0LmlkIHx8IGdlbmVyYXRlUHJlc2V0SWQoKSxcbiAgICAgICAgaXNVc2VyQ3JlYXRlZDogdHJ1ZSxcbiAgICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICAgIGNyZWF0ZWRBdDogcHJlc2V0LmNyZWF0ZWRBdCB8fCBub3csXG4gICAgICAgIHZlcnNpb246IHByZXNldC52ZXJzaW9uIHx8ICcxLjAuMCdcbiAgICB9O1xuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBidWlsdC1pbiBwcmVzZXRcbiAgICBjb25zdCBidWlsdGluSW5kZXggPSBQUkVTRVRTLmZpbmRJbmRleChwID0+IHAuaWQgPT09IGVuaGFuY2VkUHJlc2V0LmlkKTtcbiAgICBpZiAoYnVpbHRpbkluZGV4ID49IDApIHtcbiAgICAgICAgLy8gRG9uJ3QgYWxsb3cgb3ZlcndyaXRpbmcgYnVpbHQtaW4gcHJlc2V0cywgY3JlYXRlIGEgY29weSBpbnN0ZWFkXG4gICAgICAgIGVuaGFuY2VkUHJlc2V0LmlkID0gZ2VuZXJhdGVQcmVzZXRJZCgpO1xuICAgICAgICBlbmhhbmNlZFByZXNldC5uYW1lID0gYCR7ZW5oYW5jZWRQcmVzZXQubmFtZX0gKEN1c3RvbSlgO1xuICAgIH1cbiAgICAvLyBTYXZlIHRvIHVzZXIgcHJlc2V0c1xuICAgIGNvbnN0IHVzZXJJbmRleCA9IHVzZXJQcmVzZXRzLmZpbmRJbmRleChwID0+IHAuaWQgPT09IGVuaGFuY2VkUHJlc2V0LmlkKTtcbiAgICBpZiAodXNlckluZGV4ID49IDApIHtcbiAgICAgICAgdXNlclByZXNldHNbdXNlckluZGV4XSA9IGVuaGFuY2VkUHJlc2V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXNlclByZXNldHMucHVzaChlbmhhbmNlZFByZXNldCk7XG4gICAgfVxuICAgIHNhdmVVc2VyUHJlc2V0c1RvU3RvcmFnZSgpO1xufVxuLyoqIENyZWF0ZSBhIG5ldyBwcmVzZXQgZnJvbSBzY3JhdGNoICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJlc2V0KG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByZXNldCA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlUHJlc2V0SWQoKSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgIGRvbWFpbjogb3B0aW9ucy5kb21haW4gfHwgJ0dlbmVyYWwnLFxuICAgICAgICBlbmFibGVkS2luZHM6IG9wdGlvbnMuZW5hYmxlZEtpbmRzIHx8IFtdLFxuICAgICAgICBzdHlsZU1hcDogb3B0aW9ucy5zdHlsZU1hcCB8fCB7fSxcbiAgICAgICAgY3VzdG9tUmVnZXg6IG9wdGlvbnMuY3VzdG9tUmVnZXggfHwgW10sXG4gICAgICAgIGN1c3RvbVBhdHRlcm5zOiBvcHRpb25zLmN1c3RvbVBhdHRlcm5zIHx8IFtdLFxuICAgICAgICBkZWZhdWx0UmVkYWN0aW9uQ29uZmlnOiBvcHRpb25zLmRlZmF1bHRSZWRhY3Rpb25Db25maWcgfHwge1xuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICB9LFxuICAgICAgICBjb25maWRlbmNlVGhyZXNob2xkOiBvcHRpb25zLmNvbmZpZGVuY2VUaHJlc2hvbGQgfHwgMC42LFxuICAgICAgICBpc1VzZXJDcmVhdGVkOiB0cnVlLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHZlcnNpb246ICcxLjAuMCdcbiAgICB9O1xuICAgIHNhdmVQcmVzZXQocHJlc2V0KTtcbiAgICByZXR1cm4gcHJlc2V0O1xufVxuLyoqIER1cGxpY2F0ZSBhbiBleGlzdGluZyBwcmVzZXQgKi9cbmV4cG9ydCBmdW5jdGlvbiBkdXBsaWNhdGVQcmVzZXQoaWQsIG5ld05hbWUpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGdldFByZXNldChpZCk7XG4gICAgaWYgKCFvcmlnaW5hbClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcmVzZXQgPSB7XG4gICAgICAgIC4uLm9yaWdpbmFsLFxuICAgICAgICBpZDogZ2VuZXJhdGVQcmVzZXRJZCgpLFxuICAgICAgICBuYW1lOiBuZXdOYW1lIHx8IGAke29yaWdpbmFsLm5hbWV9IChDb3B5KWAsXG4gICAgICAgIGlzVXNlckNyZWF0ZWQ6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgc2F2ZVByZXNldChwcmVzZXQpO1xuICAgIHJldHVybiBwcmVzZXQ7XG59XG4vKiogRGVsZXRlIGEgcHJlc2V0IGJ5IGl0cyBJRC4gIEJ1aWx0LWluIHByZXNldHMgY2Fubm90IGJlIGRlbGV0ZWQuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUHJlc2V0KGlkKSB7XG4gICAgLy8gRG9uJ3QgYWxsb3cgZGVsZXRpbmcgYnVpbHQtaW4gcHJlc2V0c1xuICAgIGNvbnN0IGlzQnVpbHRpbiA9IFBSRVNFVFMuc29tZShwID0+IHAuaWQgPT09IGlkKTtcbiAgICBpZiAoaXNCdWlsdGluKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaW5kZXggPSB1c2VyUHJlc2V0cy5maW5kSW5kZXgocCA9PiBwLmlkID09PSBpZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdXNlclByZXNldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgc2F2ZVVzZXJQcmVzZXRzVG9TdG9yYWdlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKiogVmFsaWRhdGUgYSBwcmVzZXQgb2JqZWN0ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcmVzZXQocHJlc2V0KSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICAvLyBSZXF1aXJlZCBmaWVsZHNcbiAgICBpZiAoIXByZXNldC5pZCB8fCB0eXBlb2YgcHJlc2V0LmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvcnMucHVzaCgnUHJlc2V0IG11c3QgaGF2ZSBhIHZhbGlkIElEJyk7XG4gICAgfVxuICAgIGlmICghcHJlc2V0Lm5hbWUgfHwgdHlwZW9mIHByZXNldC5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvcnMucHVzaCgnUHJlc2V0IG11c3QgaGF2ZSBhIHZhbGlkIG5hbWUnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXNldC5lbmFibGVkS2luZHMpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKCdQcmVzZXQgbXVzdCBoYXZlIGFuIGVuYWJsZWRLaW5kcyBhcnJheScpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBkZXRlY3Rpb24ga2luZHNcbiAgICBjb25zdCB2YWxpZEtpbmRzID0gWydGQUNFJywgJ0VNQUlMJywgJ1BIT05FJywgJ1BBTicsICdJQkFOJywgJ1NTTicsICdQQVNTUE9SVCcsICdKV1QnLCAnQVBJX0tFWScsICdCQVJDT0RFJywgJ05BTUUnLCAnQUREUkVTUycsICdPVEhFUiddO1xuICAgIGlmIChwcmVzZXQuZW5hYmxlZEtpbmRzKSB7XG4gICAgICAgIGNvbnN0IGludmFsaWRLaW5kcyA9IHByZXNldC5lbmFibGVkS2luZHMuZmlsdGVyKChraW5kKSA9PiAhdmFsaWRLaW5kcy5pbmNsdWRlcyhraW5kKSk7XG4gICAgICAgIGlmIChpbnZhbGlkS2luZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChgVW5rbm93biBkZXRlY3Rpb24ga2luZHM6ICR7aW52YWxpZEtpbmRzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgY3VzdG9tIHBhdHRlcm5zXG4gICAgaWYgKHByZXNldC5jdXN0b21QYXR0ZXJucyAmJiBBcnJheS5pc0FycmF5KHByZXNldC5jdXN0b21QYXR0ZXJucykpIHtcbiAgICAgICAgcHJlc2V0LmN1c3RvbVBhdHRlcm5zLmZvckVhY2goKHBhdHRlcm4sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4uaWQgfHwgIXBhdHRlcm4ubmFtZSB8fCAhcGF0dGVybi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYEN1c3RvbSBwYXR0ZXJuICR7aW5kZXggKyAxfSBpcyBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcyAoaWQsIG5hbWUsIHBhdHRlcm4pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0dGVybi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYEN1c3RvbSBwYXR0ZXJuICR7aW5kZXggKyAxfSBoYXMgaW52YWxpZCByZWdleDogJHtwYXR0ZXJuLnBhdHRlcm59YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgY29uZmlkZW5jZSB0aHJlc2hvbGRcbiAgICBpZiAocHJlc2V0LmNvbmZpZGVuY2VUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZXNldC5jb25maWRlbmNlVGhyZXNob2xkICE9PSAnbnVtYmVyJyB8fCBwcmVzZXQuY29uZmlkZW5jZVRocmVzaG9sZCA8IDAgfHwgcHJlc2V0LmNvbmZpZGVuY2VUaHJlc2hvbGQgPiAxKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCdDb25maWRlbmNlIHRocmVzaG9sZCBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgcHJlc2V0OiBlcnJvcnMubGVuZ3RoID09PSAwID8gcHJlc2V0IDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIHdhcm5pbmdzXG4gICAgfTtcbn1cbi8qKiBJbXBvcnQgYSBwcmVzZXQgZnJvbSBKU09OICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0UHJlc2V0KGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlUHJlc2V0KGRhdGEpO1xuICAgICAgICBpZiAodmFsaWRhdGlvbi5zdWNjZXNzICYmIHZhbGlkYXRpb24ucHJlc2V0KSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgSUQgY29uZmxpY3RzIGFuZCBnZW5lcmF0ZSBuZXcgSUQgaWYgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1ByZXNldCA9IGdldFByZXNldCh2YWxpZGF0aW9uLnByZXNldC5pZCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdQcmVzZXQpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnByZXNldC5pZCA9IGdlbmVyYXRlUHJlc2V0SWQoKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnByZXNldC5uYW1lID0gYCR7dmFsaWRhdGlvbi5wcmVzZXQubmFtZX0gKEltcG9ydGVkKWA7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbi53YXJuaW5ncy5wdXNoKCdQcmVzZXQgSUQgYWxyZWFkeSBleGlzdHMsIGdlbmVyYXRlZCBuZXcgSUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgYXMgdXNlci1jcmVhdGVkIGFuZCB1cGRhdGUgdGltZXN0YW1wc1xuICAgICAgICAgICAgdmFsaWRhdGlvbi5wcmVzZXQuaXNVc2VyQ3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLnByZXNldC5jcmVhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLnByZXNldC51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBzYXZlUHJlc2V0KHZhbGlkYXRpb24ucHJlc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGlvbjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yczogW2BJbnZhbGlkIEpTT046ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YF0sXG4gICAgICAgICAgICB3YXJuaW5nczogW11cbiAgICAgICAgfTtcbiAgICB9XG59XG4vKiogRXhwb3J0IGEgcHJlc2V0IHRvIEpTT04gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRQcmVzZXQoaWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByZXNldCA9IGdldFByZXNldChpZCk7XG4gICAgaWYgKCFwcmVzZXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGV4cG9ydERhdGEgPSB7IC4uLnByZXNldCB9O1xuICAgIC8vIFJlbW92ZSBtZXRhZGF0YSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZU1ldGFkYXRhKSB7XG4gICAgICAgIGRlbGV0ZSBleHBvcnREYXRhLmNyZWF0ZWRBdDtcbiAgICAgICAgZGVsZXRlIGV4cG9ydERhdGEudXBkYXRlZEF0O1xuICAgICAgICBkZWxldGUgZXhwb3J0RGF0YS5pc1VzZXJDcmVhdGVkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdjb21wYWN0Jykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMik7XG4gICAgfVxufVxuLyoqIEV4cG9ydCBhbGwgdXNlciBwcmVzZXRzICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0QWxsVXNlclByZXNldHMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcHJlc2V0cyA9IGxpc3RVc2VyUHJlc2V0cygpO1xuICAgIGNvbnN0IGV4cG9ydERhdGEgPSBwcmVzZXRzLm1hcChwcmVzZXQgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5wcmVzZXQgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmluY2x1ZGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuY3JlYXRlZEF0O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEudXBkYXRlZEF0O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuaXNVc2VyQ3JlYXRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdjb21wYWN0Jykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMik7XG4gICAgfVxufVxuLyoqIEltcG9ydCBtdWx0aXBsZSBwcmVzZXRzIGZyb20gSlNPTiBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydE11bHRpcGxlUHJlc2V0cyhqc29uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFsnRXhwZWN0ZWQgSlNPTiBhcnJheSBvZiBwcmVzZXRzJ10sXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLm1hcChwcmVzZXREYXRhID0+IGltcG9ydFByZXNldChKU09OLnN0cmluZ2lmeShwcmVzZXREYXRhKSkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbYEludmFsaWQgSlNPTjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gXSxcbiAgICAgICAgICAgICAgICB3YXJuaW5nczogW11cbiAgICAgICAgICAgIH1dO1xuICAgIH1cbn1cbi8qKiBSZXNldCBhbGwgdXNlciBwcmVzZXRzIChjbGVhciBsb2NhbFN0b3JhZ2UpICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRVc2VyUHJlc2V0cygpIHtcbiAgICB1c2VyUHJlc2V0cyA9IFtdO1xuICAgIHNhdmVVc2VyUHJlc2V0c1RvU3RvcmFnZSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../core-detect/dist/presets.js\n"));

/***/ })

});