"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../core-detect/dist/pipeline/apply.js":
/*!*********************************************!*\
  !*** ../core-detect/dist/pipeline/apply.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDocument: function() { return /* binding */ analyzeDocument; },\n/* harmony export */   applyRedactions: function() { return /* binding */ applyRedactions; }\n/* harmony export */ });\n/* harmony import */ var _analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analyze */ \"../core-detect/dist/pipeline/analyze.js\");\n/* harmony import */ var pdf_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdf-lib */ \"../../node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/.pnpm/next@14.1.0_@babel+core@7.28.3_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n// A moduleâ€‘scoped variable to store the last analysis result.  applyRedactions()\n// uses this map to resolve detection IDs to bounding boxes.  In a real\n// application you should pass the detections directly to avoid shared\n// mutable state.  This simplified implementation is sufficient for the\n// demonstration.\nlet lastResult = null;\n/** Override the exported analyse function to capture the last result. */\nasync function analyzeDocument(file, opts = {}) {\n    const result = await (0,_analyze__WEBPACK_IMPORTED_MODULE_1__.analyzeDocument)(file, opts);\n    lastResult = result;\n    return result;\n}\n/** Internal helper: convert a canvas to a data URI. */\nfunction canvasToDataURL(canvas, mimeType = 'image/png', quality = 0.92) {\n    return canvas.toDataURL(mimeType, quality);\n}\n/** Internal helper: convert a File/Blob into a HTMLImageElement. */\nasync function fileToImage(file) {\n    const dataURL = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(file);\n    });\n    const img = new Image();\n    await new Promise(resolve => {\n        img.onload = () => resolve();\n        img.src = dataURL;\n    });\n    return img;\n}\n/** Apply redactions to an image.  Returns a Data URI. */\nasync function applyRedactionsToImage(file, actions, quality = 0.92, detectionResult) {\n    const img = await fileToImage(file);\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        throw new Error('Cannot obtain 2D context');\n    // Draw original image\n    ctx.drawImage(img, 0, 0);\n    // Build detection map\n    const map = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            map.set(det.id, det);\n        }\n    }\n    // Utility helpers for drawing various redaction styles on images\n    function drawBox(x, y, w, h, config = {}) {\n        var _a;\n        const color = config.color || 'black';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const cornerRadius = config.cornerRadius || 0;\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        ctx.fillStyle = color;\n        if (cornerRadius > 0) {\n            // Draw rounded rectangle\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        // Add border if specified\n        if (config.borderWidth && config.borderColor) {\n            ctx.lineWidth = config.borderWidth;\n            ctx.strokeStyle = config.borderColor;\n            if (cornerRadius > 0) {\n                ctx.beginPath();\n                ctx.roundRect(x, y, w, h, cornerRadius);\n                ctx.stroke();\n            }\n            else {\n                ctx.strokeRect(x, y, w, h);\n            }\n        }\n        ctx.restore();\n    }\n    // Enhanced solid color redaction with configuration support\n    function drawSolidColor(x, y, w, h, config = {}) {\n        drawBox(x, y, w, h, config);\n    }\n    // Gradient redaction\n    function drawGradient(x, y, w, h, config = {}) {\n        var _a;\n        const color1 = config.color || 'black';\n        const color2 = config.secondaryColor || 'gray';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        const gradient = ctx.createLinearGradient(x, y, x + w, y + h);\n        gradient.addColorStop(0, color1);\n        gradient.addColorStop(1, color2);\n        ctx.fillStyle = gradient;\n        if (config.cornerRadius && config.cornerRadius > 0) {\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, config.cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        ctx.restore();\n    }\n    // Pattern redaction\n    function drawPattern(x, y, w, h, config = {}) {\n        var _a;\n        const color = config.color || 'black';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const patternType = config.patternType || 'diagonal';\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        // Fill background first\n        ctx.fillStyle = config.secondaryColor || '#f0f0f0';\n        ctx.fillRect(x, y, w, h);\n        // Draw pattern\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2;\n        switch (patternType) {\n            case 'diagonal':\n                for (let i = -h; i < w + h; i += 8) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y);\n                    ctx.lineTo(x + i + h, y + h);\n                    ctx.stroke();\n                }\n                break;\n            case 'dots':\n                const dotSize = 3;\n                const spacing = 8;\n                ctx.fillStyle = color;\n                for (let dx = 0; dx < w; dx += spacing) {\n                    for (let dy = 0; dy < h; dy += spacing) {\n                        ctx.beginPath();\n                        ctx.arc(x + dx + spacing / 2, y + dy + spacing / 2, dotSize / 2, 0, Math.PI * 2);\n                        ctx.fill();\n                    }\n                }\n                break;\n            case 'cross-hatch':\n                // Diagonal lines one way\n                for (let i = -h; i < w + h; i += 6) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y);\n                    ctx.lineTo(x + i + h, y + h);\n                    ctx.stroke();\n                }\n                // Diagonal lines the other way\n                for (let i = 0; i < w + h; i += 6) {\n                    ctx.beginPath();\n                    ctx.moveTo(x + i, y + h);\n                    ctx.lineTo(x + i - h, y);\n                    ctx.stroke();\n                }\n                break;\n            case 'waves':\n                ctx.beginPath();\n                for (let i = 0; i < w; i += 2) {\n                    const wave = Math.sin((i / w) * Math.PI * 4) * (h * 0.2);\n                    if (i === 0) {\n                        ctx.moveTo(x + i, y + h / 2 + wave);\n                    }\n                    else {\n                        ctx.lineTo(x + i, y + h / 2 + wave);\n                    }\n                }\n                ctx.stroke();\n                break;\n            case 'noise':\n                ctx.fillStyle = color;\n                for (let i = 0; i < w * h / 20; i++) {\n                    const nx = x + Math.random() * w;\n                    const ny = y + Math.random() * h;\n                    ctx.beginPath();\n                    ctx.arc(nx, ny, 1, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                break;\n        }\n        ctx.restore();\n    }\n    // Apply a CSS blur filter to a region by drawing the original image with\n    // the filter enabled only for that region.  Canvas 2D `filter` is\n    // supported in modern browsers.  We temporarily clip the context to\n    // restrict the blur effect to the redaction box.\n    function drawBlur(x, y, w, h) {\n        ctx.save();\n        ctx.filter = 'blur(8px)';\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n        ctx.drawImage(img, 0, 0);\n        ctx.restore();\n    }\n    // Pixelate by drawing the region scaled down and back up.  Choose a\n    // pixel size relative to region size to maintain some obfuscation but\n    // not degrade performance too much.\n    function drawPixelate(x, y, w, h) {\n        const pixelSize = Math.max(4, Math.floor(Math.min(w, h) / 10));\n        // Create a temporary canvas to hold the region scaled down\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = Math.max(1, Math.floor(w / pixelSize));\n        tempCanvas.height = Math.max(1, Math.floor(h / pixelSize));\n        const tctx = tempCanvas.getContext('2d');\n        if (!tctx) {\n            drawBox(x, y, w, h);\n            return;\n        }\n        // Draw the region scaled down onto the temp canvas\n        tctx.drawImage(img, x, y, w, h, 0, 0, tempCanvas.width, tempCanvas.height);\n        // Now draw the scaled up version onto the main canvas to pixelate\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, x, y, w, h);\n        ctx.imageSmoothingEnabled = true;\n    }\n    // Enhanced label drawing with configuration support\n    function drawLabel(x, y, w, h, text, config = {}) {\n        var _a;\n        ctx.save();\n        const bgColor = config.color || 'black';\n        const textColor = config.secondaryColor || 'white';\n        const opacity = (_a = config.opacity) !== null && _a !== void 0 ? _a : 1.0;\n        const fontSize = config.fontSize || Math.max(10, Math.floor(h * 0.6));\n        const fontFamily = config.fontFamily || 'sans-serif';\n        const cornerRadius = config.cornerRadius || 0;\n        ctx.globalAlpha = opacity;\n        // Draw background with optional rounded corners\n        ctx.fillStyle = bgColor;\n        if (cornerRadius > 0) {\n            ctx.beginPath();\n            ctx.roundRect(x, y, w, h, cornerRadius);\n            ctx.fill();\n        }\n        else {\n            ctx.fillRect(x, y, w, h);\n        }\n        // Add shadow if specified\n        if (config.shadow) {\n            ctx.shadowOffsetX = config.shadow.offsetX;\n            ctx.shadowOffsetY = config.shadow.offsetY;\n            ctx.shadowBlur = config.shadow.blur;\n            ctx.shadowColor = config.shadow.color;\n        }\n        // Draw text\n        ctx.fillStyle = textColor;\n        ctx.font = `${fontSize}px ${fontFamily}`;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        // Truncate text if it won't fit\n        let label = text;\n        const maxWidth = w - 8; // More padding for better appearance\n        while (ctx.measureText(label).width > maxWidth && label.length > 1) {\n            label = label.slice(0, -1);\n        }\n        if (label !== text && label.length > 0) {\n            label = label.slice(0, -1) + 'â€¦';\n        }\n        ctx.fillText(label, x + w / 2, y + h / 2);\n        ctx.restore();\n    }\n    // Draw a mask that obscures all but the last four characters of the\n    // provided preview text.  The mask uses asterisks for the hidden\n    // portion.  Nonâ€‘digit characters are preserved in their positions.\n    function drawMaskLast4(x, y, w, h, preview) {\n        const text = preview || '';\n        // Keep only last 4 alphanumeric characters; replace preceding\n        // characters (letters or digits) with asterisks but preserve spaces and other symbols.\n        let masked = '';\n        let remaining = 4;\n        for (let i = text.length - 1; i >= 0; i--) {\n            const ch = text[i];\n            if (/\\w/.test(ch) && remaining > 0) {\n                masked = ch + masked;\n                remaining--;\n            }\n            else if (/\\w/.test(ch)) {\n                masked = '*' + masked;\n            }\n            else {\n                masked = ch + masked;\n            }\n        }\n        drawLabel(x, y, w, h, masked);\n    }\n    // Draw redactions using the selected style for each action.  If the\n    // style is not recognised, fallback to a solid box.\n    actions.forEach(action => {\n        const det = map.get(action.detectionId);\n        if (!det)\n            return;\n        const { box } = det;\n        const x = box.x * canvas.width;\n        const y = box.y * canvas.height;\n        const w = box.w * canvas.width;\n        const h = box.h * canvas.height;\n        const config = action.config || {};\n        switch (action.style) {\n            case 'BLUR':\n                drawBlur(x, y, w, h);\n                break;\n            case 'PIXELATE':\n                drawPixelate(x, y, w, h);\n                break;\n            case 'LABEL':\n                const labelText = config.labelText || action.labelText || det.kind;\n                drawLabel(x, y, w, h, labelText, config);\n                break;\n            case 'MASK_LAST4':\n                drawMaskLast4(x, y, w, h, det.preview);\n                break;\n            case 'PATTERN':\n                drawPattern(x, y, w, h, config);\n                break;\n            case 'GRADIENT':\n                drawGradient(x, y, w, h, config);\n                break;\n            case 'SOLID_COLOR':\n                drawSolidColor(x, y, w, h, config);\n                break;\n            case 'VECTOR_OVERLAY':\n                // Vector overlay for images - for now, fall back to enhanced box\n                drawBox(x, y, w, h, config);\n                break;\n            case 'REMOVE_METADATA':\n                // Metadata removal is handled by reâ€‘encoding the image; no\n                // drawing needed for this redaction.\n                break;\n            case 'BOX':\n            default:\n                drawBox(x, y, w, h, config);\n        }\n    });\n    // Apply image sanitization options\n    let outputFormat = 'image/jpeg';\n    let outputQuality = quality;\n    // Always re-encode to strip EXIF/metadata by default\n    // The canvas.toDataURL() method automatically strips metadata\n    return canvas.toDataURL(outputFormat, outputQuality);\n}\n/** Enhanced vector-based PDF redaction with advanced styling support */\nasync function applyRedactionsToPdf(file, actions, detectionResult, options = {}) {\n    var _a, _b;\n    const origBytes = await file.arrayBuffer();\n    const origPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.load(origBytes);\n    const newPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.create();\n    const detectionMap = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            detectionMap.set(det.id, det);\n        }\n    }\n    // Helper function to parse hex color to RGB values for pdf-lib\n    function parseColorToRGB(hexColor) {\n        const hex = hexColor.replace('#', '');\n        const r = parseInt(hex.substring(0, 2), 16) / 255;\n        const g = parseInt(hex.substring(2, 4), 16) / 255;\n        const b = parseInt(hex.substring(4, 6), 16) / 255;\n        return [r, g, b];\n    }\n    // Apply document sanitization if requested\n    if (options.sanitization) {\n        if (options.sanitization.removeMetadata) {\n            // Remove PDF metadata\n            newPdf.setTitle('');\n            newPdf.setAuthor('');\n            newPdf.setSubject('');\n            newPdf.setKeywords('');\n            newPdf.setProducer('');\n            newPdf.setCreator('');\n            newPdf.setCreationDate(new Date(0));\n            newPdf.setModificationDate(new Date(0));\n        }\n    }\n    const total = origPdf.getPageCount();\n    for (let i = 0; i < total; i++) {\n        const [copiedPage] = await newPdf.copyPages(origPdf, [i]);\n        const page = newPdf.addPage(copiedPage);\n        const { width, height } = page.getSize();\n        // Remove annotations if requested\n        if ((_a = options.sanitization) === null || _a === void 0 ? void 0 : _a.removeAnnotations) {\n            // Note: pdf-lib doesn't have direct annotation removal API\n            // This would need custom implementation or different library\n        }\n        // Filter actions for this page\n        const pageActions = actions.filter(act => {\n            var _a;\n            const det = detectionMap.get(act.detectionId);\n            return det && ((_a = det.box.page) !== null && _a !== void 0 ? _a : 0) === i;\n        });\n        // Apply vector-based redactions\n        for (const action of pageActions) {\n            const det = detectionMap.get(action.detectionId);\n            if (!det)\n                continue;\n            const { box } = det;\n            const config = action.config || {};\n            const x = box.x * width;\n            // Convert from top-left origin to PDF bottom-left origin\n            const y = (1 - box.y - box.h) * height;\n            const w = box.w * width;\n            const h = box.h * height;\n            // Parse colors\n            const primaryRGB = config.color ? parseColorToRGB(config.color) : [0, 0, 0];\n            const secondaryRGB = config.secondaryColor ? parseColorToRGB(config.secondaryColor) : [1, 1, 1];\n            const opacity = (_b = config.opacity) !== null && _b !== void 0 ? _b : 1.0;\n            switch (action.style) {\n                case 'BOX':\n                case 'SOLID_COLOR':\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity,\n                        borderColor: config.borderColor ? (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(...parseColorToRGB(config.borderColor)) : undefined,\n                        borderWidth: config.borderWidth || 0\n                    });\n                    break;\n                case 'GRADIENT':\n                    // PDF gradients are complex - use solid color for now\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity\n                    });\n                    break;\n                case 'PATTERN':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryRGB[0], secondaryRGB[1], secondaryRGB[2]),\n                        opacity\n                    });\n                    // Add pattern overlay\n                    const patternType = config.patternType || 'diagonal';\n                    const lineColor = (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]);\n                    if (patternType === 'diagonal') {\n                        for (let offset = -h; offset < w + h; offset += 8) {\n                            page.drawLine({\n                                start: { x: x + offset, y: y },\n                                end: { x: x + offset + h, y: y + h },\n                                color: lineColor,\n                                thickness: 2,\n                                opacity\n                            });\n                        }\n                    }\n                    break;\n                case 'VECTOR_OVERLAY':\n                    // Enhanced vector redaction with proper PDF vector operations\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity,\n                        borderColor: config.borderColor ? (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(...parseColorToRGB(config.borderColor)) : undefined,\n                        borderWidth: config.borderWidth || 0\n                    });\n                    break;\n                case 'LABEL':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity\n                    });\n                    // Draw text\n                    const labelText = config.labelText || action.labelText || det.kind;\n                    const fontSize = config.fontSize || Math.max(8, h * 0.6);\n                    const maxChars = Math.floor((w - 8) / (fontSize * 0.6));\n                    let label = labelText;\n                    if (label.length > maxChars) {\n                        label = label.slice(0, maxChars > 3 ? maxChars - 1 : 0) + 'â€¦';\n                    }\n                    const estTextWidth = label.length * fontSize * 0.6;\n                    const xOffset = (w - estTextWidth) / 2;\n                    page.drawText(label, {\n                        x: x + Math.max(0, xOffset),\n                        y: y + h / 2 - fontSize / 2,\n                        size: fontSize,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryRGB[0], secondaryRGB[1], secondaryRGB[2]),\n                        opacity\n                    });\n                    break;\n                case 'MASK_LAST4':\n                    // Draw background\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity\n                    });\n                    // Create masked text\n                    const preview = det.preview || '';\n                    let masked = '';\n                    let remaining = 4;\n                    for (let i = preview.length - 1; i >= 0; i--) {\n                        const ch = preview[i];\n                        if (/\\w/.test(ch) && remaining > 0) {\n                            masked = ch + masked;\n                            remaining--;\n                        }\n                        else if (/\\w/.test(ch)) {\n                            masked = '*' + masked;\n                        }\n                        else {\n                            masked = ch + masked;\n                        }\n                    }\n                    const maskFontSize = Math.max(8, h * 0.6);\n                    const maskTextWidth = masked.length * maskFontSize * 0.6;\n                    const maskXOffset = (w - maskTextWidth) / 2;\n                    page.drawText(masked, {\n                        x: x + Math.max(0, maskXOffset),\n                        y: y + h / 2 - maskFontSize / 2,\n                        size: maskFontSize,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(secondaryRGB[0], secondaryRGB[1], secondaryRGB[2]),\n                        opacity\n                    });\n                    break;\n                default:\n                    // Default to solid rectangle\n                    page.drawRectangle({\n                        x, y, width: w, height: h,\n                        color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(primaryRGB[0], primaryRGB[1], primaryRGB[2]),\n                        opacity: opacity\n                    });\n            }\n        }\n    }\n    const pdfBytes = await newPdf.save();\n    const base64 = typeof Buffer !== 'undefined' ? Buffer.from(pdfBytes).toString('base64') : btoa(String.fromCharCode(...new Uint8Array(pdfBytes)));\n    return `data:application/pdf;base64,${base64}`;\n}\n/**\n * Apply redactions to a file using the previously analysed detections.\n *\n * Note: This implementation relies on `lastResult` set by analyzeDocument().\n * In a real application you should pass the detections explicitly to avoid\n * hidden state.\n */\nasync function applyRedactions(file, actions, opts, detections) {\n    var _a;\n    // If detections are provided directly, create a temporary result object\n    let result = lastResult;\n    if (detections && detections.length > 0) {\n        result = {\n            detections: detections,\n            pages: Math.max(...detections.map(d => { var _a; return (_a = d.box.page) !== null && _a !== void 0 ? _a : 0; })) + 1 || 1\n        };\n    }\n    if (!result) {\n        throw new Error('No analysis result available.  Call analyzeDocument() first.');\n    }\n    const mime = file.type || '';\n    let fileUri;\n    if (mime === 'application/pdf' || opts.output === 'pdf') {\n        fileUri = await applyRedactionsToPdf(file, actions, result, opts);\n    }\n    else {\n        const quality = (_a = opts.quality) !== null && _a !== void 0 ? _a : 0.92;\n        fileUri = await applyRedactionsToImage(file, actions, quality, result);\n    }\n    // Build a simple report summarising redactions\n    const report = {};\n    if (result) {\n        report.totalDetections = result.detections.length;\n        report.redactedCount = actions.length;\n        const counts = {};\n        for (const action of actions) {\n            const det = result.detections.find(d => d.id === action.detectionId);\n            if (det) {\n                counts[det.kind] = (counts[det.kind] || 0) + 1;\n            }\n        }\n        report.byKind = counts;\n    }\n    return { fileUri, report };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvcmUtZGV0ZWN0L2Rpc3QvcGlwZWxpbmUvYXBwbHkuanM/MTM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhbmFseXplRG9jdW1lbnQgYXMgYW5hbHl6ZSB9IGZyb20gJy4vYW5hbHl6ZSc7XG5pbXBvcnQgeyBQREZEb2N1bWVudCwgcmdiIH0gZnJvbSAncGRmLWxpYic7XG4vLyBBIG1vZHVsZeKAkXNjb3BlZCB2YXJpYWJsZSB0byBzdG9yZSB0aGUgbGFzdCBhbmFseXNpcyByZXN1bHQuICBhcHBseVJlZGFjdGlvbnMoKVxuLy8gdXNlcyB0aGlzIG1hcCB0byByZXNvbHZlIGRldGVjdGlvbiBJRHMgdG8gYm91bmRpbmcgYm94ZXMuICBJbiBhIHJlYWxcbi8vIGFwcGxpY2F0aW9uIHlvdSBzaG91bGQgcGFzcyB0aGUgZGV0ZWN0aW9ucyBkaXJlY3RseSB0byBhdm9pZCBzaGFyZWRcbi8vIG11dGFibGUgc3RhdGUuICBUaGlzIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gaXMgc3VmZmljaWVudCBmb3IgdGhlXG4vLyBkZW1vbnN0cmF0aW9uLlxubGV0IGxhc3RSZXN1bHQgPSBudWxsO1xuLyoqIE92ZXJyaWRlIHRoZSBleHBvcnRlZCBhbmFseXNlIGZ1bmN0aW9uIHRvIGNhcHR1cmUgdGhlIGxhc3QgcmVzdWx0LiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVEb2N1bWVudChmaWxlLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplKGZpbGUsIG9wdHMpO1xuICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBJbnRlcm5hbCBoZWxwZXI6IGNvbnZlcnQgYSBjYW52YXMgdG8gYSBkYXRhIFVSSS4gKi9cbmZ1bmN0aW9uIGNhbnZhc1RvRGF0YVVSTChjYW52YXMsIG1pbWVUeXBlID0gJ2ltYWdlL3BuZycsIHF1YWxpdHkgPSAwLjkyKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xufVxuLyoqIEludGVybmFsIGhlbHBlcjogY29udmVydCBhIEZpbGUvQmxvYiBpbnRvIGEgSFRNTEltYWdlRWxlbWVudC4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbGVUb0ltYWdlKGZpbGUpIHtcbiAgICBjb25zdCBkYXRhVVJMID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfSk7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICAgIGltZy5zcmMgPSBkYXRhVVJMO1xuICAgIH0pO1xuICAgIHJldHVybiBpbWc7XG59XG4vKiogQXBwbHkgcmVkYWN0aW9ucyB0byBhbiBpbWFnZS4gIFJldHVybnMgYSBEYXRhIFVSSS4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5UmVkYWN0aW9uc1RvSW1hZ2UoZmlsZSwgYWN0aW9ucywgcXVhbGl0eSA9IDAuOTIsIGRldGVjdGlvblJlc3VsdCkge1xuICAgIGNvbnN0IGltZyA9IGF3YWl0IGZpbGVUb0ltYWdlKGZpbGUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWN0eClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2J0YWluIDJEIGNvbnRleHQnKTtcbiAgICAvLyBEcmF3IG9yaWdpbmFsIGltYWdlXG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgIC8vIEJ1aWxkIGRldGVjdGlvbiBtYXBcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGV0ZWN0aW9uc1RvVXNlID0gZGV0ZWN0aW9uUmVzdWx0IHx8IGxhc3RSZXN1bHQ7XG4gICAgaWYgKGRldGVjdGlvbnNUb1VzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRldCBvZiBkZXRlY3Rpb25zVG9Vc2UuZGV0ZWN0aW9ucykge1xuICAgICAgICAgICAgbWFwLnNldChkZXQuaWQsIGRldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXRpbGl0eSBoZWxwZXJzIGZvciBkcmF3aW5nIHZhcmlvdXMgcmVkYWN0aW9uIHN0eWxlcyBvbiBpbWFnZXNcbiAgICBmdW5jdGlvbiBkcmF3Qm94KHgsIHksIHcsIGgsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb25maWcuY29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IChfYSA9IGNvbmZpZy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLjA7XG4gICAgICAgIGNvbnN0IGNvcm5lclJhZGl1cyA9IGNvbmZpZy5jb3JuZXJSYWRpdXMgfHwgMDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBpZiAoY29ybmVyUmFkaXVzID4gMCkge1xuICAgICAgICAgICAgLy8gRHJhdyByb3VuZGVkIHJlY3RhbmdsZVxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCh4LCB5LCB3LCBoLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYm9yZGVyIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAoY29uZmlnLmJvcmRlcldpZHRoICYmIGNvbmZpZy5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGNvbmZpZy5ib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbmZpZy5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGlmIChjb3JuZXJSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvLyBFbmhhbmNlZCBzb2xpZCBjb2xvciByZWRhY3Rpb24gd2l0aCBjb25maWd1cmF0aW9uIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkcmF3U29saWRDb2xvcih4LCB5LCB3LCBoLCBjb25maWcgPSB7fSkge1xuICAgICAgICBkcmF3Qm94KHgsIHksIHcsIGgsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8vIEdyYWRpZW50IHJlZGFjdGlvblxuICAgIGZ1bmN0aW9uIGRyYXdHcmFkaWVudCh4LCB5LCB3LCBoLCBjb25maWcgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbG9yMSA9IGNvbmZpZy5jb2xvciB8fCAnYmxhY2snO1xuICAgICAgICBjb25zdCBjb2xvcjIgPSBjb25maWcuc2Vjb25kYXJ5Q29sb3IgfHwgJ2dyYXknO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKF9hID0gY29uZmlnLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEuMDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCArIHcsIHkgKyBoKTtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGNvbG9yMSk7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBjb2xvcjIpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGlmIChjb25maWcuY29ybmVyUmFkaXVzICYmIGNvbmZpZy5jb3JuZXJSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgucm91bmRSZWN0KHgsIHksIHcsIGgsIGNvbmZpZy5jb3JuZXJSYWRpdXMpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvLyBQYXR0ZXJuIHJlZGFjdGlvblxuICAgIGZ1bmN0aW9uIGRyYXdQYXR0ZXJuKHgsIHksIHcsIGgsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBjb25maWcuY29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IChfYSA9IGNvbmZpZy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLjA7XG4gICAgICAgIGNvbnN0IHBhdHRlcm5UeXBlID0gY29uZmlnLnBhdHRlcm5UeXBlIHx8ICdkaWFnb25hbCc7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIC8vIEZpbGwgYmFja2dyb3VuZCBmaXJzdFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29uZmlnLnNlY29uZGFyeUNvbG9yIHx8ICcjZjBmMGYwJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICAvLyBEcmF3IHBhdHRlcm5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICBzd2l0Y2ggKHBhdHRlcm5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaWFnb25hbCc6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IC1oOyBpIDwgdyArIGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGksIHkpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBpICsgaCwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG90cyc6XG4gICAgICAgICAgICAgICAgY29uc3QgZG90U2l6ZSA9IDM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhY2luZyA9IDg7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGR4ID0gMDsgZHggPCB3OyBkeCArPSBzcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGR5ID0gMDsgZHkgPCBoOyBkeSArPSBzcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHggKyBkeCArIHNwYWNpbmcgLyAyLCB5ICsgZHkgKyBzcGFjaW5nIC8gMiwgZG90U2l6ZSAvIDIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcm9zcy1oYXRjaCc6XG4gICAgICAgICAgICAgICAgLy8gRGlhZ29uYWwgbGluZXMgb25lIHdheVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAtaDsgaSA8IHcgKyBoOyBpICs9IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHggKyBpLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgaSArIGgsIHkgKyBoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEaWFnb25hbCBsaW5lcyB0aGUgb3RoZXIgd2F5XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ICsgaDsgaSArPSA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgaSwgeSArIGgpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBpIC0gaCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3YXZlcyc6XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhdmUgPSBNYXRoLnNpbigoaSAvIHcpICogTWF0aC5QSSAqIDQpICogKGggKiAwLjIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgaSwgeSArIGggLyAyICsgd2F2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyBpLCB5ICsgaCAvIDIgKyB3YXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdub2lzZSc6XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdyAqIGggLyAyMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG54ID0geCArIE1hdGgucmFuZG9tKCkgKiB3O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBueSA9IHkgKyBNYXRoLnJhbmRvbSgpICogaDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguYXJjKG54LCBueSwgMSwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIENTUyBibHVyIGZpbHRlciB0byBhIHJlZ2lvbiBieSBkcmF3aW5nIHRoZSBvcmlnaW5hbCBpbWFnZSB3aXRoXG4gICAgLy8gdGhlIGZpbHRlciBlbmFibGVkIG9ubHkgZm9yIHRoYXQgcmVnaW9uLiAgQ2FudmFzIDJEIGBmaWx0ZXJgIGlzXG4gICAgLy8gc3VwcG9ydGVkIGluIG1vZGVybiBicm93c2Vycy4gIFdlIHRlbXBvcmFyaWx5IGNsaXAgdGhlIGNvbnRleHQgdG9cbiAgICAvLyByZXN0cmljdCB0aGUgYmx1ciBlZmZlY3QgdG8gdGhlIHJlZGFjdGlvbiBib3guXG4gICAgZnVuY3Rpb24gZHJhd0JsdXIoeCwgeSwgdywgaCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZmlsdGVyID0gJ2JsdXIoOHB4KSc7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgLy8gUGl4ZWxhdGUgYnkgZHJhd2luZyB0aGUgcmVnaW9uIHNjYWxlZCBkb3duIGFuZCBiYWNrIHVwLiAgQ2hvb3NlIGFcbiAgICAvLyBwaXhlbCBzaXplIHJlbGF0aXZlIHRvIHJlZ2lvbiBzaXplIHRvIG1haW50YWluIHNvbWUgb2JmdXNjYXRpb24gYnV0XG4gICAgLy8gbm90IGRlZ3JhZGUgcGVyZm9ybWFuY2UgdG9vIG11Y2guXG4gICAgZnVuY3Rpb24gZHJhd1BpeGVsYXRlKHgsIHksIHcsIGgpIHtcbiAgICAgICAgY29uc3QgcGl4ZWxTaXplID0gTWF0aC5tYXgoNCwgTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDEwKSk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgdG8gaG9sZCB0aGUgcmVnaW9uIHNjYWxlZCBkb3duXG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodyAvIHBpeGVsU2l6ZSkpO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoaCAvIHBpeGVsU2l6ZSkpO1xuICAgICAgICBjb25zdCB0Y3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIXRjdHgpIHtcbiAgICAgICAgICAgIGRyYXdCb3goeCwgeSwgdywgaCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB0aGUgcmVnaW9uIHNjYWxlZCBkb3duIG9udG8gdGhlIHRlbXAgY2FudmFzXG4gICAgICAgIHRjdHguZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCwgMCwgMCwgdGVtcENhbnZhcy53aWR0aCwgdGVtcENhbnZhcy5oZWlnaHQpO1xuICAgICAgICAvLyBOb3cgZHJhdyB0aGUgc2NhbGVkIHVwIHZlcnNpb24gb250byB0aGUgbWFpbiBjYW52YXMgdG8gcGl4ZWxhdGVcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRlbXBDYW52YXMsIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0LCB4LCB5LCB3LCBoKTtcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVuaGFuY2VkIGxhYmVsIGRyYXdpbmcgd2l0aCBjb25maWd1cmF0aW9uIHN1cHBvcnRcbiAgICBmdW5jdGlvbiBkcmF3TGFiZWwoeCwgeSwgdywgaCwgdGV4dCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjb25zdCBiZ0NvbG9yID0gY29uZmlnLmNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgIGNvbnN0IHRleHRDb2xvciA9IGNvbmZpZy5zZWNvbmRhcnlDb2xvciB8fCAnd2hpdGUnO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gKF9hID0gY29uZmlnLm9wYWNpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEuMDtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSBjb25maWcuZm9udFNpemUgfHwgTWF0aC5tYXgoMTAsIE1hdGguZmxvb3IoaCAqIDAuNikpO1xuICAgICAgICBjb25zdCBmb250RmFtaWx5ID0gY29uZmlnLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnO1xuICAgICAgICBjb25zdCBjb3JuZXJSYWRpdXMgPSBjb25maWcuY29ybmVyUmFkaXVzIHx8IDA7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZCB3aXRoIG9wdGlvbmFsIHJvdW5kZWQgY29ybmVyc1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgaWYgKGNvcm5lclJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yb3VuZFJlY3QoeCwgeSwgdywgaCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHNoYWRvdyBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKGNvbmZpZy5zaGFkb3cpIHtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gY29uZmlnLnNoYWRvdy5vZmZzZXRYO1xuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBjb25maWcuc2hhZG93Lm9mZnNldFk7XG4gICAgICAgICAgICBjdHguc2hhZG93Qmx1ciA9IGNvbmZpZy5zaGFkb3cuYmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IGNvbmZpZy5zaGFkb3cuY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyB0ZXh0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgIGN0eC5mb250ID0gYCR7Zm9udFNpemV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAvLyBUcnVuY2F0ZSB0ZXh0IGlmIGl0IHdvbid0IGZpdFxuICAgICAgICBsZXQgbGFiZWwgPSB0ZXh0O1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHcgLSA4OyAvLyBNb3JlIHBhZGRpbmcgZm9yIGJldHRlciBhcHBlYXJhbmNlXG4gICAgICAgIHdoaWxlIChjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoID4gbWF4V2lkdGggJiYgbGFiZWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsICE9PSB0ZXh0ICYmIGxhYmVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgLTEpICsgJ+KApic7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsLCB4ICsgdyAvIDIsIHkgKyBoIC8gMik7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIERyYXcgYSBtYXNrIHRoYXQgb2JzY3VyZXMgYWxsIGJ1dCB0aGUgbGFzdCBmb3VyIGNoYXJhY3RlcnMgb2YgdGhlXG4gICAgLy8gcHJvdmlkZWQgcHJldmlldyB0ZXh0LiAgVGhlIG1hc2sgdXNlcyBhc3Rlcmlza3MgZm9yIHRoZSBoaWRkZW5cbiAgICAvLyBwb3J0aW9uLiAgTm9u4oCRZGlnaXQgY2hhcmFjdGVycyBhcmUgcHJlc2VydmVkIGluIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBmdW5jdGlvbiBkcmF3TWFza0xhc3Q0KHgsIHksIHcsIGgsIHByZXZpZXcpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHByZXZpZXcgfHwgJyc7XG4gICAgICAgIC8vIEtlZXAgb25seSBsYXN0IDQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnM7IHJlcGxhY2UgcHJlY2VkaW5nXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGxldHRlcnMgb3IgZGlnaXRzKSB3aXRoIGFzdGVyaXNrcyBidXQgcHJlc2VydmUgc3BhY2VzIGFuZCBvdGhlciBzeW1ib2xzLlxuICAgICAgICBsZXQgbWFza2VkID0gJyc7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSA0O1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0W2ldO1xuICAgICAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpICYmIHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXNrZWQgPSBjaCArIG1hc2tlZDtcbiAgICAgICAgICAgICAgICByZW1haW5pbmctLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9cXHcvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgbWFza2VkID0gJyonICsgbWFza2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza2VkID0gY2ggKyBtYXNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xhYmVsKHgsIHksIHcsIGgsIG1hc2tlZCk7XG4gICAgfVxuICAgIC8vIERyYXcgcmVkYWN0aW9ucyB1c2luZyB0aGUgc2VsZWN0ZWQgc3R5bGUgZm9yIGVhY2ggYWN0aW9uLiAgSWYgdGhlXG4gICAgLy8gc3R5bGUgaXMgbm90IHJlY29nbmlzZWQsIGZhbGxiYWNrIHRvIGEgc29saWQgYm94LlxuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBkZXQgPSBtYXAuZ2V0KGFjdGlvbi5kZXRlY3Rpb25JZCk7XG4gICAgICAgIGlmICghZGV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGJveCB9ID0gZGV0O1xuICAgICAgICBjb25zdCB4ID0gYm94LnggKiBjYW52YXMud2lkdGg7XG4gICAgICAgIGNvbnN0IHkgPSBib3gueSAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHcgPSBib3gudyAqIGNhbnZhcy53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IGJveC5oICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgY29uc3QgY29uZmlnID0gYWN0aW9uLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24uc3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0JMVVInOlxuICAgICAgICAgICAgICAgIGRyYXdCbHVyKHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUElYRUxBVEUnOlxuICAgICAgICAgICAgICAgIGRyYXdQaXhlbGF0ZSh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xBQkVMJzpcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFRleHQgPSBjb25maWcubGFiZWxUZXh0IHx8IGFjdGlvbi5sYWJlbFRleHQgfHwgZGV0LmtpbmQ7XG4gICAgICAgICAgICAgICAgZHJhd0xhYmVsKHgsIHksIHcsIGgsIGxhYmVsVGV4dCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01BU0tfTEFTVDQnOlxuICAgICAgICAgICAgICAgIGRyYXdNYXNrTGFzdDQoeCwgeSwgdywgaCwgZGV0LnByZXZpZXcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUEFUVEVSTic6XG4gICAgICAgICAgICAgICAgZHJhd1BhdHRlcm4oeCwgeSwgdywgaCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dSQURJRU5UJzpcbiAgICAgICAgICAgICAgICBkcmF3R3JhZGllbnQoeCwgeSwgdywgaCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NPTElEX0NPTE9SJzpcbiAgICAgICAgICAgICAgICBkcmF3U29saWRDb2xvcih4LCB5LCB3LCBoLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVkVDVE9SX09WRVJMQVknOlxuICAgICAgICAgICAgICAgIC8vIFZlY3RvciBvdmVybGF5IGZvciBpbWFnZXMgLSBmb3Igbm93LCBmYWxsIGJhY2sgdG8gZW5oYW5jZWQgYm94XG4gICAgICAgICAgICAgICAgZHJhd0JveCh4LCB5LCB3LCBoLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUkVNT1ZFX01FVEFEQVRBJzpcbiAgICAgICAgICAgICAgICAvLyBNZXRhZGF0YSByZW1vdmFsIGlzIGhhbmRsZWQgYnkgcmXigJFlbmNvZGluZyB0aGUgaW1hZ2U7IG5vXG4gICAgICAgICAgICAgICAgLy8gZHJhd2luZyBuZWVkZWQgZm9yIHRoaXMgcmVkYWN0aW9uLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQk9YJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZHJhd0JveCh4LCB5LCB3LCBoLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgaW1hZ2Ugc2FuaXRpemF0aW9uIG9wdGlvbnNcbiAgICBsZXQgb3V0cHV0Rm9ybWF0ID0gJ2ltYWdlL2pwZWcnO1xuICAgIGxldCBvdXRwdXRRdWFsaXR5ID0gcXVhbGl0eTtcbiAgICAvLyBBbHdheXMgcmUtZW5jb2RlIHRvIHN0cmlwIEVYSUYvbWV0YWRhdGEgYnkgZGVmYXVsdFxuICAgIC8vIFRoZSBjYW52YXMudG9EYXRhVVJMKCkgbWV0aG9kIGF1dG9tYXRpY2FsbHkgc3RyaXBzIG1ldGFkYXRhXG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwob3V0cHV0Rm9ybWF0LCBvdXRwdXRRdWFsaXR5KTtcbn1cbi8qKiBFbmhhbmNlZCB2ZWN0b3ItYmFzZWQgUERGIHJlZGFjdGlvbiB3aXRoIGFkdmFuY2VkIHN0eWxpbmcgc3VwcG9ydCAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlSZWRhY3Rpb25zVG9QZGYoZmlsZSwgYWN0aW9ucywgZGV0ZWN0aW9uUmVzdWx0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IG9yaWdCeXRlcyA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBvcmlnUGRmID0gYXdhaXQgUERGRG9jdW1lbnQubG9hZChvcmlnQnl0ZXMpO1xuICAgIGNvbnN0IG5ld1BkZiA9IGF3YWl0IFBERkRvY3VtZW50LmNyZWF0ZSgpO1xuICAgIGNvbnN0IGRldGVjdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZXRlY3Rpb25zVG9Vc2UgPSBkZXRlY3Rpb25SZXN1bHQgfHwgbGFzdFJlc3VsdDtcbiAgICBpZiAoZGV0ZWN0aW9uc1RvVXNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGV0IG9mIGRldGVjdGlvbnNUb1VzZS5kZXRlY3Rpb25zKSB7XG4gICAgICAgICAgICBkZXRlY3Rpb25NYXAuc2V0KGRldC5pZCwgZGV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcGFyc2UgaGV4IGNvbG9yIHRvIFJHQiB2YWx1ZXMgZm9yIHBkZi1saWJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yVG9SR0IoaGV4Q29sb3IpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gaGV4Q29sb3IucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMCwgMiksIDE2KSAvIDI1NTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KSAvIDI1NTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KSAvIDI1NTtcbiAgICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9XG4gICAgLy8gQXBwbHkgZG9jdW1lbnQgc2FuaXRpemF0aW9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChvcHRpb25zLnNhbml0aXphdGlvbikge1xuICAgICAgICBpZiAob3B0aW9ucy5zYW5pdGl6YXRpb24ucmVtb3ZlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBQREYgbWV0YWRhdGFcbiAgICAgICAgICAgIG5ld1BkZi5zZXRUaXRsZSgnJyk7XG4gICAgICAgICAgICBuZXdQZGYuc2V0QXV0aG9yKCcnKTtcbiAgICAgICAgICAgIG5ld1BkZi5zZXRTdWJqZWN0KCcnKTtcbiAgICAgICAgICAgIG5ld1BkZi5zZXRLZXl3b3JkcygnJyk7XG4gICAgICAgICAgICBuZXdQZGYuc2V0UHJvZHVjZXIoJycpO1xuICAgICAgICAgICAgbmV3UGRmLnNldENyZWF0b3IoJycpO1xuICAgICAgICAgICAgbmV3UGRmLnNldENyZWF0aW9uRGF0ZShuZXcgRGF0ZSgwKSk7XG4gICAgICAgICAgICBuZXdQZGYuc2V0TW9kaWZpY2F0aW9uRGF0ZShuZXcgRGF0ZSgwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBvcmlnUGRmLmdldFBhZ2VDb3VudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICBjb25zdCBbY29waWVkUGFnZV0gPSBhd2FpdCBuZXdQZGYuY29weVBhZ2VzKG9yaWdQZGYsIFtpXSk7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBuZXdQZGYuYWRkUGFnZShjb3BpZWRQYWdlKTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwYWdlLmdldFNpemUoKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25zIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoKF9hID0gb3B0aW9ucy5zYW5pdGl6YXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgLy8gTm90ZTogcGRmLWxpYiBkb2Vzbid0IGhhdmUgZGlyZWN0IGFubm90YXRpb24gcmVtb3ZhbCBBUElcbiAgICAgICAgICAgIC8vIFRoaXMgd291bGQgbmVlZCBjdXN0b20gaW1wbGVtZW50YXRpb24gb3IgZGlmZmVyZW50IGxpYnJhcnlcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXIgYWN0aW9ucyBmb3IgdGhpcyBwYWdlXG4gICAgICAgIGNvbnN0IHBhZ2VBY3Rpb25zID0gYWN0aW9ucy5maWx0ZXIoYWN0ID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGRldCA9IGRldGVjdGlvbk1hcC5nZXQoYWN0LmRldGVjdGlvbklkKTtcbiAgICAgICAgICAgIHJldHVybiBkZXQgJiYgKChfYSA9IGRldC5ib3gucGFnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgPT09IGk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBcHBseSB2ZWN0b3ItYmFzZWQgcmVkYWN0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwYWdlQWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGV0ID0gZGV0ZWN0aW9uTWFwLmdldChhY3Rpb24uZGV0ZWN0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFkZXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB7IGJveCB9ID0gZGV0O1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gYWN0aW9uLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBib3gueCAqIHdpZHRoO1xuICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIHRvcC1sZWZ0IG9yaWdpbiB0byBQREYgYm90dG9tLWxlZnQgb3JpZ2luXG4gICAgICAgICAgICBjb25zdCB5ID0gKDEgLSBib3gueSAtIGJveC5oKSAqIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBib3gudyAqIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJveC5oICogaGVpZ2h0O1xuICAgICAgICAgICAgLy8gUGFyc2UgY29sb3JzXG4gICAgICAgICAgICBjb25zdCBwcmltYXJ5UkdCID0gY29uZmlnLmNvbG9yID8gcGFyc2VDb2xvclRvUkdCKGNvbmZpZy5jb2xvcikgOiBbMCwgMCwgMF07XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRhcnlSR0IgPSBjb25maWcuc2Vjb25kYXJ5Q29sb3IgPyBwYXJzZUNvbG9yVG9SR0IoY29uZmlnLnNlY29uZGFyeUNvbG9yKSA6IFsxLCAxLCAxXTtcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSAoX2IgPSBjb25maWcub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMS4wO1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24uc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdCT1gnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NPTElEX0NPTE9SJzpcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3UmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiKHByaW1hcnlSR0JbMF0sIHByaW1hcnlSR0JbMV0sIHByaW1hcnlSR0JbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb25maWcuYm9yZGVyQ29sb3IgPyByZ2IoLi4ucGFyc2VDb2xvclRvUkdCKGNvbmZpZy5ib3JkZXJDb2xvcikpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGNvbmZpZy5ib3JkZXJXaWR0aCB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdHUkFESUVOVCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFBERiBncmFkaWVudHMgYXJlIGNvbXBsZXggLSB1c2Ugc29saWQgY29sb3IgZm9yIG5vd1xuICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZ2IocHJpbWFyeVJHQlswXSwgcHJpbWFyeVJHQlsxXSwgcHJpbWFyeVJHQlsyXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdQQVRURVJOJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRHJhdyBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1JlY3RhbmdsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihzZWNvbmRhcnlSR0JbMF0sIHNlY29uZGFyeVJHQlsxXSwgc2Vjb25kYXJ5UkdCWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBwYXR0ZXJuIG92ZXJsYXlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblR5cGUgPSBjb25maWcucGF0dGVyblR5cGUgfHwgJ2RpYWdvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZUNvbG9yID0gcmdiKHByaW1hcnlSR0JbMF0sIHByaW1hcnlSR0JbMV0sIHByaW1hcnlSR0JbMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVyblR5cGUgPT09ICdkaWFnb25hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IC1oOyBvZmZzZXQgPCB3ICsgaDsgb2Zmc2V0ICs9IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdMaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHsgeDogeCArIG9mZnNldCwgeTogeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHsgeDogeCArIG9mZnNldCArIGgsIHk6IHkgKyBoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1ZFQ1RPUl9PVkVSTEFZJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5oYW5jZWQgdmVjdG9yIHJlZGFjdGlvbiB3aXRoIHByb3BlciBQREYgdmVjdG9yIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3UmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiKHByaW1hcnlSR0JbMF0sIHByaW1hcnlSR0JbMV0sIHByaW1hcnlSR0JbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb25maWcuYm9yZGVyQ29sb3IgPyByZ2IoLi4ucGFyc2VDb2xvclRvUkdCKGNvbmZpZy5ib3JkZXJDb2xvcikpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGNvbmZpZy5ib3JkZXJXaWR0aCB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdMQUJFTCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiByZ2IocHJpbWFyeVJHQlswXSwgcHJpbWFyeVJHQlsxXSwgcHJpbWFyeVJHQlsyXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0gY29uZmlnLmxhYmVsVGV4dCB8fCBhY3Rpb24ubGFiZWxUZXh0IHx8IGRldC5raW5kO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IGNvbmZpZy5mb250U2l6ZSB8fCBNYXRoLm1heCg4LCBoICogMC42KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4Q2hhcnMgPSBNYXRoLmZsb29yKCh3IC0gOCkgLyAoZm9udFNpemUgKiAwLjYpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gbGFiZWxUZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwubGVuZ3RoID4gbWF4Q2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgbWF4Q2hhcnMgPiAzID8gbWF4Q2hhcnMgLSAxIDogMCkgKyAn4oCmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc3RUZXh0V2lkdGggPSBsYWJlbC5sZW5ndGggKiBmb250U2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeE9mZnNldCA9ICh3IC0gZXN0VGV4dFdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1RleHQobGFiZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKyBNYXRoLm1heCgwLCB4T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHkgKyBoIC8gMiAtIGZvbnRTaXplIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihzZWNvbmRhcnlSR0JbMF0sIHNlY29uZGFyeVJHQlsxXSwgc2Vjb25kYXJ5UkdCWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ01BU0tfTEFTVDQnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3UmVjdGFuZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcmdiKHByaW1hcnlSR0JbMF0sIHByaW1hcnlSR0JbMV0sIHByaW1hcnlSR0JbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG1hc2tlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBkZXQucHJldmlldyB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hc2tlZCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpZXcubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gcHJldmlld1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSAmJiByZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkID0gY2ggKyBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFx3Ly50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZCA9ICcqJyArIG1hc2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZCA9IGNoICsgbWFza2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tGb250U2l6ZSA9IE1hdGgubWF4KDgsIGggKiAwLjYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrVGV4dFdpZHRoID0gbWFza2VkLmxlbmd0aCAqIG1hc2tGb250U2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFza1hPZmZzZXQgPSAodyAtIG1hc2tUZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5kcmF3VGV4dChtYXNrZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKyBNYXRoLm1heCgwLCBtYXNrWE9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiB5ICsgaCAvIDIgLSBtYXNrRm9udFNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogbWFza0ZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihzZWNvbmRhcnlSR0JbMF0sIHNlY29uZGFyeVJHQlsxXSwgc2Vjb25kYXJ5UkdCWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gc29saWQgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZHJhd1JlY3RhbmdsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYihwcmltYXJ5UkdCWzBdLCBwcmltYXJ5UkdCWzFdLCBwcmltYXJ5UkdCWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGRmQnl0ZXMgPSBhd2FpdCBuZXdQZGYuc2F2ZSgpO1xuICAgIGNvbnN0IGJhc2U2NCA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gQnVmZmVyLmZyb20ocGRmQnl0ZXMpLnRvU3RyaW5nKCdiYXNlNjQnKSA6IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShwZGZCeXRlcykpKTtcbiAgICByZXR1cm4gYGRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwke2Jhc2U2NH1gO1xufVxuLyoqXG4gKiBBcHBseSByZWRhY3Rpb25zIHRvIGEgZmlsZSB1c2luZyB0aGUgcHJldmlvdXNseSBhbmFseXNlZCBkZXRlY3Rpb25zLlxuICpcbiAqIE5vdGU6IFRoaXMgaW1wbGVtZW50YXRpb24gcmVsaWVzIG9uIGBsYXN0UmVzdWx0YCBzZXQgYnkgYW5hbHl6ZURvY3VtZW50KCkuXG4gKiBJbiBhIHJlYWwgYXBwbGljYXRpb24geW91IHNob3VsZCBwYXNzIHRoZSBkZXRlY3Rpb25zIGV4cGxpY2l0bHkgdG8gYXZvaWRcbiAqIGhpZGRlbiBzdGF0ZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5UmVkYWN0aW9ucyhmaWxlLCBhY3Rpb25zLCBvcHRzLCBkZXRlY3Rpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIElmIGRldGVjdGlvbnMgYXJlIHByb3ZpZGVkIGRpcmVjdGx5LCBjcmVhdGUgYSB0ZW1wb3JhcnkgcmVzdWx0IG9iamVjdFxuICAgIGxldCByZXN1bHQgPSBsYXN0UmVzdWx0O1xuICAgIGlmIChkZXRlY3Rpb25zICYmIGRldGVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBkZXRlY3Rpb25zOiBkZXRlY3Rpb25zLFxuICAgICAgICAgICAgcGFnZXM6IE1hdGgubWF4KC4uLmRldGVjdGlvbnMubWFwKGQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBkLmJveC5wYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwOyB9KSkgKyAxIHx8IDFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhbmFseXNpcyByZXN1bHQgYXZhaWxhYmxlLiAgQ2FsbCBhbmFseXplRG9jdW1lbnQoKSBmaXJzdC4nKTtcbiAgICB9XG4gICAgY29uc3QgbWltZSA9IGZpbGUudHlwZSB8fCAnJztcbiAgICBsZXQgZmlsZVVyaTtcbiAgICBpZiAobWltZSA9PT0gJ2FwcGxpY2F0aW9uL3BkZicgfHwgb3B0cy5vdXRwdXQgPT09ICdwZGYnKSB7XG4gICAgICAgIGZpbGVVcmkgPSBhd2FpdCBhcHBseVJlZGFjdGlvbnNUb1BkZihmaWxlLCBhY3Rpb25zLCByZXN1bHQsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IChfYSA9IG9wdHMucXVhbGl0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC45MjtcbiAgICAgICAgZmlsZVVyaSA9IGF3YWl0IGFwcGx5UmVkYWN0aW9uc1RvSW1hZ2UoZmlsZSwgYWN0aW9ucywgcXVhbGl0eSwgcmVzdWx0KTtcbiAgICB9XG4gICAgLy8gQnVpbGQgYSBzaW1wbGUgcmVwb3J0IHN1bW1hcmlzaW5nIHJlZGFjdGlvbnNcbiAgICBjb25zdCByZXBvcnQgPSB7fTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlcG9ydC50b3RhbERldGVjdGlvbnMgPSByZXN1bHQuZGV0ZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJlcG9ydC5yZWRhY3RlZENvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSByZXN1bHQuZGV0ZWN0aW9ucy5maW5kKGQgPT4gZC5pZCA9PT0gYWN0aW9uLmRldGVjdGlvbklkKTtcbiAgICAgICAgICAgIGlmIChkZXQpIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbZGV0LmtpbmRdID0gKGNvdW50c1tkZXQua2luZF0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcG9ydC5ieUtpbmQgPSBjb3VudHM7XG4gICAgfVxuICAgIHJldHVybiB7IGZpbGVVcmksIHJlcG9ydCB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../core-detect/dist/pipeline/apply.js\n"));

/***/ })

});