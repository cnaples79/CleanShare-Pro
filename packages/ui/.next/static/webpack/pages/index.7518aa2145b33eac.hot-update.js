"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "../core-detect/dist/index.js":
/*!************************************!*\
  !*** ../core-detect/dist/index.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDocument: function() { return /* reexport safe */ _pipeline_analyze__WEBPACK_IMPORTED_MODULE_1__.analyzeDocument; },\n/* harmony export */   applyRedactions: function() { return /* reexport safe */ _pipeline_apply__WEBPACK_IMPORTED_MODULE_2__.applyRedactions; },\n/* harmony export */   deletePreset: function() { return /* reexport safe */ _presets__WEBPACK_IMPORTED_MODULE_3__.deletePreset; },\n/* harmony export */   getPreset: function() { return /* reexport safe */ _presets__WEBPACK_IMPORTED_MODULE_3__.getPreset; },\n/* harmony export */   listPresets: function() { return /* reexport safe */ _presets__WEBPACK_IMPORTED_MODULE_3__.listPresets; },\n/* harmony export */   savePreset: function() { return /* reexport safe */ _presets__WEBPACK_IMPORTED_MODULE_3__.savePreset; }\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"../core-detect/dist/types.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"analyzeDocument\",\"applyRedactions\",\"listPresets\",\"getPreset\",\"savePreset\",\"deletePreset\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _types__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var _pipeline_analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pipeline/analyze */ \"../core-detect/dist/pipeline/analyze.js\");\n/* harmony import */ var _pipeline_apply__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pipeline/apply */ \"../core-detect/dist/pipeline/apply.js\");\n/* harmony import */ var _presets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./presets */ \"../core-detect/dist/presets.js\");\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vY29yZS1kZXRlY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQzZCO0FBQ0Y7QUFDMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvcmUtZGV0ZWN0L2Rpc3QvaW5kZXguanM/NWVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB7IGFuYWx5emVEb2N1bWVudCB9IGZyb20gJy4vcGlwZWxpbmUvYW5hbHl6ZSc7XG5leHBvcnQgeyBhcHBseVJlZGFjdGlvbnMgfSBmcm9tICcuL3BpcGVsaW5lL2FwcGx5JztcbmV4cG9ydCB7IGxpc3RQcmVzZXRzLCBnZXRQcmVzZXQsIHNhdmVQcmVzZXQsIGRlbGV0ZVByZXNldCB9IGZyb20gJy4vcHJlc2V0cyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../core-detect/dist/index.js\n"));

/***/ }),

/***/ "../core-detect/dist/pipeline/apply.js":
/*!*********************************************!*\
  !*** ../core-detect/dist/pipeline/apply.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeDocument: function() { return /* binding */ analyzeDocument; },\n/* harmony export */   applyRedactions: function() { return /* binding */ applyRedactions; }\n/* harmony export */ });\n/* harmony import */ var _analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./analyze */ \"../core-detect/dist/pipeline/analyze.js\");\n/* harmony import */ var pdf_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdf-lib */ \"../../node_modules/.pnpm/pdf-lib@1.17.1/node_modules/pdf-lib/es/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"../../node_modules/.pnpm/next@14.1.0_@babel+core@7.28.3_react-dom@18.2.0_react@18.2.0__react@18.2.0/node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n// A module‑scoped variable to store the last analysis result.  applyRedactions()\n// uses this map to resolve detection IDs to bounding boxes.  In a real\n// application you should pass the detections directly to avoid shared\n// mutable state.  This simplified implementation is sufficient for the\n// demonstration.\nlet lastResult = null;\n/** Override the exported analyse function to capture the last result. */\nasync function analyzeDocument(file, opts = {}) {\n    const result = await (0,_analyze__WEBPACK_IMPORTED_MODULE_1__.analyzeDocument)(file, opts);\n    lastResult = result;\n    return result;\n}\n/** Internal helper: convert a canvas to a data URI. */\nfunction canvasToDataURL(canvas, mimeType = 'image/png', quality = 0.92) {\n    return canvas.toDataURL(mimeType, quality);\n}\n/** Internal helper: convert a File/Blob into a HTMLImageElement. */\nasync function fileToImage(file) {\n    const dataURL = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsDataURL(file);\n    });\n    const img = new Image();\n    await new Promise(resolve => {\n        img.onload = () => resolve();\n        img.src = dataURL;\n    });\n    return img;\n}\n/** Apply redactions to an image.  Returns a Data URI. */\nasync function applyRedactionsToImage(file, actions, quality = 0.92, detectionResult) {\n    const img = await fileToImage(file);\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        throw new Error('Cannot obtain 2D context');\n    // Draw original image\n    ctx.drawImage(img, 0, 0);\n    // Build detection map\n    const map = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            map.set(det.id, det);\n        }\n    }\n    // Utility helpers for drawing various redaction styles on images\n    function drawBox(x, y, w, h) {\n        ctx.fillStyle = 'black';\n        ctx.fillRect(x, y, w, h);\n    }\n    // Apply a CSS blur filter to a region by drawing the original image with\n    // the filter enabled only for that region.  Canvas 2D `filter` is\n    // supported in modern browsers.  We temporarily clip the context to\n    // restrict the blur effect to the redaction box.\n    function drawBlur(x, y, w, h) {\n        ctx.save();\n        ctx.filter = 'blur(8px)';\n        ctx.beginPath();\n        ctx.rect(x, y, w, h);\n        ctx.clip();\n        ctx.drawImage(img, 0, 0);\n        ctx.restore();\n    }\n    // Pixelate by drawing the region scaled down and back up.  Choose a\n    // pixel size relative to region size to maintain some obfuscation but\n    // not degrade performance too much.\n    function drawPixelate(x, y, w, h) {\n        const pixelSize = Math.max(4, Math.floor(Math.min(w, h) / 10));\n        // Create a temporary canvas to hold the region scaled down\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = Math.max(1, Math.floor(w / pixelSize));\n        tempCanvas.height = Math.max(1, Math.floor(h / pixelSize));\n        const tctx = tempCanvas.getContext('2d');\n        if (!tctx) {\n            drawBox(x, y, w, h);\n            return;\n        }\n        // Draw the region scaled down onto the temp canvas\n        tctx.drawImage(img, x, y, w, h, 0, 0, tempCanvas.width, tempCanvas.height);\n        // Now draw the scaled up version onto the main canvas to pixelate\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, x, y, w, h);\n        ctx.imageSmoothingEnabled = true;\n    }\n    // Draw a label over the region.  Fill a semi‑opaque box then draw\n    // the label text centred within.  When the label is too long to fit,\n    // truncate and append an ellipsis.\n    function drawLabel(x, y, w, h, text) {\n        ctx.save();\n        ctx.fillStyle = 'black';\n        ctx.fillRect(x, y, w, h);\n        ctx.fillStyle = 'white';\n        const fontSize = Math.max(10, Math.floor(h * 0.6));\n        ctx.font = `${fontSize}px sans-serif`;\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        // Truncate text if it won't fit\n        let label = text;\n        const maxWidth = w - 4;\n        while (ctx.measureText(label).width > maxWidth && label.length > 1) {\n            label = label.slice(0, -1);\n        }\n        if (label !== text) {\n            label = label.slice(0, -1) + '…';\n        }\n        ctx.fillText(label, x + w / 2, y + h / 2);\n        ctx.restore();\n    }\n    // Draw a mask that obscures all but the last four characters of the\n    // provided preview text.  The mask uses asterisks for the hidden\n    // portion.  Non‑digit characters are preserved in their positions.\n    function drawMaskLast4(x, y, w, h, preview) {\n        const text = preview || '';\n        // Keep only last 4 alphanumeric characters; replace preceding\n        // characters (letters or digits) with asterisks but preserve spaces and other symbols.\n        let masked = '';\n        let remaining = 4;\n        for (let i = text.length - 1; i >= 0; i--) {\n            const ch = text[i];\n            if (/\\w/.test(ch) && remaining > 0) {\n                masked = ch + masked;\n                remaining--;\n            }\n            else if (/\\w/.test(ch)) {\n                masked = '*' + masked;\n            }\n            else {\n                masked = ch + masked;\n            }\n        }\n        drawLabel(x, y, w, h, masked);\n    }\n    // Draw redactions using the selected style for each action.  If the\n    // style is not recognised, fallback to a solid box.\n    actions.forEach(action => {\n        const det = map.get(action.detectionId);\n        if (!det)\n            return;\n        const { box } = det;\n        const x = box.x * canvas.width;\n        const y = box.y * canvas.height;\n        const w = box.w * canvas.width;\n        const h = box.h * canvas.height;\n        switch (action.style) {\n            case 'BLUR':\n                drawBlur(x, y, w, h);\n                break;\n            case 'PIXELATE':\n                drawPixelate(x, y, w, h);\n                break;\n            case 'LABEL':\n                drawLabel(x, y, w, h, action.labelText || det.kind);\n                break;\n            case 'MASK_LAST4':\n                drawMaskLast4(x, y, w, h, det.preview);\n                break;\n            case 'REMOVE_METADATA':\n                // Metadata removal is handled by re‑encoding the image; no\n                // drawing needed for this redaction.\n                break;\n            default:\n                drawBox(x, y, w, h);\n        }\n    });\n    // Return a data URI without metadata (re‑encoding strips EXIF)\n    return canvas.toDataURL('image/jpeg', quality);\n}\n/** Apply redactions to a PDF.  Returns a Data URI of the new PDF. */\nasync function applyRedactionsToPdf(file, actions, detectionResult) {\n    const origBytes = await file.arrayBuffer();\n    const origPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.load(origBytes);\n    const newPdf = await pdf_lib__WEBPACK_IMPORTED_MODULE_0__.PDFDocument.create();\n    const detectionMap = new Map();\n    const detectionsToUse = detectionResult || lastResult;\n    if (detectionsToUse) {\n        for (const det of detectionsToUse.detections) {\n            detectionMap.set(det.id, det);\n        }\n    }\n    const total = origPdf.getPageCount();\n    for (let i = 0; i < total; i++) {\n        const [copiedPage] = await newPdf.copyPages(origPdf, [i]);\n        newPdf.addPage(copiedPage);\n        const { width, height } = copiedPage.getSize();\n        // Filter actions for this page\n        const pageActions = actions.filter(act => {\n            var _a;\n            const det = detectionMap.get(act.detectionId);\n            return det && ((_a = det.box.page) !== null && _a !== void 0 ? _a : 0) === i;\n        });\n        // Draw each redaction.  Always draw a black rectangle; then if the\n        // style supports text (LABEL or MASK_LAST4) overlay text on top.\n        for (const action of pageActions) {\n            const det = detectionMap.get(action.detectionId);\n            if (!det)\n                continue;\n            const { box } = det;\n            const x = box.x * width;\n            // Convert from top-left origin to PDF bottom-left origin\n            const y = (1 - box.y - box.h) * height;\n            const w = box.w * width;\n            const h = box.h * height;\n            // Draw base rectangle\n            copiedPage.drawRectangle({\n                x,\n                y,\n                width: w,\n                height: h,\n                color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(0, 0, 0),\n                opacity: 1\n            });\n            // Overlay text for LABEL or MASK_LAST4\n            if (action.style === 'LABEL' || action.style === 'MASK_LAST4') {\n                let text = '';\n                if (action.style === 'LABEL') {\n                    text = action.labelText || det.kind;\n                }\n                else if (action.style === 'MASK_LAST4') {\n                    const preview = det.preview || '';\n                    // Mask all but last four alphanumeric characters\n                    let masked = '';\n                    let remaining = 4;\n                    for (let i = preview.length - 1; i >= 0; i--) {\n                        const ch = preview[i];\n                        if (/\\w/.test(ch) && remaining > 0) {\n                            masked = ch + masked;\n                            remaining--;\n                        }\n                        else if (/\\w/.test(ch)) {\n                            masked = '*' + masked;\n                        }\n                        else {\n                            masked = ch + masked;\n                        }\n                    }\n                    text = masked;\n                }\n                // Ensure font size reasonably scales with height\n                const fontSize = Math.max(8, h * 0.6);\n                // Constrain text width; if too long, truncate and add ellipsis\n                let label = text;\n                // pdf-lib drawText does not provide measureText; approximate by\n                // character count relative to width and font size\n                const maxChars = Math.floor((w - 4) / (fontSize * 0.6));\n                if (label.length > maxChars) {\n                    label = label.slice(0, maxChars > 3 ? maxChars - 1 : 0) + '…';\n                }\n                // Approximate horizontal centering.  Estimate each character width as\n                // 0.6 × fontSize and compute offset relative to the region width.\n                const estTextWidth = label.length * fontSize * 0.6;\n                const xOffset = (w - estTextWidth) / 2;\n                copiedPage.drawText(label, {\n                    x: x + Math.max(0, xOffset),\n                    y: y + h / 2 - fontSize / 2,\n                    size: fontSize,\n                    color: (0,pdf_lib__WEBPACK_IMPORTED_MODULE_0__.rgb)(1, 1, 1)\n                });\n            }\n        }\n    }\n    const pdfBytes = await newPdf.save();\n    const base64 = typeof Buffer !== 'undefined' ? Buffer.from(pdfBytes).toString('base64') : btoa(String.fromCharCode(...new Uint8Array(pdfBytes)));\n    return `data:application/pdf;base64,${base64}`;\n}\n/**\n * Apply redactions to a file using the previously analysed detections.\n *\n * Note: This implementation relies on `lastResult` set by analyzeDocument().\n * In a real application you should pass the detections explicitly to avoid\n * hidden state.\n */\nasync function applyRedactions(file, actions, opts, detections) {\n    var _a;\n    // If detections are provided directly, create a temporary result object\n    let result = lastResult;\n    if (detections && detections.length > 0) {\n        result = {\n            detections: detections,\n            pages: Math.max(...detections.map(d => { var _a; return (_a = d.box.page) !== null && _a !== void 0 ? _a : 0; })) + 1 || 1\n        };\n    }\n    if (!result) {\n        throw new Error('No analysis result available.  Call analyzeDocument() first.');\n    }\n    const mime = file.type || '';\n    let fileUri;\n    if (mime === 'application/pdf' || opts.output === 'pdf') {\n        fileUri = await applyRedactionsToPdf(file, actions, result);\n    }\n    else {\n        const quality = (_a = opts.quality) !== null && _a !== void 0 ? _a : 0.92;\n        fileUri = await applyRedactionsToImage(file, actions, quality, result);\n    }\n    // Build a simple report summarising redactions\n    const report = {};\n    if (result) {\n        report.totalDetections = result.detections.length;\n        report.redactedCount = actions.length;\n        const counts = {};\n        for (const action of actions) {\n            const det = result.detections.find(d => d.id === action.detectionId);\n            if (det) {\n                counts[det.kind] = (counts[det.kind] || 0) + 1;\n            }\n        }\n        report.byKind = counts;\n    }\n    return { fileUri, report };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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REFBcUQsUUFBUSw4REFBOEQ7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2NvcmUtZGV0ZWN0L2Rpc3QvcGlwZWxpbmUvYXBwbHkuanM/MTM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhbmFseXplRG9jdW1lbnQgYXMgYW5hbHl6ZSB9IGZyb20gJy4vYW5hbHl6ZSc7XG5pbXBvcnQgeyBQREZEb2N1bWVudCwgcmdiIH0gZnJvbSAncGRmLWxpYic7XG4vLyBBIG1vZHVsZeKAkXNjb3BlZCB2YXJpYWJsZSB0byBzdG9yZSB0aGUgbGFzdCBhbmFseXNpcyByZXN1bHQuICBhcHBseVJlZGFjdGlvbnMoKVxuLy8gdXNlcyB0aGlzIG1hcCB0byByZXNvbHZlIGRldGVjdGlvbiBJRHMgdG8gYm91bmRpbmcgYm94ZXMuICBJbiBhIHJlYWxcbi8vIGFwcGxpY2F0aW9uIHlvdSBzaG91bGQgcGFzcyB0aGUgZGV0ZWN0aW9ucyBkaXJlY3RseSB0byBhdm9pZCBzaGFyZWRcbi8vIG11dGFibGUgc3RhdGUuICBUaGlzIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gaXMgc3VmZmljaWVudCBmb3IgdGhlXG4vLyBkZW1vbnN0cmF0aW9uLlxubGV0IGxhc3RSZXN1bHQgPSBudWxsO1xuLyoqIE92ZXJyaWRlIHRoZSBleHBvcnRlZCBhbmFseXNlIGZ1bmN0aW9uIHRvIGNhcHR1cmUgdGhlIGxhc3QgcmVzdWx0LiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVEb2N1bWVudChmaWxlLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplKGZpbGUsIG9wdHMpO1xuICAgIGxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBJbnRlcm5hbCBoZWxwZXI6IGNvbnZlcnQgYSBjYW52YXMgdG8gYSBkYXRhIFVSSS4gKi9cbmZ1bmN0aW9uIGNhbnZhc1RvRGF0YVVSTChjYW52YXMsIG1pbWVUeXBlID0gJ2ltYWdlL3BuZycsIHF1YWxpdHkgPSAwLjkyKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xufVxuLyoqIEludGVybmFsIGhlbHBlcjogY29udmVydCBhIEZpbGUvQmxvYiBpbnRvIGEgSFRNTEltYWdlRWxlbWVudC4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbGVUb0ltYWdlKGZpbGUpIHtcbiAgICBjb25zdCBkYXRhVVJMID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfSk7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKCk7XG4gICAgICAgIGltZy5zcmMgPSBkYXRhVVJMO1xuICAgIH0pO1xuICAgIHJldHVybiBpbWc7XG59XG4vKiogQXBwbHkgcmVkYWN0aW9ucyB0byBhbiBpbWFnZS4gIFJldHVybnMgYSBEYXRhIFVSSS4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5UmVkYWN0aW9uc1RvSW1hZ2UoZmlsZSwgYWN0aW9ucywgcXVhbGl0eSA9IDAuOTIsIGRldGVjdGlvblJlc3VsdCkge1xuICAgIGNvbnN0IGltZyA9IGF3YWl0IGZpbGVUb0ltYWdlKGZpbGUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoIWN0eClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2J0YWluIDJEIGNvbnRleHQnKTtcbiAgICAvLyBEcmF3IG9yaWdpbmFsIGltYWdlXG4gICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgIC8vIEJ1aWxkIGRldGVjdGlvbiBtYXBcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGV0ZWN0aW9uc1RvVXNlID0gZGV0ZWN0aW9uUmVzdWx0IHx8IGxhc3RSZXN1bHQ7XG4gICAgaWYgKGRldGVjdGlvbnNUb1VzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRldCBvZiBkZXRlY3Rpb25zVG9Vc2UuZGV0ZWN0aW9ucykge1xuICAgICAgICAgICAgbWFwLnNldChkZXQuaWQsIGRldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXRpbGl0eSBoZWxwZXJzIGZvciBkcmF3aW5nIHZhcmlvdXMgcmVkYWN0aW9uIHN0eWxlcyBvbiBpbWFnZXNcbiAgICBmdW5jdGlvbiBkcmF3Qm94KHgsIHksIHcsIGgpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgYSBDU1MgYmx1ciBmaWx0ZXIgdG8gYSByZWdpb24gYnkgZHJhd2luZyB0aGUgb3JpZ2luYWwgaW1hZ2Ugd2l0aFxuICAgIC8vIHRoZSBmaWx0ZXIgZW5hYmxlZCBvbmx5IGZvciB0aGF0IHJlZ2lvbi4gIENhbnZhcyAyRCBgZmlsdGVyYCBpc1xuICAgIC8vIHN1cHBvcnRlZCBpbiBtb2Rlcm4gYnJvd3NlcnMuICBXZSB0ZW1wb3JhcmlseSBjbGlwIHRoZSBjb250ZXh0IHRvXG4gICAgLy8gcmVzdHJpY3QgdGhlIGJsdXIgZWZmZWN0IHRvIHRoZSByZWRhY3Rpb24gYm94LlxuICAgIGZ1bmN0aW9uIGRyYXdCbHVyKHgsIHksIHcsIGgpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmZpbHRlciA9ICdibHVyKDhweCknO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIFBpeGVsYXRlIGJ5IGRyYXdpbmcgdGhlIHJlZ2lvbiBzY2FsZWQgZG93biBhbmQgYmFjayB1cC4gIENob29zZSBhXG4gICAgLy8gcGl4ZWwgc2l6ZSByZWxhdGl2ZSB0byByZWdpb24gc2l6ZSB0byBtYWludGFpbiBzb21lIG9iZnVzY2F0aW9uIGJ1dFxuICAgIC8vIG5vdCBkZWdyYWRlIHBlcmZvcm1hbmNlIHRvbyBtdWNoLlxuICAgIGZ1bmN0aW9uIGRyYXdQaXhlbGF0ZSh4LCB5LCB3LCBoKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsU2l6ZSA9IE1hdGgubWF4KDQsIE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAxMCkpO1xuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgY2FudmFzIHRvIGhvbGQgdGhlIHJlZ2lvbiBzY2FsZWQgZG93blxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHcgLyBwaXhlbFNpemUpKTtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGggLyBwaXhlbFNpemUpKTtcbiAgICAgICAgY29uc3QgdGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCF0Y3R4KSB7XG4gICAgICAgICAgICBkcmF3Qm94KHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERyYXcgdGhlIHJlZ2lvbiBzY2FsZWQgZG93biBvbnRvIHRoZSB0ZW1wIGNhbnZhc1xuICAgICAgICB0Y3R4LmRyYXdJbWFnZShpbWcsIHgsIHksIHcsIGgsIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gTm93IGRyYXcgdGhlIHNjYWxlZCB1cCB2ZXJzaW9uIG9udG8gdGhlIG1haW4gY2FudmFzIHRvIHBpeGVsYXRlXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wQ2FudmFzLCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCwgeCwgeSwgdywgaCk7XG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEcmF3IGEgbGFiZWwgb3ZlciB0aGUgcmVnaW9uLiAgRmlsbCBhIHNlbWnigJFvcGFxdWUgYm94IHRoZW4gZHJhd1xuICAgIC8vIHRoZSBsYWJlbCB0ZXh0IGNlbnRyZWQgd2l0aGluLiAgV2hlbiB0aGUgbGFiZWwgaXMgdG9vIGxvbmcgdG8gZml0LFxuICAgIC8vIHRydW5jYXRlIGFuZCBhcHBlbmQgYW4gZWxsaXBzaXMuXG4gICAgZnVuY3Rpb24gZHJhd0xhYmVsKHgsIHksIHcsIGgsIHRleHQpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGN0eC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gTWF0aC5tYXgoMTAsIE1hdGguZmxvb3IoaCAqIDAuNikpO1xuICAgICAgICBjdHguZm9udCA9IGAke2ZvbnRTaXplfXB4IHNhbnMtc2VyaWZgO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgLy8gVHJ1bmNhdGUgdGV4dCBpZiBpdCB3b24ndCBmaXRcbiAgICAgICAgbGV0IGxhYmVsID0gdGV4dDtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSB3IC0gNDtcbiAgICAgICAgd2hpbGUgKGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGggPiBtYXhXaWR0aCAmJiBsYWJlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFiZWwgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgLTEpICsgJ+KApic7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxUZXh0KGxhYmVsLCB4ICsgdyAvIDIsIHkgKyBoIC8gMik7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIC8vIERyYXcgYSBtYXNrIHRoYXQgb2JzY3VyZXMgYWxsIGJ1dCB0aGUgbGFzdCBmb3VyIGNoYXJhY3RlcnMgb2YgdGhlXG4gICAgLy8gcHJvdmlkZWQgcHJldmlldyB0ZXh0LiAgVGhlIG1hc2sgdXNlcyBhc3Rlcmlza3MgZm9yIHRoZSBoaWRkZW5cbiAgICAvLyBwb3J0aW9uLiAgTm9u4oCRZGlnaXQgY2hhcmFjdGVycyBhcmUgcHJlc2VydmVkIGluIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBmdW5jdGlvbiBkcmF3TWFza0xhc3Q0KHgsIHksIHcsIGgsIHByZXZpZXcpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHByZXZpZXcgfHwgJyc7XG4gICAgICAgIC8vIEtlZXAgb25seSBsYXN0IDQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnM7IHJlcGxhY2UgcHJlY2VkaW5nXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGxldHRlcnMgb3IgZGlnaXRzKSB3aXRoIGFzdGVyaXNrcyBidXQgcHJlc2VydmUgc3BhY2VzIGFuZCBvdGhlciBzeW1ib2xzLlxuICAgICAgICBsZXQgbWFza2VkID0gJyc7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSA0O1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0W2ldO1xuICAgICAgICAgICAgaWYgKC9cXHcvLnRlc3QoY2gpICYmIHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXNrZWQgPSBjaCArIG1hc2tlZDtcbiAgICAgICAgICAgICAgICByZW1haW5pbmctLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9cXHcvLnRlc3QoY2gpKSB7XG4gICAgICAgICAgICAgICAgbWFza2VkID0gJyonICsgbWFza2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFza2VkID0gY2ggKyBtYXNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xhYmVsKHgsIHksIHcsIGgsIG1hc2tlZCk7XG4gICAgfVxuICAgIC8vIERyYXcgcmVkYWN0aW9ucyB1c2luZyB0aGUgc2VsZWN0ZWQgc3R5bGUgZm9yIGVhY2ggYWN0aW9uLiAgSWYgdGhlXG4gICAgLy8gc3R5bGUgaXMgbm90IHJlY29nbmlzZWQsIGZhbGxiYWNrIHRvIGEgc29saWQgYm94LlxuICAgIGFjdGlvbnMuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBkZXQgPSBtYXAuZ2V0KGFjdGlvbi5kZXRlY3Rpb25JZCk7XG4gICAgICAgIGlmICghZGV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGJveCB9ID0gZGV0O1xuICAgICAgICBjb25zdCB4ID0gYm94LnggKiBjYW52YXMud2lkdGg7XG4gICAgICAgIGNvbnN0IHkgPSBib3gueSAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHcgPSBib3gudyAqIGNhbnZhcy53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IGJveC5oICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24uc3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0JMVVInOlxuICAgICAgICAgICAgICAgIGRyYXdCbHVyKHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUElYRUxBVEUnOlxuICAgICAgICAgICAgICAgIGRyYXdQaXhlbGF0ZSh4LCB5LCB3LCBoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xBQkVMJzpcbiAgICAgICAgICAgICAgICBkcmF3TGFiZWwoeCwgeSwgdywgaCwgYWN0aW9uLmxhYmVsVGV4dCB8fCBkZXQua2luZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNQVNLX0xBU1Q0JzpcbiAgICAgICAgICAgICAgICBkcmF3TWFza0xhc3Q0KHgsIHksIHcsIGgsIGRldC5wcmV2aWV3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9NRVRBREFUQSc6XG4gICAgICAgICAgICAgICAgLy8gTWV0YWRhdGEgcmVtb3ZhbCBpcyBoYW5kbGVkIGJ5IHJl4oCRZW5jb2RpbmcgdGhlIGltYWdlOyBub1xuICAgICAgICAgICAgICAgIC8vIGRyYXdpbmcgbmVlZGVkIGZvciB0aGlzIHJlZGFjdGlvbi5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZHJhd0JveCh4LCB5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFJldHVybiBhIGRhdGEgVVJJIHdpdGhvdXQgbWV0YWRhdGEgKHJl4oCRZW5jb2Rpbmcgc3RyaXBzIEVYSUYpXG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCBxdWFsaXR5KTtcbn1cbi8qKiBBcHBseSByZWRhY3Rpb25zIHRvIGEgUERGLiAgUmV0dXJucyBhIERhdGEgVVJJIG9mIHRoZSBuZXcgUERGLiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlSZWRhY3Rpb25zVG9QZGYoZmlsZSwgYWN0aW9ucywgZGV0ZWN0aW9uUmVzdWx0KSB7XG4gICAgY29uc3Qgb3JpZ0J5dGVzID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IG9yaWdQZGYgPSBhd2FpdCBQREZEb2N1bWVudC5sb2FkKG9yaWdCeXRlcyk7XG4gICAgY29uc3QgbmV3UGRmID0gYXdhaXQgUERGRG9jdW1lbnQuY3JlYXRlKCk7XG4gICAgY29uc3QgZGV0ZWN0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRldGVjdGlvbnNUb1VzZSA9IGRldGVjdGlvblJlc3VsdCB8fCBsYXN0UmVzdWx0O1xuICAgIGlmIChkZXRlY3Rpb25zVG9Vc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXQgb2YgZGV0ZWN0aW9uc1RvVXNlLmRldGVjdGlvbnMpIHtcbiAgICAgICAgICAgIGRldGVjdGlvbk1hcC5zZXQoZGV0LmlkLCBkZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsID0gb3JpZ1BkZi5nZXRQYWdlQ291bnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgY29uc3QgW2NvcGllZFBhZ2VdID0gYXdhaXQgbmV3UGRmLmNvcHlQYWdlcyhvcmlnUGRmLCBbaV0pO1xuICAgICAgICBuZXdQZGYuYWRkUGFnZShjb3BpZWRQYWdlKTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb3BpZWRQYWdlLmdldFNpemUoKTtcbiAgICAgICAgLy8gRmlsdGVyIGFjdGlvbnMgZm9yIHRoaXMgcGFnZVxuICAgICAgICBjb25zdCBwYWdlQWN0aW9ucyA9IGFjdGlvbnMuZmlsdGVyKGFjdCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZXQgPSBkZXRlY3Rpb25NYXAuZ2V0KGFjdC5kZXRlY3Rpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4gZGV0ICYmICgoX2EgPSBkZXQuYm94LnBhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID09PSBpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJhdyBlYWNoIHJlZGFjdGlvbi4gIEFsd2F5cyBkcmF3IGEgYmxhY2sgcmVjdGFuZ2xlOyB0aGVuIGlmIHRoZVxuICAgICAgICAvLyBzdHlsZSBzdXBwb3J0cyB0ZXh0IChMQUJFTCBvciBNQVNLX0xBU1Q0KSBvdmVybGF5IHRleHQgb24gdG9wLlxuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwYWdlQWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGV0ID0gZGV0ZWN0aW9uTWFwLmdldChhY3Rpb24uZGV0ZWN0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKCFkZXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB7IGJveCB9ID0gZGV0O1xuICAgICAgICAgICAgY29uc3QgeCA9IGJveC54ICogd2lkdGg7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gdG9wLWxlZnQgb3JpZ2luIHRvIFBERiBib3R0b20tbGVmdCBvcmlnaW5cbiAgICAgICAgICAgIGNvbnN0IHkgPSAoMSAtIGJveC55IC0gYm94LmgpICogaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgdyA9IGJveC53ICogd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoID0gYm94LmggKiBoZWlnaHQ7XG4gICAgICAgICAgICAvLyBEcmF3IGJhc2UgcmVjdGFuZ2xlXG4gICAgICAgICAgICBjb3BpZWRQYWdlLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgY29sb3I6IHJnYigwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE92ZXJsYXkgdGV4dCBmb3IgTEFCRUwgb3IgTUFTS19MQVNUNFxuICAgICAgICAgICAgaWYgKGFjdGlvbi5zdHlsZSA9PT0gJ0xBQkVMJyB8fCBhY3Rpb24uc3R5bGUgPT09ICdNQVNLX0xBU1Q0Jykge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5zdHlsZSA9PT0gJ0xBQkVMJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gYWN0aW9uLmxhYmVsVGV4dCB8fCBkZXQua2luZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uLnN0eWxlID09PSAnTUFTS19MQVNUNCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlldyA9IGRldC5wcmV2aWV3IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXNrIGFsbCBidXQgbGFzdCBmb3VyIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXNrZWQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwcmV2aWV3Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaCA9IHByZXZpZXdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgJiYgcmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZCA9IGNoICsgbWFza2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1xcdy8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrZWQgPSAnKicgKyBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrZWQgPSBjaCArIG1hc2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbWFza2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgZm9udCBzaXplIHJlYXNvbmFibHkgc2NhbGVzIHdpdGggaGVpZ2h0XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBNYXRoLm1heCg4LCBoICogMC42KTtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW4gdGV4dCB3aWR0aDsgaWYgdG9vIGxvbmcsIHRydW5jYXRlIGFuZCBhZGQgZWxsaXBzaXNcbiAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIC8vIHBkZi1saWIgZHJhd1RleHQgZG9lcyBub3QgcHJvdmlkZSBtZWFzdXJlVGV4dDsgYXBwcm94aW1hdGUgYnlcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgY291bnQgcmVsYXRpdmUgdG8gd2lkdGggYW5kIGZvbnQgc2l6ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG1heENoYXJzID0gTWF0aC5mbG9vcigodyAtIDQpIC8gKGZvbnRTaXplICogMC42KSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsLmxlbmd0aCA+IG1heENoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgbWF4Q2hhcnMgPiAzID8gbWF4Q2hhcnMgLSAxIDogMCkgKyAn4oCmJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgaG9yaXpvbnRhbCBjZW50ZXJpbmcuICBFc3RpbWF0ZSBlYWNoIGNoYXJhY3RlciB3aWR0aCBhc1xuICAgICAgICAgICAgICAgIC8vIDAuNiDDlyBmb250U2l6ZSBhbmQgY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHJlZ2lvbiB3aWR0aC5cbiAgICAgICAgICAgICAgICBjb25zdCBlc3RUZXh0V2lkdGggPSBsYWJlbC5sZW5ndGggKiBmb250U2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICBjb25zdCB4T2Zmc2V0ID0gKHcgLSBlc3RUZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBjb3BpZWRQYWdlLmRyYXdUZXh0KGxhYmVsLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHggKyBNYXRoLm1heCgwLCB4T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgeTogeSArIGggLyAyIC0gZm9udFNpemUgLyAyLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHJnYigxLCAxLCAxKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBkZkJ5dGVzID0gYXdhaXQgbmV3UGRmLnNhdmUoKTtcbiAgICBjb25zdCBiYXNlNjQgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IEJ1ZmZlci5mcm9tKHBkZkJ5dGVzKS50b1N0cmluZygnYmFzZTY0JykgOiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkocGRmQnl0ZXMpKSk7XG4gICAgcmV0dXJuIGBkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsJHtiYXNlNjR9YDtcbn1cbi8qKlxuICogQXBwbHkgcmVkYWN0aW9ucyB0byBhIGZpbGUgdXNpbmcgdGhlIHByZXZpb3VzbHkgYW5hbHlzZWQgZGV0ZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBUaGlzIGltcGxlbWVudGF0aW9uIHJlbGllcyBvbiBgbGFzdFJlc3VsdGAgc2V0IGJ5IGFuYWx5emVEb2N1bWVudCgpLlxuICogSW4gYSByZWFsIGFwcGxpY2F0aW9uIHlvdSBzaG91bGQgcGFzcyB0aGUgZGV0ZWN0aW9ucyBleHBsaWNpdGx5IHRvIGF2b2lkXG4gKiBoaWRkZW4gc3RhdGUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBseVJlZGFjdGlvbnMoZmlsZSwgYWN0aW9ucywgb3B0cywgZGV0ZWN0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICAvLyBJZiBkZXRlY3Rpb25zIGFyZSBwcm92aWRlZCBkaXJlY3RseSwgY3JlYXRlIGEgdGVtcG9yYXJ5IHJlc3VsdCBvYmplY3RcbiAgICBsZXQgcmVzdWx0ID0gbGFzdFJlc3VsdDtcbiAgICBpZiAoZGV0ZWN0aW9ucyAmJiBkZXRlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGV0ZWN0aW9uczogZGV0ZWN0aW9ucyxcbiAgICAgICAgICAgIHBhZ2VzOiBNYXRoLm1heCguLi5kZXRlY3Rpb25zLm1hcChkID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZC5ib3gucGFnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDsgfSkpICsgMSB8fCAxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYW5hbHlzaXMgcmVzdWx0IGF2YWlsYWJsZS4gIENhbGwgYW5hbHl6ZURvY3VtZW50KCkgZmlyc3QuJyk7XG4gICAgfVxuICAgIGNvbnN0IG1pbWUgPSBmaWxlLnR5cGUgfHwgJyc7XG4gICAgbGV0IGZpbGVVcmk7XG4gICAgaWYgKG1pbWUgPT09ICdhcHBsaWNhdGlvbi9wZGYnIHx8IG9wdHMub3V0cHV0ID09PSAncGRmJykge1xuICAgICAgICBmaWxlVXJpID0gYXdhaXQgYXBwbHlSZWRhY3Rpb25zVG9QZGYoZmlsZSwgYWN0aW9ucywgcmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSAoX2EgPSBvcHRzLnF1YWxpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAuOTI7XG4gICAgICAgIGZpbGVVcmkgPSBhd2FpdCBhcHBseVJlZGFjdGlvbnNUb0ltYWdlKGZpbGUsIGFjdGlvbnMsIHF1YWxpdHksIHJlc3VsdCk7XG4gICAgfVxuICAgIC8vIEJ1aWxkIGEgc2ltcGxlIHJlcG9ydCBzdW1tYXJpc2luZyByZWRhY3Rpb25zXG4gICAgY29uc3QgcmVwb3J0ID0ge307XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXBvcnQudG90YWxEZXRlY3Rpb25zID0gcmVzdWx0LmRldGVjdGlvbnMubGVuZ3RoO1xuICAgICAgICByZXBvcnQucmVkYWN0ZWRDb3VudCA9IGFjdGlvbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGV0ID0gcmVzdWx0LmRldGVjdGlvbnMuZmluZChkID0+IGQuaWQgPT09IGFjdGlvbi5kZXRlY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoZGV0KSB7XG4gICAgICAgICAgICAgICAgY291bnRzW2RldC5raW5kXSA9IChjb3VudHNbZGV0LmtpbmRdIHx8IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnQuYnlLaW5kID0gY291bnRzO1xuICAgIH1cbiAgICByZXR1cm4geyBmaWxlVXJpLCByZXBvcnQgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../core-detect/dist/pipeline/apply.js\n"));

/***/ })

});