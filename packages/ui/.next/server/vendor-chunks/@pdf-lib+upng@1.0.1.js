"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pdf-lib+upng@1.0.1";
exports.ids = ["vendor-chunks/@pdf-lib+upng@1.0.1"];
exports.modules = {

/***/ "../../node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/cjs/UPNG.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/cjs/UPNG.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _pako = _interopRequireDefault(__webpack_require__(/*! pako */ \"../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar UPNG = {};\n\nUPNG.toRGBA8 = function (out) {\n  var w = out.width,\n      h = out.height;\n  if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n  var frms = [];\n  if (out.frames[0].data == null) out.frames[0].data = out.data;\n  var len = w * h * 4,\n      img = new Uint8Array(len),\n      empty = new Uint8Array(len),\n      prev = new Uint8Array(len);\n\n  for (var i = 0; i < out.frames.length; i++) {\n    var frm = out.frames[i];\n    var fx = frm.rect.x,\n        fy = frm.rect.y,\n        fw = frm.rect.width,\n        fh = frm.rect.height;\n    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n    if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\n    if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n    frms.push(img.buffer.slice(0));\n\n    if (frm.dispose == 0) {} else if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\n  }\n\n  return frms;\n};\n\nUPNG.toRGBA8.decodeImage = function (data, w, h, out) {\n  var area = w * h,\n      bpp = UPNG.decode._getBPP(out);\n\n  var bpl = Math.ceil(w * bpp / 8); // bytes per line\n\n  var bf = new Uint8Array(area * 4),\n      bf32 = new Uint32Array(bf.buffer);\n  var ctype = out.ctype,\n      depth = out.depth;\n  var rs = UPNG._bin.readUshort; //console.log(ctype, depth);\n\n  var time = Date.now();\n\n  if (ctype == 6) {\n    // RGB + alpha\n    var qarea = area << 2;\n    if (depth == 8) for (var i = 0; i < qarea; i += 4) {\n      bf[i] = data[i];\n      bf[i + 1] = data[i + 1];\n      bf[i + 2] = data[i + 2];\n      bf[i + 3] = data[i + 3];\n    }\n    if (depth == 16) for (var i = 0; i < qarea; i++) {\n      bf[i] = data[i << 1];\n    }\n  } else if (ctype == 2) {\n    // RGB\n    var ts = out.tabs[\"tRNS\"];\n\n    if (ts == null) {\n      if (depth == 8) for (var i = 0; i < area; i++) {\n        var ti = i * 3;\n        bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n      }\n      if (depth == 16) for (var i = 0; i < area; i++) {\n        var ti = i * 6;\n        bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n      }\n    } else {\n      var tr = ts[0],\n          tg = ts[1],\n          tb = ts[2];\n      if (depth == 8) for (var i = 0; i < area; i++) {\n        var qi = i << 2,\n            ti = i * 3;\n        bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n        if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n      }\n      if (depth == 16) for (var i = 0; i < area; i++) {\n        var qi = i << 2,\n            ti = i * 6;\n        bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n        if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n      }\n    }\n  } else if (ctype == 3) {\n    // palette\n    var p = out.tabs[\"PLTE\"],\n        ap = out.tabs[\"tRNS\"],\n        tl = ap ? ap.length : 0; //console.log(p, ap);\n\n    if (depth == 1) for (var y = 0; y < h; y++) {\n      var s0 = y * bpl,\n          t0 = y * w;\n\n      for (var i = 0; i < w; i++) {\n        var qi = t0 + i << 2,\n            j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1,\n            cj = 3 * j;\n        bf[qi] = p[cj];\n        bf[qi + 1] = p[cj + 1];\n        bf[qi + 2] = p[cj + 2];\n        bf[qi + 3] = j < tl ? ap[j] : 255;\n      }\n    }\n    if (depth == 2) for (var y = 0; y < h; y++) {\n      var s0 = y * bpl,\n          t0 = y * w;\n\n      for (var i = 0; i < w; i++) {\n        var qi = t0 + i << 2,\n            j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3,\n            cj = 3 * j;\n        bf[qi] = p[cj];\n        bf[qi + 1] = p[cj + 1];\n        bf[qi + 2] = p[cj + 2];\n        bf[qi + 3] = j < tl ? ap[j] : 255;\n      }\n    }\n    if (depth == 4) for (var y = 0; y < h; y++) {\n      var s0 = y * bpl,\n          t0 = y * w;\n\n      for (var i = 0; i < w; i++) {\n        var qi = t0 + i << 2,\n            j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15,\n            cj = 3 * j;\n        bf[qi] = p[cj];\n        bf[qi + 1] = p[cj + 1];\n        bf[qi + 2] = p[cj + 2];\n        bf[qi + 3] = j < tl ? ap[j] : 255;\n      }\n    }\n    if (depth == 8) for (var i = 0; i < area; i++) {\n      var qi = i << 2,\n          j = data[i],\n          cj = 3 * j;\n      bf[qi] = p[cj];\n      bf[qi + 1] = p[cj + 1];\n      bf[qi + 2] = p[cj + 2];\n      bf[qi + 3] = j < tl ? ap[j] : 255;\n    }\n  } else if (ctype == 4) {\n    // gray + alpha\n    if (depth == 8) for (var i = 0; i < area; i++) {\n      var qi = i << 2,\n          di = i << 1,\n          gr = data[di];\n      bf[qi] = gr;\n      bf[qi + 1] = gr;\n      bf[qi + 2] = gr;\n      bf[qi + 3] = data[di + 1];\n    }\n    if (depth == 16) for (var i = 0; i < area; i++) {\n      var qi = i << 2,\n          di = i << 2,\n          gr = data[di];\n      bf[qi] = gr;\n      bf[qi + 1] = gr;\n      bf[qi + 2] = gr;\n      bf[qi + 3] = data[di + 2];\n    }\n  } else if (ctype == 0) {\n    // gray\n    var tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n\n    for (var y = 0; y < h; y++) {\n      var off = y * bpl,\n          to = y * w;\n      if (depth == 1) for (var x = 0; x < w; x++) {\n        var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1),\n            al = gr == tr * 255 ? 0 : 255;\n        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n      } else if (depth == 2) for (var x = 0; x < w; x++) {\n        var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3),\n            al = gr == tr * 85 ? 0 : 255;\n        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n      } else if (depth == 4) for (var x = 0; x < w; x++) {\n        var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15),\n            al = gr == tr * 17 ? 0 : 255;\n        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n      } else if (depth == 8) for (var x = 0; x < w; x++) {\n        var gr = data[off + x],\n            al = gr == tr ? 0 : 255;\n        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n      } else if (depth == 16) for (var x = 0; x < w; x++) {\n        var gr = data[off + (x << 1)],\n            al = rs(data, off + (x << i)) == tr ? 0 : 255;\n        bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n      }\n    }\n  } //console.log(Date.now()-time);\n\n\n  return bf;\n};\n\nUPNG.decode = function (buff) {\n  var data = new Uint8Array(buff),\n      offset = 8,\n      bin = UPNG._bin,\n      rUs = bin.readUshort,\n      rUi = bin.readUint;\n  var out = {\n    tabs: {},\n    frames: []\n  };\n  var dd = new Uint8Array(data.length),\n      doff = 0; // put all IDAT data into it\n\n  var fd,\n      foff = 0; // frames\n\n  var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\n  for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw \"The input is not a PNG file!\";\n\n  while (offset < data.length) {\n    var len = bin.readUint(data, offset);\n    offset += 4;\n    var type = bin.readASCII(data, offset, 4);\n    offset += 4; //console.log(type,len);\n\n    if (type == \"IHDR\") {\n      UPNG.decode._IHDR(data, offset, out);\n    } else if (type == \"IDAT\") {\n      for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\n\n      doff += len;\n    } else if (type == \"acTL\") {\n      out.tabs[type] = {\n        num_frames: rUi(data, offset),\n        num_plays: rUi(data, offset + 4)\n      };\n      fd = new Uint8Array(data.length);\n    } else if (type == \"fcTL\") {\n      if (foff != 0) {\n        var fr = out.frames[out.frames.length - 1];\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n        foff = 0;\n      }\n\n      var rct = {\n        x: rUi(data, offset + 12),\n        y: rUi(data, offset + 16),\n        width: rUi(data, offset + 4),\n        height: rUi(data, offset + 8)\n      };\n      var del = rUs(data, offset + 22);\n      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n      var frm = {\n        rect: rct,\n        delay: Math.round(del * 1000),\n        dispose: data[offset + 24],\n        blend: data[offset + 25]\n      }; //console.log(frm);\n\n      out.frames.push(frm);\n    } else if (type == \"fdAT\") {\n      for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\n\n      foff += len - 4;\n    } else if (type == \"pHYs\") {\n      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\n    } else if (type == \"cHRM\") {\n      out.tabs[type] = [];\n\n      for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\n    } else if (type == \"tEXt\") {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = bin.nextZero(data, offset);\n      var keyw = bin.readASCII(data, offset, nz - offset);\n      var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);\n      out.tabs[type][keyw] = text;\n    } else if (type == \"iTXt\") {\n      if (out.tabs[type] == null) out.tabs[type] = {};\n      var nz = 0,\n          off = offset;\n      nz = bin.nextZero(data, off);\n      var keyw = bin.readASCII(data, off, nz - off);\n      off = nz + 1;\n      var cflag = data[off],\n          cmeth = data[off + 1];\n      off += 2;\n      nz = bin.nextZero(data, off);\n      var ltag = bin.readASCII(data, off, nz - off);\n      off = nz + 1;\n      nz = bin.nextZero(data, off);\n      var tkeyw = bin.readUTF8(data, off, nz - off);\n      off = nz + 1;\n      var text = bin.readUTF8(data, off, len - (off - offset));\n      out.tabs[type][keyw] = text;\n    } else if (type == \"PLTE\") {\n      out.tabs[type] = bin.readBytes(data, offset, len);\n    } else if (type == \"hIST\") {\n      var pl = out.tabs[\"PLTE\"].length / 3;\n      out.tabs[type] = [];\n\n      for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\n    } else if (type == \"tRNS\") {\n      if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)]; //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n    } else if (type == \"gAMA\") out.tabs[type] = bin.readUint(data, offset) / 100000;else if (type == \"sRGB\") out.tabs[type] = data[offset];else if (type == \"bKGD\") {\n      if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data, offset)];else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];else if (out.ctype == 3) out.tabs[type] = data[offset];\n    } else if (type == \"IEND\") {\n      break;\n    } //else {  log(\"unknown chunk type\", type, len);  }\n\n\n    offset += len;\n    var crc = bin.readUint(data, offset);\n    offset += 4;\n  }\n\n  if (foff != 0) {\n    var fr = out.frames[out.frames.length - 1];\n    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n    foff = 0;\n  }\n\n  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n  delete out.compress;\n  delete out.interlace;\n  delete out.filter;\n  return out;\n};\n\nUPNG.decode._decompress = function (out, dd, w, h) {\n  var time = Date.now();\n\n  var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n\n  dd = UPNG.decode._inflate(dd, buff); //console.log(dd.length, buff.length);\n  //console.log(Date.now()-time);\n\n  var time = Date.now();\n  if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out); //console.log(Date.now()-time);\n\n  return dd;\n};\n\nUPNG.decode._inflate = function (data, buff) {\n  var out = UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2, data.length - 6), buff);\n  return out;\n};\n\nUPNG.inflateRaw = function () {\n  var H = {};\n  H.H = {};\n\n  H.H.N = function (N, W) {\n    var R = Uint8Array,\n        i = 0,\n        m = 0,\n        J = 0,\n        h = 0,\n        Q = 0,\n        X = 0,\n        u = 0,\n        w = 0,\n        d = 0,\n        v,\n        C;\n    if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n    var V = H.H,\n        n = V.b,\n        A = V.e,\n        l = V.R,\n        M = V.n,\n        I = V.A,\n        e = V.Z,\n        b = V.m,\n        Z = W == null;\n    if (Z) W = new R(N.length >>> 2 << 3);\n\n    while (i == 0) {\n      i = n(N, d, 1);\n      m = n(N, d + 1, 2);\n      d += 3;\n\n      if (m == 0) {\n        if ((d & 7) != 0) d += 8 - (d & 7);\n        var D = (d >>> 3) + 4,\n            q = N[D - 4] | N[D - 3] << 8;\n        if (Z) W = H.H.W(W, w + q);\n        W.set(new R(N.buffer, N.byteOffset + D, q), w);\n        d = D + q << 3;\n        w += q;\n        continue;\n      }\n\n      if (Z) W = H.H.W(W, w + (1 << 17));\n\n      if (m == 1) {\n        v = b.J;\n        C = b.h;\n        X = (1 << 9) - 1;\n        u = (1 << 5) - 1;\n      }\n\n      if (m == 2) {\n        J = A(N, d, 5) + 257;\n        h = A(N, d + 5, 5) + 1;\n        Q = A(N, d + 10, 4) + 4;\n        d += 14;\n        var E = d,\n            j = 1;\n\n        for (var c = 0; c < 38; c += 2) {\n          b.Q[c] = 0;\n          b.Q[c + 1] = 0;\n        }\n\n        for (var c = 0; c < Q; c++) {\n          var K = A(N, d + c * 3, 3);\n          b.Q[(b.X[c] << 1) + 1] = K;\n          if (K > j) j = K;\n        }\n\n        d += 3 * Q;\n        M(b.Q, j);\n        I(b.Q, j, b.u);\n        v = b.w;\n        C = b.d;\n        d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n        var r = V.V(b.v, 0, J, b.C);\n        X = (1 << r) - 1;\n        var S = V.V(b.v, J, h, b.D);\n        u = (1 << S) - 1;\n        M(b.C, r);\n        I(b.C, r, v);\n        M(b.D, S);\n        I(b.D, S, C);\n      }\n\n      while (!0) {\n        var T = v[e(N, d) & X];\n        d += T & 15;\n        var p = T >>> 4;\n\n        if (p >>> 8 == 0) {\n          W[w++] = p;\n        } else if (p == 256) {\n          break;\n        } else {\n          var z = w + p - 254;\n\n          if (p > 264) {\n            var _ = b.q[p - 257];\n            z = w + (_ >>> 3) + A(N, d, _ & 7);\n            d += _ & 7;\n          }\n\n          var $ = C[e(N, d) & u];\n          d += $ & 15;\n          var s = $ >>> 4,\n              Y = b.c[s],\n              a = (Y >>> 4) + n(N, d, Y & 15);\n          d += Y & 15;\n\n          while (w < z) {\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n            W[w] = W[w++ - a];\n          }\n\n          w = z;\n        }\n      }\n    }\n\n    return W.length == w ? W : W.slice(0, w);\n  };\n\n  H.H.W = function (N, W) {\n    var R = N.length;\n    if (W <= R) return N;\n    var V = new Uint8Array(R << 1);\n    V.set(N, 0);\n    return V;\n  };\n\n  H.H.R = function (N, W, R, V, n, A) {\n    var l = H.H.e,\n        M = H.H.Z,\n        I = 0;\n\n    while (I < R) {\n      var e = N[M(V, n) & W];\n      n += e & 15;\n      var b = e >>> 4;\n\n      if (b <= 15) {\n        A[I] = b;\n        I++;\n      } else {\n        var Z = 0,\n            m = 0;\n\n        if (b == 16) {\n          m = 3 + l(V, n, 2);\n          n += 2;\n          Z = A[I - 1];\n        } else if (b == 17) {\n          m = 3 + l(V, n, 3);\n          n += 3;\n        } else if (b == 18) {\n          m = 11 + l(V, n, 7);\n          n += 7;\n        }\n\n        var J = I + m;\n\n        while (I < J) {\n          A[I] = Z;\n          I++;\n        }\n      }\n    }\n\n    return n;\n  };\n\n  H.H.V = function (N, W, R, V) {\n    var n = 0,\n        A = 0,\n        l = V.length >>> 1;\n\n    while (A < R) {\n      var M = N[A + W];\n      V[A << 1] = 0;\n      V[(A << 1) + 1] = M;\n      if (M > n) n = M;\n      A++;\n    }\n\n    while (A < l) {\n      V[A << 1] = 0;\n      V[(A << 1) + 1] = 0;\n      A++;\n    }\n\n    return n;\n  };\n\n  H.H.n = function (N, W) {\n    var R = H.H.m,\n        V = N.length,\n        n,\n        A,\n        l,\n        M,\n        I,\n        e = R.j;\n\n    for (var M = 0; M <= W; M++) e[M] = 0;\n\n    for (M = 1; M < V; M += 2) e[N[M]]++;\n\n    var b = R.K;\n    n = 0;\n    e[0] = 0;\n\n    for (A = 1; A <= W; A++) {\n      n = n + e[A - 1] << 1;\n      b[A] = n;\n    }\n\n    for (l = 0; l < V; l += 2) {\n      I = N[l + 1];\n\n      if (I != 0) {\n        N[l] = b[I];\n        b[I]++;\n      }\n    }\n  };\n\n  H.H.A = function (N, W, R) {\n    var V = N.length,\n        n = H.H.m,\n        A = n.r;\n\n    for (var l = 0; l < V; l += 2) if (N[l + 1] != 0) {\n      var M = l >> 1,\n          I = N[l + 1],\n          e = M << 4 | I,\n          b = W - I,\n          Z = N[l] << b,\n          m = Z + (1 << b);\n\n      while (Z != m) {\n        var J = A[Z] >>> 15 - W;\n        R[J] = e;\n        Z++;\n      }\n    }\n  };\n\n  H.H.l = function (N, W) {\n    var R = H.H.m.r,\n        V = 15 - W;\n\n    for (var n = 0; n < N.length; n += 2) {\n      var A = N[n] << W - N[n + 1];\n      N[n] = R[A] >>> V;\n    }\n  };\n\n  H.H.M = function (N, W, R) {\n    R = R << (W & 7);\n    var V = W >>> 3;\n    N[V] |= R;\n    N[V + 1] |= R >>> 8;\n  };\n\n  H.H.I = function (N, W, R) {\n    R = R << (W & 7);\n    var V = W >>> 3;\n    N[V] |= R;\n    N[V + 1] |= R >>> 8;\n    N[V + 2] |= R >>> 16;\n  };\n\n  H.H.e = function (N, W, R) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n  };\n\n  H.H.b = function (N, W, R) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n  };\n\n  H.H.Z = function (N, W) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n  };\n\n  H.H.i = function (N, W) {\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n  };\n\n  H.H.m = function () {\n    var N = Uint16Array,\n        W = Uint32Array;\n    return {\n      K: new N(16),\n      j: new N(16),\n      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n      q: new N(32),\n      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n      c: new W(32),\n      J: new N(512),\n      _: [],\n      h: new N(32),\n      $: [],\n      w: new N(32768),\n      C: [],\n      v: [],\n      d: new N(32768),\n      D: [],\n      u: new N(512),\n      Q: [],\n      r: new N(1 << 15),\n      s: new W(286),\n      Y: new W(30),\n      a: new W(19),\n      t: new W(15e3),\n      k: new N(1 << 16),\n      g: new N(1 << 15)\n    };\n  }();\n\n  (function () {\n    var N = H.H.m,\n        W = 1 << 15;\n\n    for (var R = 0; R < W; R++) {\n      var V = R;\n      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n      N.r[R] = (V >>> 16 | V << 16) >>> 17;\n    }\n\n    function n(A, l, M) {\n      while (l-- != 0) A.push(0, M);\n    }\n\n    for (var R = 0; R < 32; R++) {\n      N.q[R] = N.S[R] << 3 | N.T[R];\n      N.c[R] = N.p[R] << 4 | N.z[R];\n    }\n\n    n(N._, 144, 8);\n    n(N._, 255 - 143, 9);\n    n(N._, 279 - 255, 7);\n    n(N._, 287 - 279, 8);\n    H.H.n(N._, 9);\n    H.H.A(N._, 9, N.J);\n    H.H.l(N._, 9);\n    n(N.$, 32, 5);\n    H.H.n(N.$, 5);\n    H.H.A(N.$, 5, N.h);\n    H.H.l(N.$, 5);\n    n(N.Q, 19, 0);\n    n(N.C, 286, 0);\n    n(N.D, 30, 0);\n    n(N.v, 320, 0);\n  })();\n\n  return H.H.N;\n}();\n\nUPNG.decode._readInterlace = function (data, out) {\n  var w = out.width,\n      h = out.height;\n\n  var bpp = UPNG.decode._getBPP(out),\n      cbpp = bpp >> 3,\n      bpl = Math.ceil(w * bpp / 8);\n\n  var img = new Uint8Array(h * bpl);\n  var di = 0;\n  var starting_row = [0, 0, 4, 0, 2, 0, 1];\n  var starting_col = [0, 4, 0, 2, 0, 1, 0];\n  var row_increment = [8, 8, 8, 4, 4, 2, 2];\n  var col_increment = [8, 8, 4, 4, 2, 2, 1];\n  var pass = 0;\n\n  while (pass < 7) {\n    var ri = row_increment[pass],\n        ci = col_increment[pass];\n    var sw = 0,\n        sh = 0;\n    var cr = starting_row[pass];\n\n    while (cr < h) {\n      cr += ri;\n      sh++;\n    }\n\n    var cc = starting_col[pass];\n\n    while (cc < w) {\n      cc += ci;\n      sw++;\n    }\n\n    var bpll = Math.ceil(sw * bpp / 8);\n\n    UPNG.decode._filterZero(data, out, di, sw, sh);\n\n    var y = 0,\n        row = starting_row[pass];\n\n    while (row < h) {\n      var col = starting_col[pass];\n      var cdi = di + y * bpll << 3;\n\n      while (col < w) {\n        if (bpp == 1) {\n          var val = data[cdi >> 3];\n          val = val >> 7 - (cdi & 7) & 1;\n          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\n        }\n\n        if (bpp == 2) {\n          var val = data[cdi >> 3];\n          val = val >> 6 - (cdi & 7) & 3;\n          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\n        }\n\n        if (bpp == 4) {\n          var val = data[cdi >> 3];\n          val = val >> 4 - (cdi & 7) & 15;\n          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\n        }\n\n        if (bpp >= 8) {\n          var ii = row * bpl + col * cbpp;\n\n          for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\n        }\n\n        cdi += bpp;\n        col += ci;\n      }\n\n      y++;\n      row += ri;\n    }\n\n    if (sw * sh != 0) di += sh * (1 + bpll);\n    pass = pass + 1;\n  }\n\n  return img;\n};\n\nUPNG.decode._getBPP = function (out) {\n  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];\n  return noc * out.depth;\n};\n\nUPNG.decode._filterZero = function (data, out, off, w, h) {\n  var bpp = UPNG.decode._getBPP(out),\n      bpl = Math.ceil(w * bpp / 8),\n      paeth = UPNG.decode._paeth;\n\n  bpp = Math.ceil(bpp / 8);\n  var i = 0,\n      di = 1,\n      type = data[off],\n      x = 0;\n  if (type > 1) data[off] = [0, 0, 1][type - 2];\n  if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\n\n  for (var y = 0; y < h; y++) {\n    i = off + y * bpl;\n    di = i + y + 1;\n    type = data[di - 1];\n    x = 0;\n    if (type == 0) for (; x < bpl; x++) data[i + x] = data[di + x];else if (type == 1) {\n      for (; x < bpp; x++) data[i + x] = data[di + x];\n\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp];\n    } else if (type == 2) {\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl];\n    } else if (type == 3) {\n      for (; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\n\n      for (; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\n    } else {\n      for (; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\n\n      for (; x < bpl; x++) data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\n    }\n  }\n\n  return data;\n};\n\nUPNG.decode._paeth = function (a, b, c) {\n  var p = a + b - c,\n      pa = p - a,\n      pb = p - b,\n      pc = p - c;\n  if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;else if (pb * pb <= pc * pc) return b;\n  return c;\n};\n\nUPNG.decode._IHDR = function (data, offset, out) {\n  var bin = UPNG._bin;\n  out.width = bin.readUint(data, offset);\n  offset += 4;\n  out.height = bin.readUint(data, offset);\n  offset += 4;\n  out.depth = data[offset];\n  offset++;\n  out.ctype = data[offset];\n  offset++;\n  out.compress = data[offset];\n  offset++;\n  out.filter = data[offset];\n  offset++;\n  out.interlace = data[offset];\n  offset++;\n};\n\nUPNG._bin = {\n  nextZero: function (data, p) {\n    while (data[p] != 0) p++;\n\n    return p;\n  },\n  readUshort: function (buff, p) {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  writeUshort: function (buff, p, n) {\n    buff[p] = n >> 8 & 255;\n    buff[p + 1] = n & 255;\n  },\n  readUint: function (buff, p) {\n    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\n  },\n  writeUint: function (buff, p, n) {\n    buff[p] = n >> 24 & 255;\n    buff[p + 1] = n >> 16 & 255;\n    buff[p + 2] = n >> 8 & 255;\n    buff[p + 3] = n & 255;\n  },\n  readASCII: function (buff, p, l) {\n    var s = \"\";\n\n    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\n\n    return s;\n  },\n  writeASCII: function (data, p, s) {\n    for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);\n  },\n  readBytes: function (buff, p, l) {\n    var arr = [];\n\n    for (var i = 0; i < l; i++) arr.push(buff[p + i]);\n\n    return arr;\n  },\n  pad: function (n) {\n    return n.length < 2 ? \"0\" + n : n;\n  },\n  readUTF8: function (buff, p, l) {\n    var s = \"\",\n        ns;\n\n    for (var i = 0; i < l; i++) s += \"%\" + UPNG._bin.pad(buff[p + i].toString(16));\n\n    try {\n      ns = decodeURIComponent(s);\n    } catch (e) {\n      return UPNG._bin.readASCII(buff, p, l);\n    }\n\n    return ns;\n  }\n};\n\nUPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n  var w = Math.min(sw, tw),\n      h = Math.min(sh, th);\n  var si = 0,\n      ti = 0;\n\n  for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {\n    if (xoff >= 0 && yoff >= 0) {\n      si = y * sw + x << 2;\n      ti = (yoff + y) * tw + xoff + x << 2;\n    } else {\n      si = (-yoff + y) * sw - xoff + x << 2;\n      ti = y * tw + x << 2;\n    }\n\n    if (mode == 0) {\n      tb[ti] = sb[si];\n      tb[ti + 1] = sb[si + 1];\n      tb[ti + 2] = sb[si + 2];\n      tb[ti + 3] = sb[si + 3];\n    } else if (mode == 1) {\n      var fa = sb[si + 3] * (1 / 255),\n          fr = sb[si] * fa,\n          fg = sb[si + 1] * fa,\n          fb = sb[si + 2] * fa;\n      var ba = tb[ti + 3] * (1 / 255),\n          br = tb[ti] * ba,\n          bg = tb[ti + 1] * ba,\n          bb = tb[ti + 2] * ba;\n      var ifa = 1 - fa,\n          oa = fa + ba * ifa,\n          ioa = oa == 0 ? 0 : 1 / oa;\n      tb[ti + 3] = 255 * oa;\n      tb[ti + 0] = (fr + br * ifa) * ioa;\n      tb[ti + 1] = (fg + bg * ifa) * ioa;\n      tb[ti + 2] = (fb + bb * ifa) * ioa;\n    } else if (mode == 2) {\n      // copy only differences, otherwise zero\n      var fa = sb[si + 3],\n          fr = sb[si],\n          fg = sb[si + 1],\n          fb = sb[si + 2];\n      var ba = tb[ti + 3],\n          br = tb[ti],\n          bg = tb[ti + 1],\n          bb = tb[ti + 2];\n\n      if (fa == ba && fr == br && fg == bg && fb == bb) {\n        tb[ti] = 0;\n        tb[ti + 1] = 0;\n        tb[ti + 2] = 0;\n        tb[ti + 3] = 0;\n      } else {\n        tb[ti] = fr;\n        tb[ti + 1] = fg;\n        tb[ti + 2] = fb;\n        tb[ti + 3] = fa;\n      }\n    } else if (mode == 3) {\n      // check if can be blended\n      var fa = sb[si + 3],\n          fr = sb[si],\n          fg = sb[si + 1],\n          fb = sb[si + 2];\n      var ba = tb[ti + 3],\n          br = tb[ti],\n          bg = tb[ti + 1],\n          bb = tb[ti + 2];\n      if (fa == ba && fr == br && fg == bg && fb == bb) continue; //if(fa!=255 && ba!=0) return false;\n\n      if (fa < 220 && ba > 20) return false;\n    }\n  }\n\n  return true;\n};\n\nUPNG.encode = function (bufs, w, h, ps, dels, tabs, forbidPlte) {\n  if (ps == null) ps = 0;\n  if (forbidPlte == null) forbidPlte = false;\n  var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);\n  UPNG.encode.compressPNG(nimg, -1);\n  return UPNG.encode._main(nimg, w, h, dels, tabs);\n};\n\nUPNG.encodeLL = function (bufs, w, h, cc, ac, depth, dels, tabs) {\n  var nimg = {\n    ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),\n    depth: depth,\n    frames: []\n  };\n  var time = Date.now();\n  var bipp = (cc + ac) * depth,\n      bipl = bipp * w;\n\n  for (var i = 0; i < bufs.length; i++) nimg.frames.push({\n    rect: {\n      x: 0,\n      y: 0,\n      width: w,\n      height: h\n    },\n    img: new Uint8Array(bufs[i]),\n    blend: 0,\n    dispose: 1,\n    bpp: Math.ceil(bipp / 8),\n    bpl: Math.ceil(bipl / 8)\n  });\n\n  UPNG.encode.compressPNG(nimg, 0, true);\n\n  var out = UPNG.encode._main(nimg, w, h, dels, tabs);\n\n  return out;\n};\n\nUPNG.encode._main = function (nimg, w, h, dels, tabs) {\n  if (tabs == null) tabs = {};\n  var crc = UPNG.crc.crc,\n      wUi = UPNG._bin.writeUint,\n      wUs = UPNG._bin.writeUshort,\n      wAs = UPNG._bin.writeASCII;\n  var offset = 8,\n      anim = nimg.frames.length > 1,\n      pltAlpha = false;\n  var leng = 8 + (16 + 5 + 4)\n  /*+ (9+4)*/\n  + (anim ? 20 : 0);\n  if (tabs[\"sRGB\"] != null) leng += 8 + 1 + 4;\n  if (tabs[\"pHYs\"] != null) leng += 8 + 9 + 4;\n\n  if (nimg.ctype == 3) {\n    var dl = nimg.plte.length;\n\n    for (var i = 0; i < dl; i++) if (nimg.plte[i] >>> 24 != 255) pltAlpha = true;\n\n    leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);\n  }\n\n  for (var j = 0; j < nimg.frames.length; j++) {\n    var fr = nimg.frames[j];\n    if (anim) leng += 38;\n    leng += fr.cimg.length + 12;\n    if (j != 0) leng += 4;\n  }\n\n  leng += 12;\n  var data = new Uint8Array(leng);\n  var wr = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\n  for (var i = 0; i < 8; i++) data[i] = wr[i];\n\n  wUi(data, offset, 13);\n  offset += 4;\n  wAs(data, offset, \"IHDR\");\n  offset += 4;\n  wUi(data, offset, w);\n  offset += 4;\n  wUi(data, offset, h);\n  offset += 4;\n  data[offset] = nimg.depth;\n  offset++; // depth\n\n  data[offset] = nimg.ctype;\n  offset++; // ctype\n\n  data[offset] = 0;\n  offset++; // compress\n\n  data[offset] = 0;\n  offset++; // filter\n\n  data[offset] = 0;\n  offset++; // interlace\n\n  wUi(data, offset, crc(data, offset - 17, 17));\n  offset += 4; // crc\n  // 13 bytes to say, that it is sRGB\n\n  if (tabs[\"sRGB\"] != null) {\n    wUi(data, offset, 1);\n    offset += 4;\n    wAs(data, offset, \"sRGB\");\n    offset += 4;\n    data[offset] = tabs[\"sRGB\"];\n    offset++;\n    wUi(data, offset, crc(data, offset - 5, 5));\n    offset += 4; // crc\n  }\n\n  if (tabs[\"pHYs\"] != null) {\n    wUi(data, offset, 9);\n    offset += 4;\n    wAs(data, offset, \"pHYs\");\n    offset += 4;\n    wUi(data, offset, tabs[\"pHYs\"][0]);\n    offset += 4;\n    wUi(data, offset, tabs[\"pHYs\"][1]);\n    offset += 4;\n    data[offset] = tabs[\"pHYs\"][2];\n    offset++;\n    wUi(data, offset, crc(data, offset - 13, 13));\n    offset += 4; // crc\n  }\n\n  if (anim) {\n    wUi(data, offset, 8);\n    offset += 4;\n    wAs(data, offset, \"acTL\");\n    offset += 4;\n    wUi(data, offset, nimg.frames.length);\n    offset += 4;\n    wUi(data, offset, tabs[\"loop\"] != null ? tabs[\"loop\"] : 0);\n    offset += 4;\n    wUi(data, offset, crc(data, offset - 12, 12));\n    offset += 4; // crc\n  }\n\n  if (nimg.ctype == 3) {\n    var dl = nimg.plte.length;\n    wUi(data, offset, dl * 3);\n    offset += 4;\n    wAs(data, offset, \"PLTE\");\n    offset += 4;\n\n    for (var i = 0; i < dl; i++) {\n      var ti = i * 3,\n          c = nimg.plte[i],\n          r = c & 255,\n          g = c >>> 8 & 255,\n          b = c >>> 16 & 255;\n      data[offset + ti + 0] = r;\n      data[offset + ti + 1] = g;\n      data[offset + ti + 2] = b;\n    }\n\n    offset += dl * 3;\n    wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));\n    offset += 4; // crc\n\n    if (pltAlpha) {\n      wUi(data, offset, dl);\n      offset += 4;\n      wAs(data, offset, \"tRNS\");\n      offset += 4;\n\n      for (var i = 0; i < dl; i++) data[offset + i] = nimg.plte[i] >>> 24 & 255;\n\n      offset += dl;\n      wUi(data, offset, crc(data, offset - dl - 4, dl + 4));\n      offset += 4; // crc\n    }\n  }\n\n  var fi = 0;\n\n  for (var j = 0; j < nimg.frames.length; j++) {\n    var fr = nimg.frames[j];\n\n    if (anim) {\n      wUi(data, offset, 26);\n      offset += 4;\n      wAs(data, offset, \"fcTL\");\n      offset += 4;\n      wUi(data, offset, fi++);\n      offset += 4;\n      wUi(data, offset, fr.rect.width);\n      offset += 4;\n      wUi(data, offset, fr.rect.height);\n      offset += 4;\n      wUi(data, offset, fr.rect.x);\n      offset += 4;\n      wUi(data, offset, fr.rect.y);\n      offset += 4;\n      wUs(data, offset, dels[j]);\n      offset += 2;\n      wUs(data, offset, 1000);\n      offset += 2;\n      data[offset] = fr.dispose;\n      offset++; // dispose\n\n      data[offset] = fr.blend;\n      offset++; // blend\n\n      wUi(data, offset, crc(data, offset - 30, 30));\n      offset += 4; // crc\n    }\n\n    var imgd = fr.cimg,\n        dl = imgd.length;\n    wUi(data, offset, dl + (j == 0 ? 0 : 4));\n    offset += 4;\n    var ioff = offset;\n    wAs(data, offset, j == 0 ? \"IDAT\" : \"fdAT\");\n    offset += 4;\n\n    if (j != 0) {\n      wUi(data, offset, fi++);\n      offset += 4;\n    }\n\n    data.set(imgd, offset);\n    offset += dl;\n    wUi(data, offset, crc(data, ioff, offset - ioff));\n    offset += 4; // crc\n  }\n\n  wUi(data, offset, 0);\n  offset += 4;\n  wAs(data, offset, \"IEND\");\n  offset += 4;\n  wUi(data, offset, crc(data, offset - 4, 4));\n  offset += 4; // crc\n\n  return data.buffer;\n};\n\nUPNG.encode.compressPNG = function (out, filter, levelZero) {\n  for (var i = 0; i < out.frames.length; i++) {\n    var frm = out.frames[i],\n        nw = frm.rect.width,\n        nh = frm.rect.height;\n    var fdata = new Uint8Array(nh * frm.bpl + nh);\n    frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);\n  }\n};\n\nUPNG.encode.compress = function (bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\n{\n  //var time = Date.now();\n  var onlyBlend = prms[0],\n      evenCrd = prms[1],\n      forbidPrev = prms[2],\n      minBits = prms[3],\n      forbidPlte = prms[4];\n  var ctype = 6,\n      depth = 8,\n      alphaAnd = 255;\n\n  for (var j = 0; j < bufs.length; j++) {\n    // when not quantized, other frames can contain colors, that are not in an initial frame\n    var img = new Uint8Array(bufs[j]),\n        ilen = img.length;\n\n    for (var i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];\n  }\n\n  var gotAlpha = alphaAnd != 255; //console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n  //var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n\n  var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev); //console.log(\"framize\", Date.now()-time);  time = Date.now();\n\n  var cmap = {},\n      plte = [],\n      inds = [];\n\n  if (ps != 0) {\n    var nbufs = [];\n\n    for (var i = 0; i < frms.length; i++) nbufs.push(frms[i].img.buffer);\n\n    var abuf = UPNG.encode.concatRGBA(nbufs),\n        qres = UPNG.quantize(abuf, ps);\n    var cof = 0,\n        bb = new Uint8Array(qres.abuf);\n\n    for (var i = 0; i < frms.length; i++) {\n      var ti = frms[i].img,\n          bln = ti.length;\n      inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));\n\n      for (var j = 0; j < bln; j += 4) {\n        ti[j] = bb[cof + j];\n        ti[j + 1] = bb[cof + j + 1];\n        ti[j + 2] = bb[cof + j + 2];\n        ti[j + 3] = bb[cof + j + 3];\n      }\n\n      cof += bln;\n    }\n\n    for (var i = 0; i < qres.plte.length; i++) plte.push(qres.plte[i].est.rgba); //console.log(\"quantize\", Date.now()-time);  time = Date.now();\n\n  } else {\n    // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n    for (var j = 0; j < frms.length; j++) {\n      // when not quantized, other frames can contain colors, that are not in an initial frame\n      var frm = frms[j],\n          img32 = new Uint32Array(frm.img.buffer),\n          nw = frm.rect.width,\n          ilen = img32.length;\n      var ind = new Uint8Array(ilen);\n      inds.push(ind);\n\n      for (var i = 0; i < ilen; i++) {\n        var c = img32[i];\n        if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];else {\n          var cmc = cmap[c];\n\n          if (cmc == null) {\n            cmap[c] = cmc = plte.length;\n            plte.push(c);\n            if (plte.length >= 300) break;\n          }\n\n          ind[i] = cmc;\n        }\n      }\n    } //console.log(\"make palette\", Date.now()-time);  time = Date.now();\n\n  }\n\n  var cc = plte.length; //console.log(\"colors:\",cc);\n\n  if (cc <= 256 && forbidPlte == false) {\n    if (cc <= 2) depth = 1;else if (cc <= 4) depth = 2;else if (cc <= 16) depth = 4;else depth = 8;\n    depth = Math.max(depth, minBits);\n  }\n\n  for (var j = 0; j < frms.length; j++) {\n    var frm = frms[j],\n        nx = frm.rect.x,\n        ny = frm.rect.y,\n        nw = frm.rect.width,\n        nh = frm.rect.height;\n    var cimg = frm.img,\n        cimg32 = new Uint32Array(cimg.buffer);\n    var bpl = 4 * nw,\n        bpp = 4;\n\n    if (cc <= 256 && forbidPlte == false) {\n      bpl = Math.ceil(depth * nw / 8);\n      var nimg = new Uint8Array(bpl * nh);\n      var inj = inds[j];\n\n      for (var y = 0; y < nh; y++) {\n        var i = y * bpl,\n            ii = y * nw;\n        if (depth == 8) for (var x = 0; x < nw; x++) nimg[i + x] = inj[ii + x];else if (depth == 4) for (var x = 0; x < nw; x++) nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;else if (depth == 2) for (var x = 0; x < nw; x++) nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;else if (depth == 1) for (var x = 0; x < nw; x++) nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;\n      }\n\n      cimg = nimg;\n      ctype = 3;\n      bpp = 1;\n    } else if (gotAlpha == false && frms.length == 1) {\n      // some next \"reduced\" frames may contain alpha for blending\n      var nimg = new Uint8Array(nw * nh * 3),\n          area = nw * nh;\n\n      for (var i = 0; i < area; i++) {\n        var ti = i * 3,\n            qi = i * 4;\n        nimg[ti] = cimg[qi];\n        nimg[ti + 1] = cimg[qi + 1];\n        nimg[ti + 2] = cimg[qi + 2];\n      }\n\n      cimg = nimg;\n      ctype = 2;\n      bpp = 3;\n      bpl = 3 * nw;\n    }\n\n    frm.img = cimg;\n    frm.bpl = bpl;\n    frm.bpp = bpp;\n  } //console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n\n\n  return {\n    ctype: ctype,\n    depth: depth,\n    plte: plte,\n    frames: frms\n  };\n};\n\nUPNG.encode.framize = function (bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {\n  /*  DISPOSE\n      - 0 : no change\n  \t- 1 : clear to transparent\n  \t- 2 : retstore to content before rendering (previous frame disposed)\n  \tBLEND\n  \t- 0 : replace\n  \t- 1 : blend\n  */\n  var frms = [];\n\n  for (var j = 0; j < bufs.length; j++) {\n    var cimg = new Uint8Array(bufs[j]),\n        cimg32 = new Uint32Array(cimg.buffer);\n    var nimg;\n    var nx = 0,\n        ny = 0,\n        nw = w,\n        nh = h,\n        blend = alwaysBlend ? 1 : 0;\n\n    if (j != 0) {\n      var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2,\n          tstp = 0,\n          tarea = 1e9;\n\n      for (var it = 0; it < tlim; it++) {\n        var pimg = new Uint8Array(bufs[j - 1 - it]),\n            p32 = new Uint32Array(bufs[j - 1 - it]);\n        var mix = w,\n            miy = h,\n            max = -1,\n            may = -1;\n\n        for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {\n          var i = y * w + x;\n\n          if (cimg32[i] != p32[i]) {\n            if (x < mix) mix = x;\n            if (x > max) max = x;\n            if (y < miy) miy = y;\n            if (y > may) may = y;\n          }\n        }\n\n        if (max == -1) mix = miy = max = may = 0;\n\n        if (evenCrd) {\n          if ((mix & 1) == 1) mix--;\n          if ((miy & 1) == 1) miy--;\n        }\n\n        var sarea = (max - mix + 1) * (may - miy + 1);\n\n        if (sarea < tarea) {\n          tarea = sarea;\n          tstp = it;\n          nx = mix;\n          ny = miy;\n          nw = max - mix + 1;\n          nh = may - miy + 1;\n        }\n      } // alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n\n\n      var pimg = new Uint8Array(bufs[j - 1 - tstp]);\n      if (tstp == 1) frms[j - 1].dispose = 2;\n      nimg = new Uint8Array(nw * nh * 4);\n\n      UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n\n      blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;\n      if (blend == 1) UPNG.encode._prepareDiff(cimg, w, h, nimg, {\n        x: nx,\n        y: ny,\n        width: nw,\n        height: nh\n      });else UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0); //UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n    } else nimg = cimg.slice(0); // img may be rewritten further ... don't rewrite input\n\n\n    frms.push({\n      rect: {\n        x: nx,\n        y: ny,\n        width: nw,\n        height: nh\n      },\n      img: nimg,\n      blend: blend,\n      dispose: 0\n    });\n  }\n\n  if (alwaysBlend) for (var j = 0; j < frms.length; j++) {\n    var frm = frms[j];\n    if (frm.blend == 1) continue;\n    var r0 = frm.rect,\n        r1 = frms[j - 1].rect;\n    var miX = Math.min(r0.x, r1.x),\n        miY = Math.min(r0.y, r1.y);\n    var maX = Math.max(r0.x + r0.width, r1.x + r1.width),\n        maY = Math.max(r0.y + r0.height, r1.y + r1.height);\n    var r = {\n      x: miX,\n      y: miY,\n      width: maX - miX,\n      height: maY - miY\n    };\n    frms[j - 1].dispose = 1;\n    if (j - 1 != 0) UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);\n\n    UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);\n  }\n  var area = 0;\n  if (bufs.length != 1) for (var i = 0; i < frms.length; i++) {\n    var frm = frms[i];\n    area += frm.rect.width * frm.rect.height; //if(i==0 || frm.blend!=1) continue;\n    //var ob = new Uint8Array(\n    //console.log(frm.blend, frm.dispose, frm.rect);\n  } //if(area!=0) console.log(area);\n\n  return frms;\n};\n\nUPNG.encode._updateFrame = function (bufs, w, h, frms, i, r, evenCrd) {\n  var U8 = Uint8Array,\n      U32 = Uint32Array;\n  var pimg = new U8(bufs[i - 1]),\n      pimg32 = new U32(bufs[i - 1]),\n      nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;\n  var cimg = new U8(bufs[i]),\n      cimg32 = new U32(cimg.buffer);\n  var mix = w,\n      miy = h,\n      max = -1,\n      may = -1;\n\n  for (var y = 0; y < r.height; y++) for (var x = 0; x < r.width; x++) {\n    var cx = r.x + x,\n        cy = r.y + y;\n    var j = cy * w + cx,\n        cc = cimg32[j]; // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n\n    if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)\n    /**/\n    ) {} else {\n      if (cx < mix) mix = cx;\n      if (cx > max) max = cx;\n      if (cy < miy) miy = cy;\n      if (cy > may) may = cy;\n    }\n  }\n\n  if (max == -1) mix = miy = max = may = 0;\n\n  if (evenCrd) {\n    if ((mix & 1) == 1) mix--;\n    if ((miy & 1) == 1) miy--;\n  }\n\n  r = {\n    x: mix,\n    y: miy,\n    width: max - mix + 1,\n    height: may - miy + 1\n  };\n  var fr = frms[i];\n  fr.rect = r;\n  fr.blend = 1;\n  fr.img = new Uint8Array(r.width * r.height * 4);\n\n  if (frms[i - 1].dispose == 0) {\n    UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n\n    UPNG.encode._prepareDiff(cimg, w, h, fr.img, r); //UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n\n  } else UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n};\n\nUPNG.encode._prepareDiff = function (cimg, w, h, nimg, rec) {\n  UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);\n  /*\n  var n32 = new Uint32Array(nimg.buffer);\n  var og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n  UPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n  for(var i=4; i<nimg.length; i+=4) {\n  \tif(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n  \t\tn32[i>>>2]=o32[i>>>2];\n  \t\t//var j = i, c=p32[(i>>>2)-1];\n  \t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n  \t}\n  }\n  for(var i=nimg.length-8; i>0; i-=4) {\n  \tif(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n  \t\tn32[i>>>2]=o32[i>>>2];\n  \t\t//var j = i, c=p32[(i>>>2)-1];\n  \t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n  \t}\n  }*/\n\n};\n\nUPNG.encode._filterZero = function (img, h, bpp, bpl, data, filter, levelZero) {\n  var fls = [],\n      ftry = [0, 1, 2, 3, 4];\n  if (filter != -1) ftry = [filter];else if (h * bpl > 500000 || bpp == 1) ftry = [0];\n  var opts;\n  if (levelZero) opts = {\n    level: 0\n  };\n  var CMPR = levelZero && UZIP != null ? UZIP : _pako.default;\n\n  for (var i = 0; i < ftry.length; i++) {\n    for (var y = 0; y < h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]); //var nimg = new Uint8Array(data.length);\n    //var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n    //var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n    //var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n    //console.log(crc, UZIP.adler(data,2,data.length-6));\n\n\n    fls.push(CMPR[\"deflate\"](data, opts));\n  }\n\n  var ti,\n      tsize = 1e9;\n\n  for (var i = 0; i < fls.length; i++) if (fls[i].length < tsize) {\n    ti = i;\n    tsize = fls[i].length;\n  }\n\n  return fls[ti];\n};\n\nUPNG.encode._filterLine = function (data, img, y, bpl, bpp, type) {\n  var i = y * bpl,\n      di = i + y,\n      paeth = UPNG.decode._paeth;\n  data[di] = type;\n  di++;\n\n  if (type == 0) {\n    if (bpl < 500) for (var x = 0; x < bpl; x++) data[di + x] = img[i + x];else data.set(new Uint8Array(img.buffer, i, bpl), di);\n  } else if (type == 1) {\n    for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n\n    for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;\n  } else if (y == 0) {\n    for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n\n    if (type == 2) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x];\n    if (type == 3) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;\n    if (type == 4) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;\n  } else {\n    if (type == 2) {\n      for (var x = 0; x < bpl; x++) data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;\n    }\n\n    if (type == 3) {\n      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;\n\n      for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;\n    }\n\n    if (type == 4) {\n      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;\n\n      for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;\n    }\n  }\n};\n\nUPNG.crc = {\n  table: function () {\n    var tab = new Uint32Array(256);\n\n    for (var n = 0; n < 256; n++) {\n      var c = n;\n\n      for (var k = 0; k < 8; k++) {\n        if (c & 1) c = 0xedb88320 ^ c >>> 1;else c = c >>> 1;\n      }\n\n      tab[n] = c;\n    }\n\n    return tab;\n  }(),\n  update: function (c, buf, off, len) {\n    for (var i = 0; i < len; i++) c = UPNG.crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;\n\n    return c;\n  },\n  crc: function (b, o, l) {\n    return UPNG.crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\n  }\n};\n\nUPNG.quantize = function (abuf, ps) {\n  var oimg = new Uint8Array(abuf),\n      nimg = oimg.slice(0),\n      nimg32 = new Uint32Array(nimg.buffer);\n  var KD = UPNG.quantize.getKDtree(nimg, ps);\n  var root = KD[0],\n      leafs = KD[1];\n  var planeDst = UPNG.quantize.planeDst;\n  var sb = oimg,\n      tb = nimg32,\n      len = sb.length;\n  var inds = new Uint8Array(oimg.length >> 2);\n\n  for (var i = 0; i < len; i += 4) {\n    var r = sb[i] * (1 / 255),\n        g = sb[i + 1] * (1 / 255),\n        b = sb[i + 2] * (1 / 255),\n        a = sb[i + 3] * (1 / 255); //  exact, but too slow :(\n\n    var nd = UPNG.quantize.getNearest(root, r, g, b, a); //var nd = root;\n    //while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n\n    inds[i >> 2] = nd.ind;\n    tb[i >> 2] = nd.est.rgba;\n  }\n\n  return {\n    abuf: nimg.buffer,\n    inds: inds,\n    plte: leafs\n  };\n};\n\nUPNG.quantize.getKDtree = function (nimg, ps, err) {\n  if (err == null) err = 0.0001;\n  var nimg32 = new Uint32Array(nimg.buffer);\n  var root = {\n    i0: 0,\n    i1: nimg.length,\n    bst: null,\n    est: null,\n    tdst: 0,\n    left: null,\n    right: null\n  }; // basic statistic, extra statistic\n\n  root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);\n  root.est = UPNG.quantize.estats(root.bst);\n  var leafs = [root];\n\n  while (leafs.length < ps) {\n    var maxL = 0,\n        mi = 0;\n\n    for (var i = 0; i < leafs.length; i++) if (leafs[i].est.L > maxL) {\n      maxL = leafs[i].est.L;\n      mi = i;\n    }\n\n    if (maxL < err) break;\n    var node = leafs[mi];\n    var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n    var s0wrong = node.i0 >= s0 || node.i1 <= s0; //console.log(maxL, leafs.length, mi);\n\n    if (s0wrong) {\n      node.est.L = 0;\n      continue;\n    }\n\n    var ln = {\n      i0: node.i0,\n      i1: s0,\n      bst: null,\n      est: null,\n      tdst: 0,\n      left: null,\n      right: null\n    };\n    ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);\n    ln.est = UPNG.quantize.estats(ln.bst);\n    var rn = {\n      i0: s0,\n      i1: node.i1,\n      bst: null,\n      est: null,\n      tdst: 0,\n      left: null,\n      right: null\n    };\n    rn.bst = {\n      R: [],\n      m: [],\n      N: node.bst.N - ln.bst.N\n    };\n\n    for (var i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\n\n    for (var i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\n\n    rn.est = UPNG.quantize.estats(rn.bst);\n    node.left = ln;\n    node.right = rn;\n    leafs[mi] = ln;\n    leafs.push(rn);\n  }\n\n  leafs.sort(function (a, b) {\n    return b.bst.N - a.bst.N;\n  });\n\n  for (var i = 0; i < leafs.length; i++) leafs[i].ind = i;\n\n  return [root, leafs];\n};\n\nUPNG.quantize.getNearest = function (nd, r, g, b, a) {\n  if (nd.left == null) {\n    nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);\n    return nd;\n  }\n\n  var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);\n  var node0 = nd.left,\n      node1 = nd.right;\n\n  if (planeDst > 0) {\n    node0 = nd.right;\n    node1 = nd.left;\n  }\n\n  var ln = UPNG.quantize.getNearest(node0, r, g, b, a);\n  if (ln.tdst <= planeDst * planeDst) return ln;\n  var rn = UPNG.quantize.getNearest(node1, r, g, b, a);\n  return rn.tdst < ln.tdst ? rn : ln;\n};\n\nUPNG.quantize.planeDst = function (est, r, g, b, a) {\n  var e = est.e;\n  return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;\n};\n\nUPNG.quantize.dist = function (q, r, g, b, a) {\n  var d0 = r - q[0],\n      d1 = g - q[1],\n      d2 = b - q[2],\n      d3 = a - q[3];\n  return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\n};\n\nUPNG.quantize.splitPixels = function (nimg, nimg32, i0, i1, e, eMq) {\n  var vecDot = UPNG.quantize.vecDot;\n  i1 -= 4;\n  var shfs = 0;\n\n  while (i0 < i1) {\n    while (vecDot(nimg, i0, e) <= eMq) i0 += 4;\n\n    while (vecDot(nimg, i1, e) > eMq) i1 -= 4;\n\n    if (i0 >= i1) break;\n    var t = nimg32[i0 >> 2];\n    nimg32[i0 >> 2] = nimg32[i1 >> 2];\n    nimg32[i1 >> 2] = t;\n    i0 += 4;\n    i1 -= 4;\n  }\n\n  while (vecDot(nimg, i0, e) > eMq) i0 -= 4;\n\n  return i0 + 4;\n};\n\nUPNG.quantize.vecDot = function (nimg, i, e) {\n  return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\n};\n\nUPNG.quantize.stats = function (nimg, i0, i1) {\n  var R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  var m = [0, 0, 0, 0];\n  var N = i1 - i0 >> 2;\n\n  for (var i = i0; i < i1; i += 4) {\n    var r = nimg[i] * (1 / 255),\n        g = nimg[i + 1] * (1 / 255),\n        b = nimg[i + 2] * (1 / 255),\n        a = nimg[i + 3] * (1 / 255); //var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n\n    m[0] += r;\n    m[1] += g;\n    m[2] += b;\n    m[3] += a;\n    R[0] += r * r;\n    R[1] += r * g;\n    R[2] += r * b;\n    R[3] += r * a;\n    R[5] += g * g;\n    R[6] += g * b;\n    R[7] += g * a;\n    R[10] += b * b;\n    R[11] += b * a;\n    R[15] += a * a;\n  }\n\n  R[4] = R[1];\n  R[8] = R[2];\n  R[9] = R[6];\n  R[12] = R[3];\n  R[13] = R[7];\n  R[14] = R[11];\n  return {\n    R: R,\n    m: m,\n    N: N\n  };\n};\n\nUPNG.quantize.estats = function (stats) {\n  var R = stats.R,\n      m = stats.m,\n      N = stats.N; // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n\n  var m0 = m[0],\n      m1 = m[1],\n      m2 = m[2],\n      m3 = m[3],\n      iN = N == 0 ? 0 : 1 / N;\n  var Rj = [R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN, R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN, R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN, R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN];\n  var A = Rj,\n      M = UPNG.M4;\n  var b = [0.5, 0.5, 0.5, 0.5],\n      mi = 0,\n      tmi = 0;\n  if (N != 0) for (var i = 0; i < 10; i++) {\n    b = M.multVec(A, b);\n    tmi = Math.sqrt(M.dot(b, b));\n    b = M.sml(1 / tmi, b);\n    if (Math.abs(tmi - mi) < 1e-9) break;\n    mi = tmi;\n  } //b = [0,0,1,0];  mi=N;\n\n  var q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];\n  var eMq255 = M.dot(M.sml(255, q), b);\n  return {\n    Cov: Rj,\n    q: q,\n    e: b,\n    L: mi,\n    eMq255: eMq255,\n    eMq: M.dot(b, q),\n    rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0\n  };\n};\n\nUPNG.M4 = {\n  multVec: function (m, v) {\n    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3], m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3], m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3], m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]];\n  },\n  dot: function (x, y) {\n    return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];\n  },\n  sml: function (a, y) {\n    return [a * y[0], a * y[1], a * y[2], a * y[3]];\n  }\n};\n\nUPNG.encode.concatRGBA = function (bufs) {\n  var tlen = 0;\n\n  for (var i = 0; i < bufs.length; i++) tlen += bufs[i].byteLength;\n\n  var nimg = new Uint8Array(tlen),\n      noff = 0;\n\n  for (var i = 0; i < bufs.length; i++) {\n    var img = new Uint8Array(bufs[i]),\n        il = img.length;\n\n    for (var j = 0; j < il; j += 4) {\n      var r = img[j],\n          g = img[j + 1],\n          b = img[j + 2],\n          a = img[j + 3];\n      if (a == 0) r = g = b = 0;\n      nimg[noff + j] = r;\n      nimg[noff + j + 1] = g;\n      nimg[noff + j + 2] = b;\n      nimg[noff + j + 3] = a;\n    }\n\n    noff += il;\n  }\n\n  return nimg.buffer;\n};\n\nvar _default = UPNG;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BwZGYtbGliK3VwbmdAMS4wLjEvbm9kZV9tb2R1bGVzL0BwZGYtbGliL3VwbmcvY2pzL1VQTkcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7O0FBRWYsbUNBQW1DLG1CQUFPLENBQUMsNkVBQU07O0FBRWpELHVDQUF1Qyx1Q0FBdUM7O0FBRTlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekMsNEVBQTRFO0FBQzVFOztBQUVBLDZCQUE2QiwrRUFBK0UsMkNBQTJDLFNBQVM7QUFDaEs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFFBQVEscUNBQXFDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFxQyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0NBQXNDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBLGdCQUFnQjs7QUFFaEI7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixTQUFTOztBQUUvQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixhQUFhOztBQUVuQztBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0IsT0FBTztBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUIsTUFBTTtBQUNOLDRFQUE0RSw0REFBNEQsNkdBQTZHO0FBQ3JQLE1BQU0sOEVBQThFLHVEQUF1RDtBQUMzSSxpRkFBaUYsOEhBQThIO0FBQy9NLE1BQU07QUFDTjtBQUNBLE1BQU0sVUFBVTs7O0FBR2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLHlFQUF5RSx1RUFBdUU7O0FBRWhKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7O0FBRTVCLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixVQUFVO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7O0FBRXhDLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVMsZ0NBQWdDO0FBQ25FLGFBQWEsU0FBUzs7QUFFdEIsYUFBYSxTQUFTO0FBQ3RCLE1BQU07QUFDTixhQUFhLFNBQVM7QUFDdEIsTUFBTTtBQUNOLGFBQWEsU0FBUzs7QUFFdEIsYUFBYSxTQUFTO0FBQ3RCLE1BQU07QUFDTixhQUFhLFNBQVM7O0FBRXRCLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLEdBQUc7QUFDSDtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPLHFCQUFxQixPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7O0FBRTVCO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLFlBQVk7O0FBRVo7QUFDQSxZQUFZOztBQUVaO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLFlBQVk7O0FBRVo7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUEsa0NBQWtDLGdEQUFnRDtBQUNsRixxQ0FBcUM7O0FBRXJDLDhFQUE4RSw0Q0FBNEM7O0FBRTFILGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0IsdUNBQXVDLDZDQUE2Qzs7QUFFOUgsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBLDZEQUE2RCw0REFBNEQ7QUFDekg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFpRDs7QUFFdkQ7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBLDJCQUEyQiw0QkFBNEIsNkJBQTZCO0FBQ3BGO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLCtCQUErQixxQ0FBcUMsUUFBUSwwREFBMEQscUNBQXFDLFFBQVEsMERBQTBELHFDQUFxQyxRQUFRO0FBQzFVOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBOEQ7OztBQUdsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPLHFCQUFxQixPQUFPO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFLDREQUE0RDtBQUNyRSxNQUFNLDJCQUEyQjs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjLHFCQUFxQixhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJELElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DLG9CQUFvQixPQUFPLCtEQUErRDtBQUMxRiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUywrQkFBK0I7QUFDM0UsSUFBSTtBQUNKLG9CQUFvQixTQUFTOztBQUU3QixzQkFBc0IsU0FBUztBQUMvQixJQUFJO0FBQ0osb0JBQW9CLFNBQVM7O0FBRTdCLHFDQUFxQyxTQUFTO0FBQzlDLHFDQUFxQyxTQUFTO0FBQzlDLHFDQUFxQyxTQUFTO0FBQzlDLElBQUk7QUFDSjtBQUNBLHNCQUFzQixTQUFTO0FBQy9COztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7O0FBRS9CLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7O0FBRS9CLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0IsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsU0FBUzs7QUFFN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkMseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFROztBQUU1QixvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGtCQUFrQixrQkFBa0I7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7O0FBRW5DO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNsZWFuc2hhcmUvdWkvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BwZGYtbGliK3VwbmdAMS4wLjEvbm9kZV9tb2R1bGVzL0BwZGYtbGliL3VwbmcvY2pzL1VQTkcuanM/MzVkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9wYWtvID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGFrb1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBVUE5HID0ge307XG5cblVQTkcudG9SR0JBOCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgdmFyIHcgPSBvdXQud2lkdGgsXG4gICAgICBoID0gb3V0LmhlaWdodDtcbiAgaWYgKG91dC50YWJzLmFjVEwgPT0gbnVsbCkgcmV0dXJuIFtVUE5HLnRvUkdCQTguZGVjb2RlSW1hZ2Uob3V0LmRhdGEsIHcsIGgsIG91dCkuYnVmZmVyXTtcbiAgdmFyIGZybXMgPSBbXTtcbiAgaWYgKG91dC5mcmFtZXNbMF0uZGF0YSA9PSBudWxsKSBvdXQuZnJhbWVzWzBdLmRhdGEgPSBvdXQuZGF0YTtcbiAgdmFyIGxlbiA9IHcgKiBoICogNCxcbiAgICAgIGltZyA9IG5ldyBVaW50OEFycmF5KGxlbiksXG4gICAgICBlbXB0eSA9IG5ldyBVaW50OEFycmF5KGxlbiksXG4gICAgICBwcmV2ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5mcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZnJtID0gb3V0LmZyYW1lc1tpXTtcbiAgICB2YXIgZnggPSBmcm0ucmVjdC54LFxuICAgICAgICBmeSA9IGZybS5yZWN0LnksXG4gICAgICAgIGZ3ID0gZnJtLnJlY3Qud2lkdGgsXG4gICAgICAgIGZoID0gZnJtLnJlY3QuaGVpZ2h0O1xuICAgIHZhciBmZGF0YSA9IFVQTkcudG9SR0JBOC5kZWNvZGVJbWFnZShmcm0uZGF0YSwgZncsIGZoLCBvdXQpO1xuICAgIGlmIChpICE9IDApIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHByZXZbal0gPSBpbWdbal07XG4gICAgaWYgKGZybS5ibGVuZCA9PSAwKSBVUE5HLl9jb3B5VGlsZShmZGF0YSwgZncsIGZoLCBpbWcsIHcsIGgsIGZ4LCBmeSwgMCk7ZWxzZSBpZiAoZnJtLmJsZW5kID09IDEpIFVQTkcuX2NvcHlUaWxlKGZkYXRhLCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAxKTtcbiAgICBmcm1zLnB1c2goaW1nLmJ1ZmZlci5zbGljZSgwKSk7XG5cbiAgICBpZiAoZnJtLmRpc3Bvc2UgPT0gMCkge30gZWxzZSBpZiAoZnJtLmRpc3Bvc2UgPT0gMSkgVVBORy5fY29weVRpbGUoZW1wdHksIGZ3LCBmaCwgaW1nLCB3LCBoLCBmeCwgZnksIDApO2Vsc2UgaWYgKGZybS5kaXNwb3NlID09IDIpIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIGltZ1tqXSA9IHByZXZbal07XG4gIH1cblxuICByZXR1cm4gZnJtcztcbn07XG5cblVQTkcudG9SR0JBOC5kZWNvZGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhLCB3LCBoLCBvdXQpIHtcbiAgdmFyIGFyZWEgPSB3ICogaCxcbiAgICAgIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KTtcblxuICB2YXIgYnBsID0gTWF0aC5jZWlsKHcgKiBicHAgLyA4KTsgLy8gYnl0ZXMgcGVyIGxpbmVcblxuICB2YXIgYmYgPSBuZXcgVWludDhBcnJheShhcmVhICogNCksXG4gICAgICBiZjMyID0gbmV3IFVpbnQzMkFycmF5KGJmLmJ1ZmZlcik7XG4gIHZhciBjdHlwZSA9IG91dC5jdHlwZSxcbiAgICAgIGRlcHRoID0gb3V0LmRlcHRoO1xuICB2YXIgcnMgPSBVUE5HLl9iaW4ucmVhZFVzaG9ydDsgLy9jb25zb2xlLmxvZyhjdHlwZSwgZGVwdGgpO1xuXG4gIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuICBpZiAoY3R5cGUgPT0gNikge1xuICAgIC8vIFJHQiArIGFscGhhXG4gICAgdmFyIHFhcmVhID0gYXJlYSA8PCAyO1xuICAgIGlmIChkZXB0aCA9PSA4KSBmb3IgKHZhciBpID0gMDsgaSA8IHFhcmVhOyBpICs9IDQpIHtcbiAgICAgIGJmW2ldID0gZGF0YVtpXTtcbiAgICAgIGJmW2kgKyAxXSA9IGRhdGFbaSArIDFdO1xuICAgICAgYmZbaSArIDJdID0gZGF0YVtpICsgMl07XG4gICAgICBiZltpICsgM10gPSBkYXRhW2kgKyAzXTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID09IDE2KSBmb3IgKHZhciBpID0gMDsgaSA8IHFhcmVhOyBpKyspIHtcbiAgICAgIGJmW2ldID0gZGF0YVtpIDw8IDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjdHlwZSA9PSAyKSB7XG4gICAgLy8gUkdCXG4gICAgdmFyIHRzID0gb3V0LnRhYnNbXCJ0Uk5TXCJdO1xuXG4gICAgaWYgKHRzID09IG51bGwpIHtcbiAgICAgIGlmIChkZXB0aCA9PSA4KSBmb3IgKHZhciBpID0gMDsgaSA8IGFyZWE7IGkrKykge1xuICAgICAgICB2YXIgdGkgPSBpICogMztcbiAgICAgICAgYmYzMltpXSA9IDI1NSA8PCAyNCB8IGRhdGFbdGkgKyAyXSA8PCAxNiB8IGRhdGFbdGkgKyAxXSA8PCA4IHwgZGF0YVt0aV07XG4gICAgICB9XG4gICAgICBpZiAoZGVwdGggPT0gMTYpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJlYTsgaSsrKSB7XG4gICAgICAgIHZhciB0aSA9IGkgKiA2O1xuICAgICAgICBiZjMyW2ldID0gMjU1IDw8IDI0IHwgZGF0YVt0aSArIDRdIDw8IDE2IHwgZGF0YVt0aSArIDJdIDw8IDggfCBkYXRhW3RpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRyID0gdHNbMF0sXG4gICAgICAgICAgdGcgPSB0c1sxXSxcbiAgICAgICAgICB0YiA9IHRzWzJdO1xuICAgICAgaWYgKGRlcHRoID09IDgpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJlYTsgaSsrKSB7XG4gICAgICAgIHZhciBxaSA9IGkgPDwgMixcbiAgICAgICAgICAgIHRpID0gaSAqIDM7XG4gICAgICAgIGJmMzJbaV0gPSAyNTUgPDwgMjQgfCBkYXRhW3RpICsgMl0gPDwgMTYgfCBkYXRhW3RpICsgMV0gPDwgOCB8IGRhdGFbdGldO1xuICAgICAgICBpZiAoZGF0YVt0aV0gPT0gdHIgJiYgZGF0YVt0aSArIDFdID09IHRnICYmIGRhdGFbdGkgKyAyXSA9PSB0YikgYmZbcWkgKyAzXSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZGVwdGggPT0gMTYpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJlYTsgaSsrKSB7XG4gICAgICAgIHZhciBxaSA9IGkgPDwgMixcbiAgICAgICAgICAgIHRpID0gaSAqIDY7XG4gICAgICAgIGJmMzJbaV0gPSAyNTUgPDwgMjQgfCBkYXRhW3RpICsgNF0gPDwgMTYgfCBkYXRhW3RpICsgMl0gPDwgOCB8IGRhdGFbdGldO1xuICAgICAgICBpZiAocnMoZGF0YSwgdGkpID09IHRyICYmIHJzKGRhdGEsIHRpICsgMikgPT0gdGcgJiYgcnMoZGF0YSwgdGkgKyA0KSA9PSB0YikgYmZbcWkgKyAzXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGN0eXBlID09IDMpIHtcbiAgICAvLyBwYWxldHRlXG4gICAgdmFyIHAgPSBvdXQudGFic1tcIlBMVEVcIl0sXG4gICAgICAgIGFwID0gb3V0LnRhYnNbXCJ0Uk5TXCJdLFxuICAgICAgICB0bCA9IGFwID8gYXAubGVuZ3RoIDogMDsgLy9jb25zb2xlLmxvZyhwLCBhcCk7XG5cbiAgICBpZiAoZGVwdGggPT0gMSkgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgIHZhciBzMCA9IHkgKiBicGwsXG4gICAgICAgICAgdDAgPSB5ICogdztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgdmFyIHFpID0gdDAgKyBpIDw8IDIsXG4gICAgICAgICAgICBqID0gZGF0YVtzMCArIChpID4+IDMpXSA+PiA3IC0gKChpICYgNykgPDwgMCkgJiAxLFxuICAgICAgICAgICAgY2ogPSAzICogajtcbiAgICAgICAgYmZbcWldID0gcFtjal07XG4gICAgICAgIGJmW3FpICsgMV0gPSBwW2NqICsgMV07XG4gICAgICAgIGJmW3FpICsgMl0gPSBwW2NqICsgMl07XG4gICAgICAgIGJmW3FpICsgM10gPSBqIDwgdGwgPyBhcFtqXSA6IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlcHRoID09IDIpIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgczAgPSB5ICogYnBsLFxuICAgICAgICAgIHQwID0geSAqIHc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdzsgaSsrKSB7XG4gICAgICAgIHZhciBxaSA9IHQwICsgaSA8PCAyLFxuICAgICAgICAgICAgaiA9IGRhdGFbczAgKyAoaSA+PiAyKV0gPj4gNiAtICgoaSAmIDMpIDw8IDEpICYgMyxcbiAgICAgICAgICAgIGNqID0gMyAqIGo7XG4gICAgICAgIGJmW3FpXSA9IHBbY2pdO1xuICAgICAgICBiZltxaSArIDFdID0gcFtjaiArIDFdO1xuICAgICAgICBiZltxaSArIDJdID0gcFtjaiArIDJdO1xuICAgICAgICBiZltxaSArIDNdID0gaiA8IHRsID8gYXBbal0gOiAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZXB0aCA9PSA0KSBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgICAgdmFyIHMwID0geSAqIGJwbCxcbiAgICAgICAgICB0MCA9IHkgKiB3O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICB2YXIgcWkgPSB0MCArIGkgPDwgMixcbiAgICAgICAgICAgIGogPSBkYXRhW3MwICsgKGkgPj4gMSldID4+IDQgLSAoKGkgJiAxKSA8PCAyKSAmIDE1LFxuICAgICAgICAgICAgY2ogPSAzICogajtcbiAgICAgICAgYmZbcWldID0gcFtjal07XG4gICAgICAgIGJmW3FpICsgMV0gPSBwW2NqICsgMV07XG4gICAgICAgIGJmW3FpICsgMl0gPSBwW2NqICsgMl07XG4gICAgICAgIGJmW3FpICsgM10gPSBqIDwgdGwgPyBhcFtqXSA6IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlcHRoID09IDgpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJlYTsgaSsrKSB7XG4gICAgICB2YXIgcWkgPSBpIDw8IDIsXG4gICAgICAgICAgaiA9IGRhdGFbaV0sXG4gICAgICAgICAgY2ogPSAzICogajtcbiAgICAgIGJmW3FpXSA9IHBbY2pdO1xuICAgICAgYmZbcWkgKyAxXSA9IHBbY2ogKyAxXTtcbiAgICAgIGJmW3FpICsgMl0gPSBwW2NqICsgMl07XG4gICAgICBiZltxaSArIDNdID0gaiA8IHRsID8gYXBbal0gOiAyNTU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN0eXBlID09IDQpIHtcbiAgICAvLyBncmF5ICsgYWxwaGFcbiAgICBpZiAoZGVwdGggPT0gOCkgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmVhOyBpKyspIHtcbiAgICAgIHZhciBxaSA9IGkgPDwgMixcbiAgICAgICAgICBkaSA9IGkgPDwgMSxcbiAgICAgICAgICBnciA9IGRhdGFbZGldO1xuICAgICAgYmZbcWldID0gZ3I7XG4gICAgICBiZltxaSArIDFdID0gZ3I7XG4gICAgICBiZltxaSArIDJdID0gZ3I7XG4gICAgICBiZltxaSArIDNdID0gZGF0YVtkaSArIDFdO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPT0gMTYpIGZvciAodmFyIGkgPSAwOyBpIDwgYXJlYTsgaSsrKSB7XG4gICAgICB2YXIgcWkgPSBpIDw8IDIsXG4gICAgICAgICAgZGkgPSBpIDw8IDIsXG4gICAgICAgICAgZ3IgPSBkYXRhW2RpXTtcbiAgICAgIGJmW3FpXSA9IGdyO1xuICAgICAgYmZbcWkgKyAxXSA9IGdyO1xuICAgICAgYmZbcWkgKyAyXSA9IGdyO1xuICAgICAgYmZbcWkgKyAzXSA9IGRhdGFbZGkgKyAyXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3R5cGUgPT0gMCkge1xuICAgIC8vIGdyYXlcbiAgICB2YXIgdHIgPSBvdXQudGFic1tcInRSTlNcIl0gPyBvdXQudGFic1tcInRSTlNcIl0gOiAtMTtcblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICB2YXIgb2ZmID0geSAqIGJwbCxcbiAgICAgICAgICB0byA9IHkgKiB3O1xuICAgICAgaWYgKGRlcHRoID09IDEpIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgIHZhciBnciA9IDI1NSAqIChkYXRhW29mZiArICh4ID4+PiAzKV0gPj4+IDcgLSAoeCAmIDcpICYgMSksXG4gICAgICAgICAgICBhbCA9IGdyID09IHRyICogMjU1ID8gMCA6IDI1NTtcbiAgICAgICAgYmYzMlt0byArIHhdID0gYWwgPDwgMjQgfCBnciA8PCAxNiB8IGdyIDw8IDggfCBncjtcbiAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgdmFyIGdyID0gODUgKiAoZGF0YVtvZmYgKyAoeCA+Pj4gMildID4+PiA2IC0gKCh4ICYgMykgPDwgMSkgJiAzKSxcbiAgICAgICAgICAgIGFsID0gZ3IgPT0gdHIgKiA4NSA/IDAgOiAyNTU7XG4gICAgICAgIGJmMzJbdG8gKyB4XSA9IGFsIDw8IDI0IHwgZ3IgPDwgMTYgfCBnciA8PCA4IHwgZ3I7XG4gICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDQpIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgIHZhciBnciA9IDE3ICogKGRhdGFbb2ZmICsgKHggPj4+IDEpXSA+Pj4gNCAtICgoeCAmIDEpIDw8IDIpICYgMTUpLFxuICAgICAgICAgICAgYWwgPSBnciA9PSB0ciAqIDE3ID8gMCA6IDI1NTtcbiAgICAgICAgYmYzMlt0byArIHhdID0gYWwgPDwgMjQgfCBnciA8PCAxNiB8IGdyIDw8IDggfCBncjtcbiAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gOCkgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgdmFyIGdyID0gZGF0YVtvZmYgKyB4XSxcbiAgICAgICAgICAgIGFsID0gZ3IgPT0gdHIgPyAwIDogMjU1O1xuICAgICAgICBiZjMyW3RvICsgeF0gPSBhbCA8PCAyNCB8IGdyIDw8IDE2IHwgZ3IgPDwgOCB8IGdyO1xuICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxNikgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgdmFyIGdyID0gZGF0YVtvZmYgKyAoeCA8PCAxKV0sXG4gICAgICAgICAgICBhbCA9IHJzKGRhdGEsIG9mZiArICh4IDw8IGkpKSA9PSB0ciA/IDAgOiAyNTU7XG4gICAgICAgIGJmMzJbdG8gKyB4XSA9IGFsIDw8IDI0IHwgZ3IgPDwgMTYgfCBnciA8PCA4IHwgZ3I7XG4gICAgICB9XG4gICAgfVxuICB9IC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblxuXG4gIHJldHVybiBiZjtcbn07XG5cblVQTkcuZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmYpIHtcbiAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmKSxcbiAgICAgIG9mZnNldCA9IDgsXG4gICAgICBiaW4gPSBVUE5HLl9iaW4sXG4gICAgICByVXMgPSBiaW4ucmVhZFVzaG9ydCxcbiAgICAgIHJVaSA9IGJpbi5yZWFkVWludDtcbiAgdmFyIG91dCA9IHtcbiAgICB0YWJzOiB7fSxcbiAgICBmcmFtZXM6IFtdXG4gIH07XG4gIHZhciBkZCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKSxcbiAgICAgIGRvZmYgPSAwOyAvLyBwdXQgYWxsIElEQVQgZGF0YSBpbnRvIGl0XG5cbiAgdmFyIGZkLFxuICAgICAgZm9mZiA9IDA7IC8vIGZyYW1lc1xuXG4gIHZhciBtZ2NrID0gWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBpZiAoZGF0YVtpXSAhPSBtZ2NrW2ldKSB0aHJvdyBcIlRoZSBpbnB1dCBpcyBub3QgYSBQTkcgZmlsZSFcIjtcblxuICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGgpIHtcbiAgICB2YXIgbGVuID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdmFyIHR5cGUgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZnNldCwgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7IC8vY29uc29sZS5sb2codHlwZSxsZW4pO1xuXG4gICAgaWYgKHR5cGUgPT0gXCJJSERSXCIpIHtcbiAgICAgIFVQTkcuZGVjb2RlLl9JSERSKGRhdGEsIG9mZnNldCwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJJREFUXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGRkW2RvZmYgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaV07XG5cbiAgICAgIGRvZmYgKz0gbGVuO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImFjVExcIikge1xuICAgICAgb3V0LnRhYnNbdHlwZV0gPSB7XG4gICAgICAgIG51bV9mcmFtZXM6IHJVaShkYXRhLCBvZmZzZXQpLFxuICAgICAgICBudW1fcGxheXM6IHJVaShkYXRhLCBvZmZzZXQgKyA0KVxuICAgICAgfTtcbiAgICAgIGZkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImZjVExcIikge1xuICAgICAgaWYgKGZvZmYgIT0gMCkge1xuICAgICAgICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZyLmRhdGEgPSBVUE5HLmRlY29kZS5fZGVjb21wcmVzcyhvdXQsIGZkLnNsaWNlKDAsIGZvZmYpLCBmci5yZWN0LndpZHRoLCBmci5yZWN0LmhlaWdodCk7XG4gICAgICAgIGZvZmYgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmN0ID0ge1xuICAgICAgICB4OiByVWkoZGF0YSwgb2Zmc2V0ICsgMTIpLFxuICAgICAgICB5OiByVWkoZGF0YSwgb2Zmc2V0ICsgMTYpLFxuICAgICAgICB3aWR0aDogclVpKGRhdGEsIG9mZnNldCArIDQpLFxuICAgICAgICBoZWlnaHQ6IHJVaShkYXRhLCBvZmZzZXQgKyA4KVxuICAgICAgfTtcbiAgICAgIHZhciBkZWwgPSByVXMoZGF0YSwgb2Zmc2V0ICsgMjIpO1xuICAgICAgZGVsID0gclVzKGRhdGEsIG9mZnNldCArIDIwKSAvIChkZWwgPT0gMCA/IDEwMCA6IGRlbCk7XG4gICAgICB2YXIgZnJtID0ge1xuICAgICAgICByZWN0OiByY3QsXG4gICAgICAgIGRlbGF5OiBNYXRoLnJvdW5kKGRlbCAqIDEwMDApLFxuICAgICAgICBkaXNwb3NlOiBkYXRhW29mZnNldCArIDI0XSxcbiAgICAgICAgYmxlbmQ6IGRhdGFbb2Zmc2V0ICsgMjVdXG4gICAgICB9OyAvL2NvbnNvbGUubG9nKGZybSk7XG5cbiAgICAgIG91dC5mcmFtZXMucHVzaChmcm0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImZkQVRcIikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSA0OyBpKyspIGZkW2ZvZmYgKyBpXSA9IGRhdGFbb2Zmc2V0ICsgaSArIDRdO1xuXG4gICAgICBmb2ZmICs9IGxlbiAtIDQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwicEhZc1wiKSB7XG4gICAgICBvdXQudGFic1t0eXBlXSA9IFtiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KSwgYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCArIDQpLCBkYXRhW29mZnNldCArIDhdXTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJjSFJNXCIpIHtcbiAgICAgIG91dC50YWJzW3R5cGVdID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBvdXQudGFic1t0eXBlXS5wdXNoKGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQgKyBpICogNCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInRFWHRcIikge1xuICAgICAgaWYgKG91dC50YWJzW3R5cGVdID09IG51bGwpIG91dC50YWJzW3R5cGVdID0ge307XG4gICAgICB2YXIgbnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2Zmc2V0KTtcbiAgICAgIHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIG56IC0gb2Zmc2V0KTtcbiAgICAgIHZhciB0ZXh0ID0gYmluLnJlYWRBU0NJSShkYXRhLCBueiArIDEsIG9mZnNldCArIGxlbiAtIG56IC0gMSk7XG4gICAgICBvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiaVRYdFwiKSB7XG4gICAgICBpZiAob3V0LnRhYnNbdHlwZV0gPT0gbnVsbCkgb3V0LnRhYnNbdHlwZV0gPSB7fTtcbiAgICAgIHZhciBueiA9IDAsXG4gICAgICAgICAgb2ZmID0gb2Zmc2V0O1xuICAgICAgbnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2ZmKTtcbiAgICAgIHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmYsIG56IC0gb2ZmKTtcbiAgICAgIG9mZiA9IG56ICsgMTtcbiAgICAgIHZhciBjZmxhZyA9IGRhdGFbb2ZmXSxcbiAgICAgICAgICBjbWV0aCA9IGRhdGFbb2ZmICsgMV07XG4gICAgICBvZmYgKz0gMjtcbiAgICAgIG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZik7XG4gICAgICB2YXIgbHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2ZmLCBueiAtIG9mZik7XG4gICAgICBvZmYgPSBueiArIDE7XG4gICAgICBueiA9IGJpbi5uZXh0WmVybyhkYXRhLCBvZmYpO1xuICAgICAgdmFyIHRrZXl3ID0gYmluLnJlYWRVVEY4KGRhdGEsIG9mZiwgbnogLSBvZmYpO1xuICAgICAgb2ZmID0gbnogKyAxO1xuICAgICAgdmFyIHRleHQgPSBiaW4ucmVhZFVURjgoZGF0YSwgb2ZmLCBsZW4gLSAob2ZmIC0gb2Zmc2V0KSk7XG4gICAgICBvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiUExURVwiKSB7XG4gICAgICBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImhJU1RcIikge1xuICAgICAgdmFyIHBsID0gb3V0LnRhYnNbXCJQTFRFXCJdLmxlbmd0aCAvIDM7XG4gICAgICBvdXQudGFic1t0eXBlXSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsOyBpKyspIG91dC50YWJzW3R5cGVdLnB1c2goclVzKGRhdGEsIG9mZnNldCArIGkgKiAyKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwidFJOU1wiKSB7XG4gICAgICBpZiAob3V0LmN0eXBlID09IDMpIG91dC50YWJzW3R5cGVdID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGxlbik7ZWxzZSBpZiAob3V0LmN0eXBlID09IDApIG91dC50YWJzW3R5cGVdID0gclVzKGRhdGEsIG9mZnNldCk7ZWxzZSBpZiAob3V0LmN0eXBlID09IDIpIG91dC50YWJzW3R5cGVdID0gW3JVcyhkYXRhLCBvZmZzZXQpLCByVXMoZGF0YSwgb2Zmc2V0ICsgMiksIHJVcyhkYXRhLCBvZmZzZXQgKyA0KV07IC8vZWxzZSBjb25zb2xlLmxvZyhcInRSTlMgZm9yIHVuc3VwcG9ydGVkIGNvbG9yIHR5cGVcIixvdXQuY3R5cGUsIGxlbik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiZ0FNQVwiKSBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpIC8gMTAwMDAwO2Vsc2UgaWYgKHR5cGUgPT0gXCJzUkdCXCIpIG91dC50YWJzW3R5cGVdID0gZGF0YVtvZmZzZXRdO2Vsc2UgaWYgKHR5cGUgPT0gXCJiS0dEXCIpIHtcbiAgICAgIGlmIChvdXQuY3R5cGUgPT0gMCB8fCBvdXQuY3R5cGUgPT0gNCkgb3V0LnRhYnNbdHlwZV0gPSBbclVzKGRhdGEsIG9mZnNldCldO2Vsc2UgaWYgKG91dC5jdHlwZSA9PSAyIHx8IG91dC5jdHlwZSA9PSA2KSBvdXQudGFic1t0eXBlXSA9IFtyVXMoZGF0YSwgb2Zmc2V0KSwgclVzKGRhdGEsIG9mZnNldCArIDIpLCByVXMoZGF0YSwgb2Zmc2V0ICsgNCldO2Vsc2UgaWYgKG91dC5jdHlwZSA9PSAzKSBvdXQudGFic1t0eXBlXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJJRU5EXCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy9lbHNlIHsgIGxvZyhcInVua25vd24gY2h1bmsgdHlwZVwiLCB0eXBlLCBsZW4pOyAgfVxuXG5cbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIHZhciBjcmMgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIGlmIChmb2ZmICE9IDApIHtcbiAgICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgZnIuZGF0YSA9IFVQTkcuZGVjb2RlLl9kZWNvbXByZXNzKG91dCwgZmQuc2xpY2UoMCwgZm9mZiksIGZyLnJlY3Qud2lkdGgsIGZyLnJlY3QuaGVpZ2h0KTtcbiAgICBmb2ZmID0gMDtcbiAgfVxuXG4gIG91dC5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBkZCwgb3V0LndpZHRoLCBvdXQuaGVpZ2h0KTtcbiAgZGVsZXRlIG91dC5jb21wcmVzcztcbiAgZGVsZXRlIG91dC5pbnRlcmxhY2U7XG4gIGRlbGV0ZSBvdXQuZmlsdGVyO1xuICByZXR1cm4gb3V0O1xufTtcblxuVVBORy5kZWNvZGUuX2RlY29tcHJlc3MgPSBmdW5jdGlvbiAob3V0LCBkZCwgdywgaCkge1xuICB2YXIgdGltZSA9IERhdGUubm93KCk7XG5cbiAgdmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSxcbiAgICAgIGJwbCA9IE1hdGguY2VpbCh3ICogYnBwIC8gOCksXG4gICAgICBidWZmID0gbmV3IFVpbnQ4QXJyYXkoKGJwbCArIDEgKyBvdXQuaW50ZXJsYWNlKSAqIGgpO1xuXG4gIGRkID0gVVBORy5kZWNvZGUuX2luZmxhdGUoZGQsIGJ1ZmYpOyAvL2NvbnNvbGUubG9nKGRkLmxlbmd0aCwgYnVmZi5sZW5ndGgpO1xuICAvL2NvbnNvbGUubG9nKERhdGUubm93KCktdGltZSk7XG5cbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICBpZiAob3V0LmludGVybGFjZSA9PSAwKSBkZCA9IFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRkLCBvdXQsIDAsIHcsIGgpO2Vsc2UgaWYgKG91dC5pbnRlcmxhY2UgPT0gMSkgZGQgPSBVUE5HLmRlY29kZS5fcmVhZEludGVybGFjZShkZCwgb3V0KTsgLy9jb25zb2xlLmxvZyhEYXRlLm5vdygpLXRpbWUpO1xuXG4gIHJldHVybiBkZDtcbn07XG5cblVQTkcuZGVjb2RlLl9pbmZsYXRlID0gZnVuY3Rpb24gKGRhdGEsIGJ1ZmYpIHtcbiAgdmFyIG91dCA9IFVQTkdbXCJpbmZsYXRlUmF3XCJdKG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCAyLCBkYXRhLmxlbmd0aCAtIDYpLCBidWZmKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cblVQTkcuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSB7fTtcbiAgSC5IID0ge307XG5cbiAgSC5ILk4gPSBmdW5jdGlvbiAoTiwgVykge1xuICAgIHZhciBSID0gVWludDhBcnJheSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG0gPSAwLFxuICAgICAgICBKID0gMCxcbiAgICAgICAgaCA9IDAsXG4gICAgICAgIFEgPSAwLFxuICAgICAgICBYID0gMCxcbiAgICAgICAgdSA9IDAsXG4gICAgICAgIHcgPSAwLFxuICAgICAgICBkID0gMCxcbiAgICAgICAgdixcbiAgICAgICAgQztcbiAgICBpZiAoTlswXSA9PSAzICYmIE5bMV0gPT0gMCkgcmV0dXJuIFcgPyBXIDogbmV3IFIoMCk7XG4gICAgdmFyIFYgPSBILkgsXG4gICAgICAgIG4gPSBWLmIsXG4gICAgICAgIEEgPSBWLmUsXG4gICAgICAgIGwgPSBWLlIsXG4gICAgICAgIE0gPSBWLm4sXG4gICAgICAgIEkgPSBWLkEsXG4gICAgICAgIGUgPSBWLlosXG4gICAgICAgIGIgPSBWLm0sXG4gICAgICAgIFogPSBXID09IG51bGw7XG4gICAgaWYgKFopIFcgPSBuZXcgUihOLmxlbmd0aCA+Pj4gMiA8PCAzKTtcblxuICAgIHdoaWxlIChpID09IDApIHtcbiAgICAgIGkgPSBuKE4sIGQsIDEpO1xuICAgICAgbSA9IG4oTiwgZCArIDEsIDIpO1xuICAgICAgZCArPSAzO1xuXG4gICAgICBpZiAobSA9PSAwKSB7XG4gICAgICAgIGlmICgoZCAmIDcpICE9IDApIGQgKz0gOCAtIChkICYgNyk7XG4gICAgICAgIHZhciBEID0gKGQgPj4+IDMpICsgNCxcbiAgICAgICAgICAgIHEgPSBOW0QgLSA0XSB8IE5bRCAtIDNdIDw8IDg7XG4gICAgICAgIGlmIChaKSBXID0gSC5ILlcoVywgdyArIHEpO1xuICAgICAgICBXLnNldChuZXcgUihOLmJ1ZmZlciwgTi5ieXRlT2Zmc2V0ICsgRCwgcSksIHcpO1xuICAgICAgICBkID0gRCArIHEgPDwgMztcbiAgICAgICAgdyArPSBxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFopIFcgPSBILkguVyhXLCB3ICsgKDEgPDwgMTcpKTtcblxuICAgICAgaWYgKG0gPT0gMSkge1xuICAgICAgICB2ID0gYi5KO1xuICAgICAgICBDID0gYi5oO1xuICAgICAgICBYID0gKDEgPDwgOSkgLSAxO1xuICAgICAgICB1ID0gKDEgPDwgNSkgLSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAobSA9PSAyKSB7XG4gICAgICAgIEogPSBBKE4sIGQsIDUpICsgMjU3O1xuICAgICAgICBoID0gQShOLCBkICsgNSwgNSkgKyAxO1xuICAgICAgICBRID0gQShOLCBkICsgMTAsIDQpICsgNDtcbiAgICAgICAgZCArPSAxNDtcbiAgICAgICAgdmFyIEUgPSBkLFxuICAgICAgICAgICAgaiA9IDE7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAzODsgYyArPSAyKSB7XG4gICAgICAgICAgYi5RW2NdID0gMDtcbiAgICAgICAgICBiLlFbYyArIDFdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgUTsgYysrKSB7XG4gICAgICAgICAgdmFyIEsgPSBBKE4sIGQgKyBjICogMywgMyk7XG4gICAgICAgICAgYi5RWyhiLlhbY10gPDwgMSkgKyAxXSA9IEs7XG4gICAgICAgICAgaWYgKEsgPiBqKSBqID0gSztcbiAgICAgICAgfVxuXG4gICAgICAgIGQgKz0gMyAqIFE7XG4gICAgICAgIE0oYi5RLCBqKTtcbiAgICAgICAgSShiLlEsIGosIGIudSk7XG4gICAgICAgIHYgPSBiLnc7XG4gICAgICAgIEMgPSBiLmQ7XG4gICAgICAgIGQgPSBsKGIudSwgKDEgPDwgaikgLSAxLCBKICsgaCwgTiwgZCwgYi52KTtcbiAgICAgICAgdmFyIHIgPSBWLlYoYi52LCAwLCBKLCBiLkMpO1xuICAgICAgICBYID0gKDEgPDwgcikgLSAxO1xuICAgICAgICB2YXIgUyA9IFYuVihiLnYsIEosIGgsIGIuRCk7XG4gICAgICAgIHUgPSAoMSA8PCBTKSAtIDE7XG4gICAgICAgIE0oYi5DLCByKTtcbiAgICAgICAgSShiLkMsIHIsIHYpO1xuICAgICAgICBNKGIuRCwgUyk7XG4gICAgICAgIEkoYi5ELCBTLCBDKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCEwKSB7XG4gICAgICAgIHZhciBUID0gdltlKE4sIGQpICYgWF07XG4gICAgICAgIGQgKz0gVCAmIDE1O1xuICAgICAgICB2YXIgcCA9IFQgPj4+IDQ7XG5cbiAgICAgICAgaWYgKHAgPj4+IDggPT0gMCkge1xuICAgICAgICAgIFdbdysrXSA9IHA7XG4gICAgICAgIH0gZWxzZSBpZiAocCA9PSAyNTYpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeiA9IHcgKyBwIC0gMjU0O1xuXG4gICAgICAgICAgaWYgKHAgPiAyNjQpIHtcbiAgICAgICAgICAgIHZhciBfID0gYi5xW3AgLSAyNTddO1xuICAgICAgICAgICAgeiA9IHcgKyAoXyA+Pj4gMykgKyBBKE4sIGQsIF8gJiA3KTtcbiAgICAgICAgICAgIGQgKz0gXyAmIDc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyICQgPSBDW2UoTiwgZCkgJiB1XTtcbiAgICAgICAgICBkICs9ICQgJiAxNTtcbiAgICAgICAgICB2YXIgcyA9ICQgPj4+IDQsXG4gICAgICAgICAgICAgIFkgPSBiLmNbc10sXG4gICAgICAgICAgICAgIGEgPSAoWSA+Pj4gNCkgKyBuKE4sIGQsIFkgJiAxNSk7XG4gICAgICAgICAgZCArPSBZICYgMTU7XG5cbiAgICAgICAgICB3aGlsZSAodyA8IHopIHtcbiAgICAgICAgICAgIFdbd10gPSBXW3crKyAtIGFdO1xuICAgICAgICAgICAgV1t3XSA9IFdbdysrIC0gYV07XG4gICAgICAgICAgICBXW3ddID0gV1t3KysgLSBhXTtcbiAgICAgICAgICAgIFdbd10gPSBXW3crKyAtIGFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcgPSB6O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFcubGVuZ3RoID09IHcgPyBXIDogVy5zbGljZSgwLCB3KTtcbiAgfTtcblxuICBILkguVyA9IGZ1bmN0aW9uIChOLCBXKSB7XG4gICAgdmFyIFIgPSBOLmxlbmd0aDtcbiAgICBpZiAoVyA8PSBSKSByZXR1cm4gTjtcbiAgICB2YXIgViA9IG5ldyBVaW50OEFycmF5KFIgPDwgMSk7XG4gICAgVi5zZXQoTiwgMCk7XG4gICAgcmV0dXJuIFY7XG4gIH07XG5cbiAgSC5ILlIgPSBmdW5jdGlvbiAoTiwgVywgUiwgViwgbiwgQSkge1xuICAgIHZhciBsID0gSC5ILmUsXG4gICAgICAgIE0gPSBILkguWixcbiAgICAgICAgSSA9IDA7XG5cbiAgICB3aGlsZSAoSSA8IFIpIHtcbiAgICAgIHZhciBlID0gTltNKFYsIG4pICYgV107XG4gICAgICBuICs9IGUgJiAxNTtcbiAgICAgIHZhciBiID0gZSA+Pj4gNDtcblxuICAgICAgaWYgKGIgPD0gMTUpIHtcbiAgICAgICAgQVtJXSA9IGI7XG4gICAgICAgIEkrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBaID0gMCxcbiAgICAgICAgICAgIG0gPSAwO1xuXG4gICAgICAgIGlmIChiID09IDE2KSB7XG4gICAgICAgICAgbSA9IDMgKyBsKFYsIG4sIDIpO1xuICAgICAgICAgIG4gKz0gMjtcbiAgICAgICAgICBaID0gQVtJIC0gMV07XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PSAxNykge1xuICAgICAgICAgIG0gPSAzICsgbChWLCBuLCAzKTtcbiAgICAgICAgICBuICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PSAxOCkge1xuICAgICAgICAgIG0gPSAxMSArIGwoViwgbiwgNyk7XG4gICAgICAgICAgbiArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEogPSBJICsgbTtcblxuICAgICAgICB3aGlsZSAoSSA8IEopIHtcbiAgICAgICAgICBBW0ldID0gWjtcbiAgICAgICAgICBJKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbiAgfTtcblxuICBILkguViA9IGZ1bmN0aW9uIChOLCBXLCBSLCBWKSB7XG4gICAgdmFyIG4gPSAwLFxuICAgICAgICBBID0gMCxcbiAgICAgICAgbCA9IFYubGVuZ3RoID4+PiAxO1xuXG4gICAgd2hpbGUgKEEgPCBSKSB7XG4gICAgICB2YXIgTSA9IE5bQSArIFddO1xuICAgICAgVltBIDw8IDFdID0gMDtcbiAgICAgIFZbKEEgPDwgMSkgKyAxXSA9IE07XG4gICAgICBpZiAoTSA+IG4pIG4gPSBNO1xuICAgICAgQSsrO1xuICAgIH1cblxuICAgIHdoaWxlIChBIDwgbCkge1xuICAgICAgVltBIDw8IDFdID0gMDtcbiAgICAgIFZbKEEgPDwgMSkgKyAxXSA9IDA7XG4gICAgICBBKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH07XG5cbiAgSC5ILm4gPSBmdW5jdGlvbiAoTiwgVykge1xuICAgIHZhciBSID0gSC5ILm0sXG4gICAgICAgIFYgPSBOLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgQSxcbiAgICAgICAgbCxcbiAgICAgICAgTSxcbiAgICAgICAgSSxcbiAgICAgICAgZSA9IFIuajtcblxuICAgIGZvciAodmFyIE0gPSAwOyBNIDw9IFc7IE0rKykgZVtNXSA9IDA7XG5cbiAgICBmb3IgKE0gPSAxOyBNIDwgVjsgTSArPSAyKSBlW05bTV1dKys7XG5cbiAgICB2YXIgYiA9IFIuSztcbiAgICBuID0gMDtcbiAgICBlWzBdID0gMDtcblxuICAgIGZvciAoQSA9IDE7IEEgPD0gVzsgQSsrKSB7XG4gICAgICBuID0gbiArIGVbQSAtIDFdIDw8IDE7XG4gICAgICBiW0FdID0gbjtcbiAgICB9XG5cbiAgICBmb3IgKGwgPSAwOyBsIDwgVjsgbCArPSAyKSB7XG4gICAgICBJID0gTltsICsgMV07XG5cbiAgICAgIGlmIChJICE9IDApIHtcbiAgICAgICAgTltsXSA9IGJbSV07XG4gICAgICAgIGJbSV0rKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSC5ILkEgPSBmdW5jdGlvbiAoTiwgVywgUikge1xuICAgIHZhciBWID0gTi5sZW5ndGgsXG4gICAgICAgIG4gPSBILkgubSxcbiAgICAgICAgQSA9IG4ucjtcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgVjsgbCArPSAyKSBpZiAoTltsICsgMV0gIT0gMCkge1xuICAgICAgdmFyIE0gPSBsID4+IDEsXG4gICAgICAgICAgSSA9IE5bbCArIDFdLFxuICAgICAgICAgIGUgPSBNIDw8IDQgfCBJLFxuICAgICAgICAgIGIgPSBXIC0gSSxcbiAgICAgICAgICBaID0gTltsXSA8PCBiLFxuICAgICAgICAgIG0gPSBaICsgKDEgPDwgYik7XG5cbiAgICAgIHdoaWxlIChaICE9IG0pIHtcbiAgICAgICAgdmFyIEogPSBBW1pdID4+PiAxNSAtIFc7XG4gICAgICAgIFJbSl0gPSBlO1xuICAgICAgICBaKys7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEguSC5sID0gZnVuY3Rpb24gKE4sIFcpIHtcbiAgICB2YXIgUiA9IEguSC5tLnIsXG4gICAgICAgIFYgPSAxNSAtIFc7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IE4ubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgIHZhciBBID0gTltuXSA8PCBXIC0gTltuICsgMV07XG4gICAgICBOW25dID0gUltBXSA+Pj4gVjtcbiAgICB9XG4gIH07XG5cbiAgSC5ILk0gPSBmdW5jdGlvbiAoTiwgVywgUikge1xuICAgIFIgPSBSIDw8IChXICYgNyk7XG4gICAgdmFyIFYgPSBXID4+PiAzO1xuICAgIE5bVl0gfD0gUjtcbiAgICBOW1YgKyAxXSB8PSBSID4+PiA4O1xuICB9O1xuXG4gIEguSC5JID0gZnVuY3Rpb24gKE4sIFcsIFIpIHtcbiAgICBSID0gUiA8PCAoVyAmIDcpO1xuICAgIHZhciBWID0gVyA+Pj4gMztcbiAgICBOW1ZdIHw9IFI7XG4gICAgTltWICsgMV0gfD0gUiA+Pj4gODtcbiAgICBOW1YgKyAyXSB8PSBSID4+PiAxNjtcbiAgfTtcblxuICBILkguZSA9IGZ1bmN0aW9uIChOLCBXLCBSKSB7XG4gICAgcmV0dXJuIChOW1cgPj4+IDNdIHwgTlsoVyA+Pj4gMykgKyAxXSA8PCA4KSA+Pj4gKFcgJiA3KSAmICgxIDw8IFIpIC0gMTtcbiAgfTtcblxuICBILkguYiA9IGZ1bmN0aW9uIChOLCBXLCBSKSB7XG4gICAgcmV0dXJuIChOW1cgPj4+IDNdIHwgTlsoVyA+Pj4gMykgKyAxXSA8PCA4IHwgTlsoVyA+Pj4gMykgKyAyXSA8PCAxNikgPj4+IChXICYgNykgJiAoMSA8PCBSKSAtIDE7XG4gIH07XG5cbiAgSC5ILlogPSBmdW5jdGlvbiAoTiwgVykge1xuICAgIHJldHVybiAoTltXID4+PiAzXSB8IE5bKFcgPj4+IDMpICsgMV0gPDwgOCB8IE5bKFcgPj4+IDMpICsgMl0gPDwgMTYpID4+PiAoVyAmIDcpO1xuICB9O1xuXG4gIEguSC5pID0gZnVuY3Rpb24gKE4sIFcpIHtcbiAgICByZXR1cm4gKE5bVyA+Pj4gM10gfCBOWyhXID4+PiAzKSArIDFdIDw8IDggfCBOWyhXID4+PiAzKSArIDJdIDw8IDE2IHwgTlsoVyA+Pj4gMykgKyAzXSA8PCAyNCkgPj4+IChXICYgNyk7XG4gIH07XG5cbiAgSC5ILm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE4gPSBVaW50MTZBcnJheSxcbiAgICAgICAgVyA9IFVpbnQzMkFycmF5O1xuICAgIHJldHVybiB7XG4gICAgICBLOiBuZXcgTigxNiksXG4gICAgICBqOiBuZXcgTigxNiksXG4gICAgICBYOiBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0sXG4gICAgICBTOiBbMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSwgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDk5OSwgOTk5LCA5OTldLFxuICAgICAgVDogWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDAsIDAsIDBdLFxuICAgICAgcTogbmV3IE4oMzIpLFxuICAgICAgcDogWzEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MywgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LCA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCA2NTUzNSwgNjU1MzVdLFxuICAgICAgejogWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgMCwgMF0sXG4gICAgICBjOiBuZXcgVygzMiksXG4gICAgICBKOiBuZXcgTig1MTIpLFxuICAgICAgXzogW10sXG4gICAgICBoOiBuZXcgTigzMiksXG4gICAgICAkOiBbXSxcbiAgICAgIHc6IG5ldyBOKDMyNzY4KSxcbiAgICAgIEM6IFtdLFxuICAgICAgdjogW10sXG4gICAgICBkOiBuZXcgTigzMjc2OCksXG4gICAgICBEOiBbXSxcbiAgICAgIHU6IG5ldyBOKDUxMiksXG4gICAgICBROiBbXSxcbiAgICAgIHI6IG5ldyBOKDEgPDwgMTUpLFxuICAgICAgczogbmV3IFcoMjg2KSxcbiAgICAgIFk6IG5ldyBXKDMwKSxcbiAgICAgIGE6IG5ldyBXKDE5KSxcbiAgICAgIHQ6IG5ldyBXKDE1ZTMpLFxuICAgICAgazogbmV3IE4oMSA8PCAxNiksXG4gICAgICBnOiBuZXcgTigxIDw8IDE1KVxuICAgIH07XG4gIH0oKTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBOID0gSC5ILm0sXG4gICAgICAgIFcgPSAxIDw8IDE1O1xuXG4gICAgZm9yICh2YXIgUiA9IDA7IFIgPCBXOyBSKyspIHtcbiAgICAgIHZhciBWID0gUjtcbiAgICAgIFYgPSAoViAmIDI4NjMzMTE1MzApID4+PiAxIHwgKFYgJiAxNDMxNjU1NzY1KSA8PCAxO1xuICAgICAgViA9IChWICYgMzQzNTk3MzgzNikgPj4+IDIgfCAoViAmIDg1ODk5MzQ1OSkgPDwgMjtcbiAgICAgIFYgPSAoViAmIDQwNDIzMjIxNjApID4+PiA0IHwgKFYgJiAyNTI2NDUxMzUpIDw8IDQ7XG4gICAgICBWID0gKFYgJiA0Mjc4MjU1MzYwKSA+Pj4gOCB8IChWICYgMTY3MTE5MzUpIDw8IDg7XG4gICAgICBOLnJbUl0gPSAoViA+Pj4gMTYgfCBWIDw8IDE2KSA+Pj4gMTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbihBLCBsLCBNKSB7XG4gICAgICB3aGlsZSAobC0tICE9IDApIEEucHVzaCgwLCBNKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBSID0gMDsgUiA8IDMyOyBSKyspIHtcbiAgICAgIE4ucVtSXSA9IE4uU1tSXSA8PCAzIHwgTi5UW1JdO1xuICAgICAgTi5jW1JdID0gTi5wW1JdIDw8IDQgfCBOLnpbUl07XG4gICAgfVxuXG4gICAgbihOLl8sIDE0NCwgOCk7XG4gICAgbihOLl8sIDI1NSAtIDE0MywgOSk7XG4gICAgbihOLl8sIDI3OSAtIDI1NSwgNyk7XG4gICAgbihOLl8sIDI4NyAtIDI3OSwgOCk7XG4gICAgSC5ILm4oTi5fLCA5KTtcbiAgICBILkguQShOLl8sIDksIE4uSik7XG4gICAgSC5ILmwoTi5fLCA5KTtcbiAgICBuKE4uJCwgMzIsIDUpO1xuICAgIEguSC5uKE4uJCwgNSk7XG4gICAgSC5ILkEoTi4kLCA1LCBOLmgpO1xuICAgIEguSC5sKE4uJCwgNSk7XG4gICAgbihOLlEsIDE5LCAwKTtcbiAgICBuKE4uQywgMjg2LCAwKTtcbiAgICBuKE4uRCwgMzAsIDApO1xuICAgIG4oTi52LCAzMjAsIDApO1xuICB9KSgpO1xuXG4gIHJldHVybiBILkguTjtcbn0oKTtcblxuVVBORy5kZWNvZGUuX3JlYWRJbnRlcmxhY2UgPSBmdW5jdGlvbiAoZGF0YSwgb3V0KSB7XG4gIHZhciB3ID0gb3V0LndpZHRoLFxuICAgICAgaCA9IG91dC5oZWlnaHQ7XG5cbiAgdmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSxcbiAgICAgIGNicHAgPSBicHAgPj4gMyxcbiAgICAgIGJwbCA9IE1hdGguY2VpbCh3ICogYnBwIC8gOCk7XG5cbiAgdmFyIGltZyA9IG5ldyBVaW50OEFycmF5KGggKiBicGwpO1xuICB2YXIgZGkgPSAwO1xuICB2YXIgc3RhcnRpbmdfcm93ID0gWzAsIDAsIDQsIDAsIDIsIDAsIDFdO1xuICB2YXIgc3RhcnRpbmdfY29sID0gWzAsIDQsIDAsIDIsIDAsIDEsIDBdO1xuICB2YXIgcm93X2luY3JlbWVudCA9IFs4LCA4LCA4LCA0LCA0LCAyLCAyXTtcbiAgdmFyIGNvbF9pbmNyZW1lbnQgPSBbOCwgOCwgNCwgNCwgMiwgMiwgMV07XG4gIHZhciBwYXNzID0gMDtcblxuICB3aGlsZSAocGFzcyA8IDcpIHtcbiAgICB2YXIgcmkgPSByb3dfaW5jcmVtZW50W3Bhc3NdLFxuICAgICAgICBjaSA9IGNvbF9pbmNyZW1lbnRbcGFzc107XG4gICAgdmFyIHN3ID0gMCxcbiAgICAgICAgc2ggPSAwO1xuICAgIHZhciBjciA9IHN0YXJ0aW5nX3Jvd1twYXNzXTtcblxuICAgIHdoaWxlIChjciA8IGgpIHtcbiAgICAgIGNyICs9IHJpO1xuICAgICAgc2grKztcbiAgICB9XG5cbiAgICB2YXIgY2MgPSBzdGFydGluZ19jb2xbcGFzc107XG5cbiAgICB3aGlsZSAoY2MgPCB3KSB7XG4gICAgICBjYyArPSBjaTtcbiAgICAgIHN3Kys7XG4gICAgfVxuXG4gICAgdmFyIGJwbGwgPSBNYXRoLmNlaWwoc3cgKiBicHAgLyA4KTtcblxuICAgIFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRhdGEsIG91dCwgZGksIHN3LCBzaCk7XG5cbiAgICB2YXIgeSA9IDAsXG4gICAgICAgIHJvdyA9IHN0YXJ0aW5nX3Jvd1twYXNzXTtcblxuICAgIHdoaWxlIChyb3cgPCBoKSB7XG4gICAgICB2YXIgY29sID0gc3RhcnRpbmdfY29sW3Bhc3NdO1xuICAgICAgdmFyIGNkaSA9IGRpICsgeSAqIGJwbGwgPDwgMztcblxuICAgICAgd2hpbGUgKGNvbCA8IHcpIHtcbiAgICAgICAgaWYgKGJwcCA9PSAxKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFbY2RpID4+IDNdO1xuICAgICAgICAgIHZhbCA9IHZhbCA+PiA3IC0gKGNkaSAmIDcpICYgMTtcbiAgICAgICAgICBpbWdbcm93ICogYnBsICsgKGNvbCA+PiAzKV0gfD0gdmFsIDw8IDcgLSAoKGNvbCAmIDcpIDw8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJwcCA9PSAyKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFbY2RpID4+IDNdO1xuICAgICAgICAgIHZhbCA9IHZhbCA+PiA2IC0gKGNkaSAmIDcpICYgMztcbiAgICAgICAgICBpbWdbcm93ICogYnBsICsgKGNvbCA+PiAyKV0gfD0gdmFsIDw8IDYgLSAoKGNvbCAmIDMpIDw8IDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJwcCA9PSA0KSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFbY2RpID4+IDNdO1xuICAgICAgICAgIHZhbCA9IHZhbCA+PiA0IC0gKGNkaSAmIDcpICYgMTU7XG4gICAgICAgICAgaW1nW3JvdyAqIGJwbCArIChjb2wgPj4gMSldIHw9IHZhbCA8PCA0IC0gKChjb2wgJiAxKSA8PCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicHAgPj0gOCkge1xuICAgICAgICAgIHZhciBpaSA9IHJvdyAqIGJwbCArIGNvbCAqIGNicHA7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNicHA7IGorKykgaW1nW2lpICsgal0gPSBkYXRhWyhjZGkgPj4gMykgKyBqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNkaSArPSBicHA7XG4gICAgICAgIGNvbCArPSBjaTtcbiAgICAgIH1cblxuICAgICAgeSsrO1xuICAgICAgcm93ICs9IHJpO1xuICAgIH1cblxuICAgIGlmIChzdyAqIHNoICE9IDApIGRpICs9IHNoICogKDEgKyBicGxsKTtcbiAgICBwYXNzID0gcGFzcyArIDE7XG4gIH1cblxuICByZXR1cm4gaW1nO1xufTtcblxuVVBORy5kZWNvZGUuX2dldEJQUCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgdmFyIG5vYyA9IFsxLCBudWxsLCAzLCAxLCAyLCBudWxsLCA0XVtvdXQuY3R5cGVdO1xuICByZXR1cm4gbm9jICogb3V0LmRlcHRoO1xufTtcblxuVVBORy5kZWNvZGUuX2ZpbHRlclplcm8gPSBmdW5jdGlvbiAoZGF0YSwgb3V0LCBvZmYsIHcsIGgpIHtcbiAgdmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSxcbiAgICAgIGJwbCA9IE1hdGguY2VpbCh3ICogYnBwIC8gOCksXG4gICAgICBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aDtcblxuICBicHAgPSBNYXRoLmNlaWwoYnBwIC8gOCk7XG4gIHZhciBpID0gMCxcbiAgICAgIGRpID0gMSxcbiAgICAgIHR5cGUgPSBkYXRhW29mZl0sXG4gICAgICB4ID0gMDtcbiAgaWYgKHR5cGUgPiAxKSBkYXRhW29mZl0gPSBbMCwgMCwgMV1bdHlwZSAtIDJdO1xuICBpZiAodHlwZSA9PSAzKSBmb3IgKHggPSBicHA7IHggPCBicGw7IHgrKykgZGF0YVt4ICsgMV0gPSBkYXRhW3ggKyAxXSArIChkYXRhW3ggKyAxIC0gYnBwXSA+Pj4gMSkgJiAyNTU7XG5cbiAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICBpID0gb2ZmICsgeSAqIGJwbDtcbiAgICBkaSA9IGkgKyB5ICsgMTtcbiAgICB0eXBlID0gZGF0YVtkaSAtIDFdO1xuICAgIHggPSAwO1xuICAgIGlmICh0eXBlID09IDApIGZvciAoOyB4IDwgYnBsOyB4KyspIGRhdGFbaSArIHhdID0gZGF0YVtkaSArIHhdO2Vsc2UgaWYgKHR5cGUgPT0gMSkge1xuICAgICAgZm9yICg7IHggPCBicHA7IHgrKykgZGF0YVtpICsgeF0gPSBkYXRhW2RpICsgeF07XG5cbiAgICAgIGZvciAoOyB4IDwgYnBsOyB4KyspIGRhdGFbaSArIHhdID0gZGF0YVtkaSArIHhdICsgZGF0YVtpICsgeCAtIGJwcF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09IDIpIHtcbiAgICAgIGZvciAoOyB4IDwgYnBsOyB4KyspIGRhdGFbaSArIHhdID0gZGF0YVtkaSArIHhdICsgZGF0YVtpICsgeCAtIGJwbF07XG4gICAgfSBlbHNlIGlmICh0eXBlID09IDMpIHtcbiAgICAgIGZvciAoOyB4IDwgYnBwOyB4KyspIGRhdGFbaSArIHhdID0gZGF0YVtkaSArIHhdICsgKGRhdGFbaSArIHggLSBicGxdID4+PiAxKTtcblxuICAgICAgZm9yICg7IHggPCBicGw7IHgrKykgZGF0YVtpICsgeF0gPSBkYXRhW2RpICsgeF0gKyAoZGF0YVtpICsgeCAtIGJwbF0gKyBkYXRhW2kgKyB4IC0gYnBwXSA+Pj4gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoOyB4IDwgYnBwOyB4KyspIGRhdGFbaSArIHhdID0gZGF0YVtkaSArIHhdICsgcGFldGgoMCwgZGF0YVtpICsgeCAtIGJwbF0sIDApO1xuXG4gICAgICBmb3IgKDsgeCA8IGJwbDsgeCsrKSBkYXRhW2kgKyB4XSA9IGRhdGFbZGkgKyB4XSArIHBhZXRoKGRhdGFbaSArIHggLSBicHBdLCBkYXRhW2kgKyB4IC0gYnBsXSwgZGF0YVtpICsgeCAtIGJwcCAtIGJwbF0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuVVBORy5kZWNvZGUuX3BhZXRoID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBhICsgYiAtIGMsXG4gICAgICBwYSA9IHAgLSBhLFxuICAgICAgcGIgPSBwIC0gYixcbiAgICAgIHBjID0gcCAtIGM7XG4gIGlmIChwYSAqIHBhIDw9IHBiICogcGIgJiYgcGEgKiBwYSA8PSBwYyAqIHBjKSByZXR1cm4gYTtlbHNlIGlmIChwYiAqIHBiIDw9IHBjICogcGMpIHJldHVybiBiO1xuICByZXR1cm4gYztcbn07XG5cblVQTkcuZGVjb2RlLl9JSERSID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCwgb3V0KSB7XG4gIHZhciBiaW4gPSBVUE5HLl9iaW47XG4gIG91dC53aWR0aCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgb3V0LmhlaWdodCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgb3V0LmRlcHRoID0gZGF0YVtvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgb3V0LmN0eXBlID0gZGF0YVtvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgb3V0LmNvbXByZXNzID0gZGF0YVtvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgb3V0LmZpbHRlciA9IGRhdGFbb2Zmc2V0XTtcbiAgb2Zmc2V0Kys7XG4gIG91dC5pbnRlcmxhY2UgPSBkYXRhW29mZnNldF07XG4gIG9mZnNldCsrO1xufTtcblxuVVBORy5fYmluID0ge1xuICBuZXh0WmVybzogZnVuY3Rpb24gKGRhdGEsIHApIHtcbiAgICB3aGlsZSAoZGF0YVtwXSAhPSAwKSBwKys7XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgcmVhZFVzaG9ydDogZnVuY3Rpb24gKGJ1ZmYsIHApIHtcbiAgICByZXR1cm4gYnVmZltwXSA8PCA4IHwgYnVmZltwICsgMV07XG4gIH0sXG4gIHdyaXRlVXNob3J0OiBmdW5jdGlvbiAoYnVmZiwgcCwgbikge1xuICAgIGJ1ZmZbcF0gPSBuID4+IDggJiAyNTU7XG4gICAgYnVmZltwICsgMV0gPSBuICYgMjU1O1xuICB9LFxuICByZWFkVWludDogZnVuY3Rpb24gKGJ1ZmYsIHApIHtcbiAgICByZXR1cm4gYnVmZltwXSAqICgyNTYgKiAyNTYgKiAyNTYpICsgKGJ1ZmZbcCArIDFdIDw8IDE2IHwgYnVmZltwICsgMl0gPDwgOCB8IGJ1ZmZbcCArIDNdKTtcbiAgfSxcbiAgd3JpdGVVaW50OiBmdW5jdGlvbiAoYnVmZiwgcCwgbikge1xuICAgIGJ1ZmZbcF0gPSBuID4+IDI0ICYgMjU1O1xuICAgIGJ1ZmZbcCArIDFdID0gbiA+PiAxNiAmIDI1NTtcbiAgICBidWZmW3AgKyAyXSA9IG4gPj4gOCAmIDI1NTtcbiAgICBidWZmW3AgKyAzXSA9IG4gJiAyNTU7XG4gIH0sXG4gIHJlYWRBU0NJSTogZnVuY3Rpb24gKGJ1ZmYsIHAsIGwpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCArIGldKTtcblxuICAgIHJldHVybiBzO1xuICB9LFxuICB3cml0ZUFTQ0lJOiBmdW5jdGlvbiAoZGF0YSwgcCwgcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgZGF0YVtwICsgaV0gPSBzLmNoYXJDb2RlQXQoaSk7XG4gIH0sXG4gIHJlYWRCeXRlczogZnVuY3Rpb24gKGJ1ZmYsIHAsIGwpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYXJyLnB1c2goYnVmZltwICsgaV0pO1xuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcGFkOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmxlbmd0aCA8IDIgPyBcIjBcIiArIG4gOiBuO1xuICB9LFxuICByZWFkVVRGODogZnVuY3Rpb24gKGJ1ZmYsIHAsIGwpIHtcbiAgICB2YXIgcyA9IFwiXCIsXG4gICAgICAgIG5zO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHMgKz0gXCIlXCIgKyBVUE5HLl9iaW4ucGFkKGJ1ZmZbcCArIGldLnRvU3RyaW5nKDE2KSk7XG5cbiAgICB0cnkge1xuICAgICAgbnMgPSBkZWNvZGVVUklDb21wb25lbnQocyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIFVQTkcuX2Jpbi5yZWFkQVNDSUkoYnVmZiwgcCwgbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5zO1xuICB9XG59O1xuXG5VUE5HLl9jb3B5VGlsZSA9IGZ1bmN0aW9uIChzYiwgc3csIHNoLCB0YiwgdHcsIHRoLCB4b2ZmLCB5b2ZmLCBtb2RlKSB7XG4gIHZhciB3ID0gTWF0aC5taW4oc3csIHR3KSxcbiAgICAgIGggPSBNYXRoLm1pbihzaCwgdGgpO1xuICB2YXIgc2kgPSAwLFxuICAgICAgdGkgPSAwO1xuXG4gIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKykge1xuICAgIGlmICh4b2ZmID49IDAgJiYgeW9mZiA+PSAwKSB7XG4gICAgICBzaSA9IHkgKiBzdyArIHggPDwgMjtcbiAgICAgIHRpID0gKHlvZmYgKyB5KSAqIHR3ICsgeG9mZiArIHggPDwgMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2kgPSAoLXlvZmYgKyB5KSAqIHN3IC0geG9mZiArIHggPDwgMjtcbiAgICAgIHRpID0geSAqIHR3ICsgeCA8PCAyO1xuICAgIH1cblxuICAgIGlmIChtb2RlID09IDApIHtcbiAgICAgIHRiW3RpXSA9IHNiW3NpXTtcbiAgICAgIHRiW3RpICsgMV0gPSBzYltzaSArIDFdO1xuICAgICAgdGJbdGkgKyAyXSA9IHNiW3NpICsgMl07XG4gICAgICB0Ylt0aSArIDNdID0gc2Jbc2kgKyAzXTtcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT0gMSkge1xuICAgICAgdmFyIGZhID0gc2Jbc2kgKyAzXSAqICgxIC8gMjU1KSxcbiAgICAgICAgICBmciA9IHNiW3NpXSAqIGZhLFxuICAgICAgICAgIGZnID0gc2Jbc2kgKyAxXSAqIGZhLFxuICAgICAgICAgIGZiID0gc2Jbc2kgKyAyXSAqIGZhO1xuICAgICAgdmFyIGJhID0gdGJbdGkgKyAzXSAqICgxIC8gMjU1KSxcbiAgICAgICAgICBiciA9IHRiW3RpXSAqIGJhLFxuICAgICAgICAgIGJnID0gdGJbdGkgKyAxXSAqIGJhLFxuICAgICAgICAgIGJiID0gdGJbdGkgKyAyXSAqIGJhO1xuICAgICAgdmFyIGlmYSA9IDEgLSBmYSxcbiAgICAgICAgICBvYSA9IGZhICsgYmEgKiBpZmEsXG4gICAgICAgICAgaW9hID0gb2EgPT0gMCA/IDAgOiAxIC8gb2E7XG4gICAgICB0Ylt0aSArIDNdID0gMjU1ICogb2E7XG4gICAgICB0Ylt0aSArIDBdID0gKGZyICsgYnIgKiBpZmEpICogaW9hO1xuICAgICAgdGJbdGkgKyAxXSA9IChmZyArIGJnICogaWZhKSAqIGlvYTtcbiAgICAgIHRiW3RpICsgMl0gPSAoZmIgKyBiYiAqIGlmYSkgKiBpb2E7XG4gICAgfSBlbHNlIGlmIChtb2RlID09IDIpIHtcbiAgICAgIC8vIGNvcHkgb25seSBkaWZmZXJlbmNlcywgb3RoZXJ3aXNlIHplcm9cbiAgICAgIHZhciBmYSA9IHNiW3NpICsgM10sXG4gICAgICAgICAgZnIgPSBzYltzaV0sXG4gICAgICAgICAgZmcgPSBzYltzaSArIDFdLFxuICAgICAgICAgIGZiID0gc2Jbc2kgKyAyXTtcbiAgICAgIHZhciBiYSA9IHRiW3RpICsgM10sXG4gICAgICAgICAgYnIgPSB0Ylt0aV0sXG4gICAgICAgICAgYmcgPSB0Ylt0aSArIDFdLFxuICAgICAgICAgIGJiID0gdGJbdGkgKyAyXTtcblxuICAgICAgaWYgKGZhID09IGJhICYmIGZyID09IGJyICYmIGZnID09IGJnICYmIGZiID09IGJiKSB7XG4gICAgICAgIHRiW3RpXSA9IDA7XG4gICAgICAgIHRiW3RpICsgMV0gPSAwO1xuICAgICAgICB0Ylt0aSArIDJdID0gMDtcbiAgICAgICAgdGJbdGkgKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0Ylt0aV0gPSBmcjtcbiAgICAgICAgdGJbdGkgKyAxXSA9IGZnO1xuICAgICAgICB0Ylt0aSArIDJdID0gZmI7XG4gICAgICAgIHRiW3RpICsgM10gPSBmYTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1vZGUgPT0gMykge1xuICAgICAgLy8gY2hlY2sgaWYgY2FuIGJlIGJsZW5kZWRcbiAgICAgIHZhciBmYSA9IHNiW3NpICsgM10sXG4gICAgICAgICAgZnIgPSBzYltzaV0sXG4gICAgICAgICAgZmcgPSBzYltzaSArIDFdLFxuICAgICAgICAgIGZiID0gc2Jbc2kgKyAyXTtcbiAgICAgIHZhciBiYSA9IHRiW3RpICsgM10sXG4gICAgICAgICAgYnIgPSB0Ylt0aV0sXG4gICAgICAgICAgYmcgPSB0Ylt0aSArIDFdLFxuICAgICAgICAgIGJiID0gdGJbdGkgKyAyXTtcbiAgICAgIGlmIChmYSA9PSBiYSAmJiBmciA9PSBiciAmJiBmZyA9PSBiZyAmJiBmYiA9PSBiYikgY29udGludWU7IC8vaWYoZmEhPTI1NSAmJiBiYSE9MCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoZmEgPCAyMjAgJiYgYmEgPiAyMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuVVBORy5lbmNvZGUgPSBmdW5jdGlvbiAoYnVmcywgdywgaCwgcHMsIGRlbHMsIHRhYnMsIGZvcmJpZFBsdGUpIHtcbiAgaWYgKHBzID09IG51bGwpIHBzID0gMDtcbiAgaWYgKGZvcmJpZFBsdGUgPT0gbnVsbCkgZm9yYmlkUGx0ZSA9IGZhbHNlO1xuICB2YXIgbmltZyA9IFVQTkcuZW5jb2RlLmNvbXByZXNzKGJ1ZnMsIHcsIGgsIHBzLCBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgZm9yYmlkUGx0ZV0pO1xuICBVUE5HLmVuY29kZS5jb21wcmVzc1BORyhuaW1nLCAtMSk7XG4gIHJldHVybiBVUE5HLmVuY29kZS5fbWFpbihuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKTtcbn07XG5cblVQTkcuZW5jb2RlTEwgPSBmdW5jdGlvbiAoYnVmcywgdywgaCwgY2MsIGFjLCBkZXB0aCwgZGVscywgdGFicykge1xuICB2YXIgbmltZyA9IHtcbiAgICBjdHlwZTogMCArIChjYyA9PSAxID8gMCA6IDIpICsgKGFjID09IDAgPyAwIDogNCksXG4gICAgZGVwdGg6IGRlcHRoLFxuICAgIGZyYW1lczogW11cbiAgfTtcbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuICB2YXIgYmlwcCA9IChjYyArIGFjKSAqIGRlcHRoLFxuICAgICAgYmlwbCA9IGJpcHAgKiB3O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKykgbmltZy5mcmFtZXMucHVzaCh7XG4gICAgcmVjdDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogdyxcbiAgICAgIGhlaWdodDogaFxuICAgIH0sXG4gICAgaW1nOiBuZXcgVWludDhBcnJheShidWZzW2ldKSxcbiAgICBibGVuZDogMCxcbiAgICBkaXNwb3NlOiAxLFxuICAgIGJwcDogTWF0aC5jZWlsKGJpcHAgLyA4KSxcbiAgICBicGw6IE1hdGguY2VpbChiaXBsIC8gOClcbiAgfSk7XG5cbiAgVVBORy5lbmNvZGUuY29tcHJlc3NQTkcobmltZywgMCwgdHJ1ZSk7XG5cbiAgdmFyIG91dCA9IFVQTkcuZW5jb2RlLl9tYWluKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5VUE5HLmVuY29kZS5fbWFpbiA9IGZ1bmN0aW9uIChuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKSB7XG4gIGlmICh0YWJzID09IG51bGwpIHRhYnMgPSB7fTtcbiAgdmFyIGNyYyA9IFVQTkcuY3JjLmNyYyxcbiAgICAgIHdVaSA9IFVQTkcuX2Jpbi53cml0ZVVpbnQsXG4gICAgICB3VXMgPSBVUE5HLl9iaW4ud3JpdGVVc2hvcnQsXG4gICAgICB3QXMgPSBVUE5HLl9iaW4ud3JpdGVBU0NJSTtcbiAgdmFyIG9mZnNldCA9IDgsXG4gICAgICBhbmltID0gbmltZy5mcmFtZXMubGVuZ3RoID4gMSxcbiAgICAgIHBsdEFscGhhID0gZmFsc2U7XG4gIHZhciBsZW5nID0gOCArICgxNiArIDUgKyA0KVxuICAvKisgKDkrNCkqL1xuICArIChhbmltID8gMjAgOiAwKTtcbiAgaWYgKHRhYnNbXCJzUkdCXCJdICE9IG51bGwpIGxlbmcgKz0gOCArIDEgKyA0O1xuICBpZiAodGFic1tcInBIWXNcIl0gIT0gbnVsbCkgbGVuZyArPSA4ICsgOSArIDQ7XG5cbiAgaWYgKG5pbWcuY3R5cGUgPT0gMykge1xuICAgIHZhciBkbCA9IG5pbWcucGx0ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRsOyBpKyspIGlmIChuaW1nLnBsdGVbaV0gPj4+IDI0ICE9IDI1NSkgcGx0QWxwaGEgPSB0cnVlO1xuXG4gICAgbGVuZyArPSA4ICsgZGwgKiAzICsgNCArIChwbHRBbHBoYSA/IDggKyBkbCAqIDEgKyA0IDogMCk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IG5pbWcuZnJhbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGZyID0gbmltZy5mcmFtZXNbal07XG4gICAgaWYgKGFuaW0pIGxlbmcgKz0gMzg7XG4gICAgbGVuZyArPSBmci5jaW1nLmxlbmd0aCArIDEyO1xuICAgIGlmIChqICE9IDApIGxlbmcgKz0gNDtcbiAgfVxuXG4gIGxlbmcgKz0gMTI7XG4gIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZyk7XG4gIHZhciB3ciA9IFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgZGF0YVtpXSA9IHdyW2ldO1xuXG4gIHdVaShkYXRhLCBvZmZzZXQsIDEzKTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHdBcyhkYXRhLCBvZmZzZXQsIFwiSUhEUlwiKTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHdVaShkYXRhLCBvZmZzZXQsIHcpO1xuICBvZmZzZXQgKz0gNDtcbiAgd1VpKGRhdGEsIG9mZnNldCwgaCk7XG4gIG9mZnNldCArPSA0O1xuICBkYXRhW29mZnNldF0gPSBuaW1nLmRlcHRoO1xuICBvZmZzZXQrKzsgLy8gZGVwdGhcblxuICBkYXRhW29mZnNldF0gPSBuaW1nLmN0eXBlO1xuICBvZmZzZXQrKzsgLy8gY3R5cGVcblxuICBkYXRhW29mZnNldF0gPSAwO1xuICBvZmZzZXQrKzsgLy8gY29tcHJlc3NcblxuICBkYXRhW29mZnNldF0gPSAwO1xuICBvZmZzZXQrKzsgLy8gZmlsdGVyXG5cbiAgZGF0YVtvZmZzZXRdID0gMDtcbiAgb2Zmc2V0Kys7IC8vIGludGVybGFjZVxuXG4gIHdVaShkYXRhLCBvZmZzZXQsIGNyYyhkYXRhLCBvZmZzZXQgLSAxNywgMTcpKTtcbiAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICAvLyAxMyBieXRlcyB0byBzYXksIHRoYXQgaXQgaXMgc1JHQlxuXG4gIGlmICh0YWJzW1wic1JHQlwiXSAhPSBudWxsKSB7XG4gICAgd1VpKGRhdGEsIG9mZnNldCwgMSk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgd0FzKGRhdGEsIG9mZnNldCwgXCJzUkdCXCIpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGRhdGFbb2Zmc2V0XSA9IHRhYnNbXCJzUkdCXCJdO1xuICAgIG9mZnNldCsrO1xuICAgIHdVaShkYXRhLCBvZmZzZXQsIGNyYyhkYXRhLCBvZmZzZXQgLSA1LCA1KSk7XG4gICAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICB9XG5cbiAgaWYgKHRhYnNbXCJwSFlzXCJdICE9IG51bGwpIHtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCA5KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3QXMoZGF0YSwgb2Zmc2V0LCBcInBIWXNcIik7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgd1VpKGRhdGEsIG9mZnNldCwgdGFic1tcInBIWXNcIl1bMF0pO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHdVaShkYXRhLCBvZmZzZXQsIHRhYnNbXCJwSFlzXCJdWzFdKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBkYXRhW29mZnNldF0gPSB0YWJzW1wicEhZc1wiXVsyXTtcbiAgICBvZmZzZXQrKztcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCBjcmMoZGF0YSwgb2Zmc2V0IC0gMTMsIDEzKSk7XG4gICAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICB9XG5cbiAgaWYgKGFuaW0pIHtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCA4KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3QXMoZGF0YSwgb2Zmc2V0LCBcImFjVExcIik7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgd1VpKGRhdGEsIG9mZnNldCwgbmltZy5mcmFtZXMubGVuZ3RoKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCB0YWJzW1wibG9vcFwiXSAhPSBudWxsID8gdGFic1tcImxvb3BcIl0gOiAwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCBjcmMoZGF0YSwgb2Zmc2V0IC0gMTIsIDEyKSk7XG4gICAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICB9XG5cbiAgaWYgKG5pbWcuY3R5cGUgPT0gMykge1xuICAgIHZhciBkbCA9IG5pbWcucGx0ZS5sZW5ndGg7XG4gICAgd1VpKGRhdGEsIG9mZnNldCwgZGwgKiAzKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3QXMoZGF0YSwgb2Zmc2V0LCBcIlBMVEVcIik7XG4gICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRsOyBpKyspIHtcbiAgICAgIHZhciB0aSA9IGkgKiAzLFxuICAgICAgICAgIGMgPSBuaW1nLnBsdGVbaV0sXG4gICAgICAgICAgciA9IGMgJiAyNTUsXG4gICAgICAgICAgZyA9IGMgPj4+IDggJiAyNTUsXG4gICAgICAgICAgYiA9IGMgPj4+IDE2ICYgMjU1O1xuICAgICAgZGF0YVtvZmZzZXQgKyB0aSArIDBdID0gcjtcbiAgICAgIGRhdGFbb2Zmc2V0ICsgdGkgKyAxXSA9IGc7XG4gICAgICBkYXRhW29mZnNldCArIHRpICsgMl0gPSBiO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBkbCAqIDM7XG4gICAgd1VpKGRhdGEsIG9mZnNldCwgY3JjKGRhdGEsIG9mZnNldCAtIGRsICogMyAtIDQsIGRsICogMyArIDQpKTtcbiAgICBvZmZzZXQgKz0gNDsgLy8gY3JjXG5cbiAgICBpZiAocGx0QWxwaGEpIHtcbiAgICAgIHdVaShkYXRhLCBvZmZzZXQsIGRsKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd0FzKGRhdGEsIG9mZnNldCwgXCJ0Uk5TXCIpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGw7IGkrKykgZGF0YVtvZmZzZXQgKyBpXSA9IG5pbWcucGx0ZVtpXSA+Pj4gMjQgJiAyNTU7XG5cbiAgICAgIG9mZnNldCArPSBkbDtcbiAgICAgIHdVaShkYXRhLCBvZmZzZXQsIGNyYyhkYXRhLCBvZmZzZXQgLSBkbCAtIDQsIGRsICsgNCkpO1xuICAgICAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaSA9IDA7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBuaW1nLmZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBmciA9IG5pbWcuZnJhbWVzW2pdO1xuXG4gICAgaWYgKGFuaW0pIHtcbiAgICAgIHdVaShkYXRhLCBvZmZzZXQsIDI2KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd0FzKGRhdGEsIG9mZnNldCwgXCJmY1RMXCIpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB3VWkoZGF0YSwgb2Zmc2V0LCBmaSsrKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC53aWR0aCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3QuaGVpZ2h0KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC54KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC55KTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgd1VzKGRhdGEsIG9mZnNldCwgZGVsc1tqXSk7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHdVcyhkYXRhLCBvZmZzZXQsIDEwMDApO1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBkYXRhW29mZnNldF0gPSBmci5kaXNwb3NlO1xuICAgICAgb2Zmc2V0Kys7IC8vIGRpc3Bvc2VcblxuICAgICAgZGF0YVtvZmZzZXRdID0gZnIuYmxlbmQ7XG4gICAgICBvZmZzZXQrKzsgLy8gYmxlbmRcblxuICAgICAgd1VpKGRhdGEsIG9mZnNldCwgY3JjKGRhdGEsIG9mZnNldCAtIDMwLCAzMCkpO1xuICAgICAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuICAgIH1cblxuICAgIHZhciBpbWdkID0gZnIuY2ltZyxcbiAgICAgICAgZGwgPSBpbWdkLmxlbmd0aDtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCBkbCArIChqID09IDAgPyAwIDogNCkpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHZhciBpb2ZmID0gb2Zmc2V0O1xuICAgIHdBcyhkYXRhLCBvZmZzZXQsIGogPT0gMCA/IFwiSURBVFwiIDogXCJmZEFUXCIpO1xuICAgIG9mZnNldCArPSA0O1xuXG4gICAgaWYgKGogIT0gMCkge1xuICAgICAgd1VpKGRhdGEsIG9mZnNldCwgZmkrKyk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG5cbiAgICBkYXRhLnNldChpbWdkLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBkbDtcbiAgICB3VWkoZGF0YSwgb2Zmc2V0LCBjcmMoZGF0YSwgaW9mZiwgb2Zmc2V0IC0gaW9mZikpO1xuICAgIG9mZnNldCArPSA0OyAvLyBjcmNcbiAgfVxuXG4gIHdVaShkYXRhLCBvZmZzZXQsIDApO1xuICBvZmZzZXQgKz0gNDtcbiAgd0FzKGRhdGEsIG9mZnNldCwgXCJJRU5EXCIpO1xuICBvZmZzZXQgKz0gNDtcbiAgd1VpKGRhdGEsIG9mZnNldCwgY3JjKGRhdGEsIG9mZnNldCAtIDQsIDQpKTtcbiAgb2Zmc2V0ICs9IDQ7IC8vIGNyY1xuXG4gIHJldHVybiBkYXRhLmJ1ZmZlcjtcbn07XG5cblVQTkcuZW5jb2RlLmNvbXByZXNzUE5HID0gZnVuY3Rpb24gKG91dCwgZmlsdGVyLCBsZXZlbFplcm8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXQuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZybSA9IG91dC5mcmFtZXNbaV0sXG4gICAgICAgIG53ID0gZnJtLnJlY3Qud2lkdGgsXG4gICAgICAgIG5oID0gZnJtLnJlY3QuaGVpZ2h0O1xuICAgIHZhciBmZGF0YSA9IG5ldyBVaW50OEFycmF5KG5oICogZnJtLmJwbCArIG5oKTtcbiAgICBmcm0uY2ltZyA9IFVQTkcuZW5jb2RlLl9maWx0ZXJaZXJvKGZybS5pbWcsIG5oLCBmcm0uYnBwLCBmcm0uYnBsLCBmZGF0YSwgZmlsdGVyLCBsZXZlbFplcm8pO1xuICB9XG59O1xuXG5VUE5HLmVuY29kZS5jb21wcmVzcyA9IGZ1bmN0aW9uIChidWZzLCB3LCBoLCBwcywgcHJtcykgLy8gcHJtczogIG9ubHlCbGVuZCwgbWluQml0cywgZm9yYmlkUGx0ZVxue1xuICAvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgdmFyIG9ubHlCbGVuZCA9IHBybXNbMF0sXG4gICAgICBldmVuQ3JkID0gcHJtc1sxXSxcbiAgICAgIGZvcmJpZFByZXYgPSBwcm1zWzJdLFxuICAgICAgbWluQml0cyA9IHBybXNbM10sXG4gICAgICBmb3JiaWRQbHRlID0gcHJtc1s0XTtcbiAgdmFyIGN0eXBlID0gNixcbiAgICAgIGRlcHRoID0gOCxcbiAgICAgIGFscGhhQW5kID0gMjU1O1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgYnVmcy5sZW5ndGg7IGorKykge1xuICAgIC8vIHdoZW4gbm90IHF1YW50aXplZCwgb3RoZXIgZnJhbWVzIGNhbiBjb250YWluIGNvbG9ycywgdGhhdCBhcmUgbm90IGluIGFuIGluaXRpYWwgZnJhbWVcbiAgICB2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksXG4gICAgICAgIGlsZW4gPSBpbWcubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbGVuOyBpICs9IDQpIGFscGhhQW5kICY9IGltZ1tpICsgM107XG4gIH1cblxuICB2YXIgZ290QWxwaGEgPSBhbHBoYUFuZCAhPSAyNTU7IC8vY29uc29sZS5sb2coXCJhbHBoYSBjaGVja1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG4gIC8vdmFyIGJydXRlID0gZ290QWxwaGEgJiYgZm9yR0lGO1x0XHQvLyBicnV0ZSA6IGZyYW1lcyBjYW4gb25seSBiZSBjb3BpZWQsIG5vdCBcImJsZW5kZWRcIlxuXG4gIHZhciBmcm1zID0gVVBORy5lbmNvZGUuZnJhbWl6ZShidWZzLCB3LCBoLCBvbmx5QmxlbmQsIGV2ZW5DcmQsIGZvcmJpZFByZXYpOyAvL2NvbnNvbGUubG9nKFwiZnJhbWl6ZVwiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cbiAgdmFyIGNtYXAgPSB7fSxcbiAgICAgIHBsdGUgPSBbXSxcbiAgICAgIGluZHMgPSBbXTtcblxuICBpZiAocHMgIT0gMCkge1xuICAgIHZhciBuYnVmcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcm1zLmxlbmd0aDsgaSsrKSBuYnVmcy5wdXNoKGZybXNbaV0uaW1nLmJ1ZmZlcik7XG5cbiAgICB2YXIgYWJ1ZiA9IFVQTkcuZW5jb2RlLmNvbmNhdFJHQkEobmJ1ZnMpLFxuICAgICAgICBxcmVzID0gVVBORy5xdWFudGl6ZShhYnVmLCBwcyk7XG4gICAgdmFyIGNvZiA9IDAsXG4gICAgICAgIGJiID0gbmV3IFVpbnQ4QXJyYXkocXJlcy5hYnVmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRpID0gZnJtc1tpXS5pbWcsXG4gICAgICAgICAgYmxuID0gdGkubGVuZ3RoO1xuICAgICAgaW5kcy5wdXNoKG5ldyBVaW50OEFycmF5KHFyZXMuaW5kcy5idWZmZXIsIGNvZiA+PiAyLCBibG4gPj4gMikpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsbjsgaiArPSA0KSB7XG4gICAgICAgIHRpW2pdID0gYmJbY29mICsgal07XG4gICAgICAgIHRpW2ogKyAxXSA9IGJiW2NvZiArIGogKyAxXTtcbiAgICAgICAgdGlbaiArIDJdID0gYmJbY29mICsgaiArIDJdO1xuICAgICAgICB0aVtqICsgM10gPSBiYltjb2YgKyBqICsgM107XG4gICAgICB9XG5cbiAgICAgIGNvZiArPSBibG47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxcmVzLnBsdGUubGVuZ3RoOyBpKyspIHBsdGUucHVzaChxcmVzLnBsdGVbaV0uZXN0LnJnYmEpOyAvL2NvbnNvbGUubG9nKFwicXVhbnRpemVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hhdCBpZiBwcz09MCwgYnV0IHRoZXJlIGFyZSA8PTI1NiBjb2xvcnM/ICB3ZSBzdGlsbCBuZWVkIHRvIGRldGVjdCwgaWYgdGhlIHBhbGV0dGUgY291bGQgYmUgdXNlZFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZnJtcy5sZW5ndGg7IGorKykge1xuICAgICAgLy8gd2hlbiBub3QgcXVhbnRpemVkLCBvdGhlciBmcmFtZXMgY2FuIGNvbnRhaW4gY29sb3JzLCB0aGF0IGFyZSBub3QgaW4gYW4gaW5pdGlhbCBmcmFtZVxuICAgICAgdmFyIGZybSA9IGZybXNbal0sXG4gICAgICAgICAgaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoZnJtLmltZy5idWZmZXIpLFxuICAgICAgICAgIG53ID0gZnJtLnJlY3Qud2lkdGgsXG4gICAgICAgICAgaWxlbiA9IGltZzMyLmxlbmd0aDtcbiAgICAgIHZhciBpbmQgPSBuZXcgVWludDhBcnJheShpbGVuKTtcbiAgICAgIGluZHMucHVzaChpbmQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICB2YXIgYyA9IGltZzMyW2ldO1xuICAgICAgICBpZiAoaSAhPSAwICYmIGMgPT0gaW1nMzJbaSAtIDFdKSBpbmRbaV0gPSBpbmRbaSAtIDFdO2Vsc2UgaWYgKGkgPiBudyAmJiBjID09IGltZzMyW2kgLSBud10pIGluZFtpXSA9IGluZFtpIC0gbnddO2Vsc2Uge1xuICAgICAgICAgIHZhciBjbWMgPSBjbWFwW2NdO1xuXG4gICAgICAgICAgaWYgKGNtYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjbWFwW2NdID0gY21jID0gcGx0ZS5sZW5ndGg7XG4gICAgICAgICAgICBwbHRlLnB1c2goYyk7XG4gICAgICAgICAgICBpZiAocGx0ZS5sZW5ndGggPj0gMzAwKSBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRbaV0gPSBjbWM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vY29uc29sZS5sb2coXCJtYWtlIHBhbGV0dGVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIH1cblxuICB2YXIgY2MgPSBwbHRlLmxlbmd0aDsgLy9jb25zb2xlLmxvZyhcImNvbG9yczpcIixjYyk7XG5cbiAgaWYgKGNjIDw9IDI1NiAmJiBmb3JiaWRQbHRlID09IGZhbHNlKSB7XG4gICAgaWYgKGNjIDw9IDIpIGRlcHRoID0gMTtlbHNlIGlmIChjYyA8PSA0KSBkZXB0aCA9IDI7ZWxzZSBpZiAoY2MgPD0gMTYpIGRlcHRoID0gNDtlbHNlIGRlcHRoID0gODtcbiAgICBkZXB0aCA9IE1hdGgubWF4KGRlcHRoLCBtaW5CaXRzKTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZnJtcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBmcm0gPSBmcm1zW2pdLFxuICAgICAgICBueCA9IGZybS5yZWN0LngsXG4gICAgICAgIG55ID0gZnJtLnJlY3QueSxcbiAgICAgICAgbncgPSBmcm0ucmVjdC53aWR0aCxcbiAgICAgICAgbmggPSBmcm0ucmVjdC5oZWlnaHQ7XG4gICAgdmFyIGNpbWcgPSBmcm0uaW1nLFxuICAgICAgICBjaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoY2ltZy5idWZmZXIpO1xuICAgIHZhciBicGwgPSA0ICogbncsXG4gICAgICAgIGJwcCA9IDQ7XG5cbiAgICBpZiAoY2MgPD0gMjU2ICYmIGZvcmJpZFBsdGUgPT0gZmFsc2UpIHtcbiAgICAgIGJwbCA9IE1hdGguY2VpbChkZXB0aCAqIG53IC8gOCk7XG4gICAgICB2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KGJwbCAqIG5oKTtcbiAgICAgIHZhciBpbmogPSBpbmRzW2pdO1xuXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG5oOyB5KyspIHtcbiAgICAgICAgdmFyIGkgPSB5ICogYnBsLFxuICAgICAgICAgICAgaWkgPSB5ICogbnc7XG4gICAgICAgIGlmIChkZXB0aCA9PSA4KSBmb3IgKHZhciB4ID0gMDsgeCA8IG53OyB4KyspIG5pbWdbaSArIHhdID0gaW5qW2lpICsgeF07ZWxzZSBpZiAoZGVwdGggPT0gNCkgZm9yICh2YXIgeCA9IDA7IHggPCBudzsgeCsrKSBuaW1nW2kgKyAoeCA+PiAxKV0gfD0gaW5qW2lpICsgeF0gPDwgNCAtICh4ICYgMSkgKiA0O2Vsc2UgaWYgKGRlcHRoID09IDIpIGZvciAodmFyIHggPSAwOyB4IDwgbnc7IHgrKykgbmltZ1tpICsgKHggPj4gMildIHw9IGlualtpaSArIHhdIDw8IDYgLSAoeCAmIDMpICogMjtlbHNlIGlmIChkZXB0aCA9PSAxKSBmb3IgKHZhciB4ID0gMDsgeCA8IG53OyB4KyspIG5pbWdbaSArICh4ID4+IDMpXSB8PSBpbmpbaWkgKyB4XSA8PCA3IC0gKHggJiA3KSAqIDE7XG4gICAgICB9XG5cbiAgICAgIGNpbWcgPSBuaW1nO1xuICAgICAgY3R5cGUgPSAzO1xuICAgICAgYnBwID0gMTtcbiAgICB9IGVsc2UgaWYgKGdvdEFscGhhID09IGZhbHNlICYmIGZybXMubGVuZ3RoID09IDEpIHtcbiAgICAgIC8vIHNvbWUgbmV4dCBcInJlZHVjZWRcIiBmcmFtZXMgbWF5IGNvbnRhaW4gYWxwaGEgZm9yIGJsZW5kaW5nXG4gICAgICB2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KG53ICogbmggKiAzKSxcbiAgICAgICAgICBhcmVhID0gbncgKiBuaDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmVhOyBpKyspIHtcbiAgICAgICAgdmFyIHRpID0gaSAqIDMsXG4gICAgICAgICAgICBxaSA9IGkgKiA0O1xuICAgICAgICBuaW1nW3RpXSA9IGNpbWdbcWldO1xuICAgICAgICBuaW1nW3RpICsgMV0gPSBjaW1nW3FpICsgMV07XG4gICAgICAgIG5pbWdbdGkgKyAyXSA9IGNpbWdbcWkgKyAyXTtcbiAgICAgIH1cblxuICAgICAgY2ltZyA9IG5pbWc7XG4gICAgICBjdHlwZSA9IDI7XG4gICAgICBicHAgPSAzO1xuICAgICAgYnBsID0gMyAqIG53O1xuICAgIH1cblxuICAgIGZybS5pbWcgPSBjaW1nO1xuICAgIGZybS5icGwgPSBicGw7XG4gICAgZnJtLmJwcCA9IGJwcDtcbiAgfSAvL2NvbnNvbGUubG9nKFwiY29sb3JzID0+IHBhbGV0dGUgaW5kaWNlc1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cblxuICByZXR1cm4ge1xuICAgIGN0eXBlOiBjdHlwZSxcbiAgICBkZXB0aDogZGVwdGgsXG4gICAgcGx0ZTogcGx0ZSxcbiAgICBmcmFtZXM6IGZybXNcbiAgfTtcbn07XG5cblVQTkcuZW5jb2RlLmZyYW1pemUgPSBmdW5jdGlvbiAoYnVmcywgdywgaCwgYWx3YXlzQmxlbmQsIGV2ZW5DcmQsIGZvcmJpZFByZXYpIHtcbiAgLyogIERJU1BPU0VcbiAgICAgIC0gMCA6IG5vIGNoYW5nZVxuICBcdC0gMSA6IGNsZWFyIHRvIHRyYW5zcGFyZW50XG4gIFx0LSAyIDogcmV0c3RvcmUgdG8gY29udGVudCBiZWZvcmUgcmVuZGVyaW5nIChwcmV2aW91cyBmcmFtZSBkaXNwb3NlZClcbiAgXHRCTEVORFxuICBcdC0gMCA6IHJlcGxhY2VcbiAgXHQtIDEgOiBibGVuZFxuICAqL1xuICB2YXIgZnJtcyA9IFtdO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgYnVmcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBjaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksXG4gICAgICAgIGNpbWczMiA9IG5ldyBVaW50MzJBcnJheShjaW1nLmJ1ZmZlcik7XG4gICAgdmFyIG5pbWc7XG4gICAgdmFyIG54ID0gMCxcbiAgICAgICAgbnkgPSAwLFxuICAgICAgICBudyA9IHcsXG4gICAgICAgIG5oID0gaCxcbiAgICAgICAgYmxlbmQgPSBhbHdheXNCbGVuZCA/IDEgOiAwO1xuXG4gICAgaWYgKGogIT0gMCkge1xuICAgICAgdmFyIHRsaW0gPSBmb3JiaWRQcmV2IHx8IGFsd2F5c0JsZW5kIHx8IGogPT0gMSB8fCBmcm1zW2ogLSAyXS5kaXNwb3NlICE9IDAgPyAxIDogMixcbiAgICAgICAgICB0c3RwID0gMCxcbiAgICAgICAgICB0YXJlYSA9IDFlOTtcblxuICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IHRsaW07IGl0KyspIHtcbiAgICAgICAgdmFyIHBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2ogLSAxIC0gaXRdKSxcbiAgICAgICAgICAgIHAzMiA9IG5ldyBVaW50MzJBcnJheShidWZzW2ogLSAxIC0gaXRdKTtcbiAgICAgICAgdmFyIG1peCA9IHcsXG4gICAgICAgICAgICBtaXkgPSBoLFxuICAgICAgICAgICAgbWF4ID0gLTEsXG4gICAgICAgICAgICBtYXkgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICB2YXIgaSA9IHkgKiB3ICsgeDtcblxuICAgICAgICAgIGlmIChjaW1nMzJbaV0gIT0gcDMyW2ldKSB7XG4gICAgICAgICAgICBpZiAoeCA8IG1peCkgbWl4ID0geDtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4KSBtYXggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaXkpIG1peSA9IHk7XG4gICAgICAgICAgICBpZiAoeSA+IG1heSkgbWF5ID0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ID09IC0xKSBtaXggPSBtaXkgPSBtYXggPSBtYXkgPSAwO1xuXG4gICAgICAgIGlmIChldmVuQ3JkKSB7XG4gICAgICAgICAgaWYgKChtaXggJiAxKSA9PSAxKSBtaXgtLTtcbiAgICAgICAgICBpZiAoKG1peSAmIDEpID09IDEpIG1peS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNhcmVhID0gKG1heCAtIG1peCArIDEpICogKG1heSAtIG1peSArIDEpO1xuXG4gICAgICAgIGlmIChzYXJlYSA8IHRhcmVhKSB7XG4gICAgICAgICAgdGFyZWEgPSBzYXJlYTtcbiAgICAgICAgICB0c3RwID0gaXQ7XG4gICAgICAgICAgbnggPSBtaXg7XG4gICAgICAgICAgbnkgPSBtaXk7XG4gICAgICAgICAgbncgPSBtYXggLSBtaXggKyAxO1xuICAgICAgICAgIG5oID0gbWF5IC0gbWl5ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBhbHdheXNCbGVuZDogcG9rdWQgemppc3TDrW0sIMW+ZSBibGVuZGl0IG5lbHplLCBuYXN0YXbDrW0gcMWZZWRjaG96w61tdSBzbsOtbWt1IGRpc3Bvc2U9MS4gWmFqaXN0w61tLCBhYnkgb2JzYWhvdmFsIG3Fr2ogb2Jkw6lsbsOtay5cblxuXG4gICAgICB2YXIgcGltZyA9IG5ldyBVaW50OEFycmF5KGJ1ZnNbaiAtIDEgLSB0c3RwXSk7XG4gICAgICBpZiAodHN0cCA9PSAxKSBmcm1zW2ogLSAxXS5kaXNwb3NlID0gMjtcbiAgICAgIG5pbWcgPSBuZXcgVWludDhBcnJheShudyAqIG5oICogNCk7XG5cbiAgICAgIFVQTkcuX2NvcHlUaWxlKHBpbWcsIHcsIGgsIG5pbWcsIG53LCBuaCwgLW54LCAtbnksIDApO1xuXG4gICAgICBibGVuZCA9IFVQTkcuX2NvcHlUaWxlKGNpbWcsIHcsIGgsIG5pbWcsIG53LCBuaCwgLW54LCAtbnksIDMpID8gMSA6IDA7XG4gICAgICBpZiAoYmxlbmQgPT0gMSkgVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsIHcsIGgsIG5pbWcsIHtcbiAgICAgICAgeDogbngsXG4gICAgICAgIHk6IG55LFxuICAgICAgICB3aWR0aDogbncsXG4gICAgICAgIGhlaWdodDogbmhcbiAgICAgIH0pO2Vsc2UgVVBORy5fY29weVRpbGUoY2ltZywgdywgaCwgbmltZywgbncsIG5oLCAtbngsIC1ueSwgMCk7IC8vVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcsbncsbmgsIC1ueCwtbnksIGJsZW5kPT0xPzI6MCk7XG4gICAgfSBlbHNlIG5pbWcgPSBjaW1nLnNsaWNlKDApOyAvLyBpbWcgbWF5IGJlIHJld3JpdHRlbiBmdXJ0aGVyIC4uLiBkb24ndCByZXdyaXRlIGlucHV0XG5cblxuICAgIGZybXMucHVzaCh7XG4gICAgICByZWN0OiB7XG4gICAgICAgIHg6IG54LFxuICAgICAgICB5OiBueSxcbiAgICAgICAgd2lkdGg6IG53LFxuICAgICAgICBoZWlnaHQ6IG5oXG4gICAgICB9LFxuICAgICAgaW1nOiBuaW1nLFxuICAgICAgYmxlbmQ6IGJsZW5kLFxuICAgICAgZGlzcG9zZTogMFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFsd2F5c0JsZW5kKSBmb3IgKHZhciBqID0gMDsgaiA8IGZybXMubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgZnJtID0gZnJtc1tqXTtcbiAgICBpZiAoZnJtLmJsZW5kID09IDEpIGNvbnRpbnVlO1xuICAgIHZhciByMCA9IGZybS5yZWN0LFxuICAgICAgICByMSA9IGZybXNbaiAtIDFdLnJlY3Q7XG4gICAgdmFyIG1pWCA9IE1hdGgubWluKHIwLngsIHIxLngpLFxuICAgICAgICBtaVkgPSBNYXRoLm1pbihyMC55LCByMS55KTtcbiAgICB2YXIgbWFYID0gTWF0aC5tYXgocjAueCArIHIwLndpZHRoLCByMS54ICsgcjEud2lkdGgpLFxuICAgICAgICBtYVkgPSBNYXRoLm1heChyMC55ICsgcjAuaGVpZ2h0LCByMS55ICsgcjEuaGVpZ2h0KTtcbiAgICB2YXIgciA9IHtcbiAgICAgIHg6IG1pWCxcbiAgICAgIHk6IG1pWSxcbiAgICAgIHdpZHRoOiBtYVggLSBtaVgsXG4gICAgICBoZWlnaHQ6IG1hWSAtIG1pWVxuICAgIH07XG4gICAgZnJtc1tqIC0gMV0uZGlzcG9zZSA9IDE7XG4gICAgaWYgKGogLSAxICE9IDApIFVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZShidWZzLCB3LCBoLCBmcm1zLCBqIC0gMSwgciwgZXZlbkNyZCk7XG5cbiAgICBVUE5HLmVuY29kZS5fdXBkYXRlRnJhbWUoYnVmcywgdywgaCwgZnJtcywgaiwgciwgZXZlbkNyZCk7XG4gIH1cbiAgdmFyIGFyZWEgPSAwO1xuICBpZiAoYnVmcy5sZW5ndGggIT0gMSkgZm9yICh2YXIgaSA9IDA7IGkgPCBmcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZybSA9IGZybXNbaV07XG4gICAgYXJlYSArPSBmcm0ucmVjdC53aWR0aCAqIGZybS5yZWN0LmhlaWdodDsgLy9pZihpPT0wIHx8IGZybS5ibGVuZCE9MSkgY29udGludWU7XG4gICAgLy92YXIgb2IgPSBuZXcgVWludDhBcnJheShcbiAgICAvL2NvbnNvbGUubG9nKGZybS5ibGVuZCwgZnJtLmRpc3Bvc2UsIGZybS5yZWN0KTtcbiAgfSAvL2lmKGFyZWEhPTApIGNvbnNvbGUubG9nKGFyZWEpO1xuXG4gIHJldHVybiBmcm1zO1xufTtcblxuVVBORy5lbmNvZGUuX3VwZGF0ZUZyYW1lID0gZnVuY3Rpb24gKGJ1ZnMsIHcsIGgsIGZybXMsIGksIHIsIGV2ZW5DcmQpIHtcbiAgdmFyIFU4ID0gVWludDhBcnJheSxcbiAgICAgIFUzMiA9IFVpbnQzMkFycmF5O1xuICB2YXIgcGltZyA9IG5ldyBVOChidWZzW2kgLSAxXSksXG4gICAgICBwaW1nMzIgPSBuZXcgVTMyKGJ1ZnNbaSAtIDFdKSxcbiAgICAgIG5pbWcgPSBpICsgMSA8IGJ1ZnMubGVuZ3RoID8gbmV3IFU4KGJ1ZnNbaSArIDFdKSA6IG51bGw7XG4gIHZhciBjaW1nID0gbmV3IFU4KGJ1ZnNbaV0pLFxuICAgICAgY2ltZzMyID0gbmV3IFUzMihjaW1nLmJ1ZmZlcik7XG4gIHZhciBtaXggPSB3LFxuICAgICAgbWl5ID0gaCxcbiAgICAgIG1heCA9IC0xLFxuICAgICAgbWF5ID0gLTE7XG5cbiAgZm9yICh2YXIgeSA9IDA7IHkgPCByLmhlaWdodDsgeSsrKSBmb3IgKHZhciB4ID0gMDsgeCA8IHIud2lkdGg7IHgrKykge1xuICAgIHZhciBjeCA9IHIueCArIHgsXG4gICAgICAgIGN5ID0gci55ICsgeTtcbiAgICB2YXIgaiA9IGN5ICogdyArIGN4LFxuICAgICAgICBjYyA9IGNpbWczMltqXTsgLy8gbm8gbmVlZCB0byBkcmF3IHRyYW5zcGFyZW5jeSwgb3IgdG8gZGlzcG9zZSBpdC4gT3IsIGlmIHdyaXRpbmcgdGhlIHNhbWUgY29sb3IgYW5kIHRoZSBuZXh0IG9uZSBkb2VzIG5vdCBuZWVkIHRyYW5zcGFyZW5jeS5cblxuICAgIGlmIChjYyA9PSAwIHx8IGZybXNbaSAtIDFdLmRpc3Bvc2UgPT0gMCAmJiBwaW1nMzJbal0gPT0gY2MgJiYgKG5pbWcgPT0gbnVsbCB8fCBuaW1nW2ogKiA0ICsgM10gIT0gMClcbiAgICAvKiovXG4gICAgKSB7fSBlbHNlIHtcbiAgICAgIGlmIChjeCA8IG1peCkgbWl4ID0gY3g7XG4gICAgICBpZiAoY3ggPiBtYXgpIG1heCA9IGN4O1xuICAgICAgaWYgKGN5IDwgbWl5KSBtaXkgPSBjeTtcbiAgICAgIGlmIChjeSA+IG1heSkgbWF5ID0gY3k7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heCA9PSAtMSkgbWl4ID0gbWl5ID0gbWF4ID0gbWF5ID0gMDtcblxuICBpZiAoZXZlbkNyZCkge1xuICAgIGlmICgobWl4ICYgMSkgPT0gMSkgbWl4LS07XG4gICAgaWYgKChtaXkgJiAxKSA9PSAxKSBtaXktLTtcbiAgfVxuXG4gIHIgPSB7XG4gICAgeDogbWl4LFxuICAgIHk6IG1peSxcbiAgICB3aWR0aDogbWF4IC0gbWl4ICsgMSxcbiAgICBoZWlnaHQ6IG1heSAtIG1peSArIDFcbiAgfTtcbiAgdmFyIGZyID0gZnJtc1tpXTtcbiAgZnIucmVjdCA9IHI7XG4gIGZyLmJsZW5kID0gMTtcbiAgZnIuaW1nID0gbmV3IFVpbnQ4QXJyYXkoci53aWR0aCAqIHIuaGVpZ2h0ICogNCk7XG5cbiAgaWYgKGZybXNbaSAtIDFdLmRpc3Bvc2UgPT0gMCkge1xuICAgIFVQTkcuX2NvcHlUaWxlKHBpbWcsIHcsIGgsIGZyLmltZywgci53aWR0aCwgci5oZWlnaHQsIC1yLngsIC1yLnksIDApO1xuXG4gICAgVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsIHcsIGgsIGZyLmltZywgcik7IC8vVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIGZyLmltZyxyLndpZHRoLHIuaGVpZ2h0LCAtci54LC1yLnksIDIpO1xuXG4gIH0gZWxzZSBVUE5HLl9jb3B5VGlsZShjaW1nLCB3LCBoLCBmci5pbWcsIHIud2lkdGgsIHIuaGVpZ2h0LCAtci54LCAtci55LCAwKTtcbn07XG5cblVQTkcuZW5jb2RlLl9wcmVwYXJlRGlmZiA9IGZ1bmN0aW9uIChjaW1nLCB3LCBoLCBuaW1nLCByZWMpIHtcbiAgVVBORy5fY29weVRpbGUoY2ltZywgdywgaCwgbmltZywgcmVjLndpZHRoLCByZWMuaGVpZ2h0LCAtcmVjLngsIC1yZWMueSwgMik7XG4gIC8qXG4gIHZhciBuMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuICB2YXIgb2cgPSBuZXcgVWludDhBcnJheShyZWMud2lkdGgqcmVjLmhlaWdodCo0KSwgbzMyID0gbmV3IFVpbnQzMkFycmF5KG9nLmJ1ZmZlcik7XG4gIFVQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBvZyxyZWMud2lkdGgscmVjLmhlaWdodCwgLXJlYy54LC1yZWMueSwgMCk7XG4gIGZvcih2YXIgaT00OyBpPG5pbWcubGVuZ3RoOyBpKz00KSB7XG4gIFx0aWYobmltZ1tpLTFdIT0wICYmIG5pbWdbaSszXT09MCAmJiBvMzJbaT4+PjJdPT1vMzJbKGk+Pj4yKS0xXSkge1xuICBcdFx0bjMyW2k+Pj4yXT1vMzJbaT4+PjJdO1xuICBcdFx0Ly92YXIgaiA9IGksIGM9cDMyWyhpPj4+MiktMV07XG4gIFx0XHQvL3doaWxlKHAzMltqPj4+Ml09PWMpIHsgIG4zMltqPj4+Ml09YzsgIGorPTQ7ICB9XG4gIFx0fVxuICB9XG4gIGZvcih2YXIgaT1uaW1nLmxlbmd0aC04OyBpPjA7IGktPTQpIHtcbiAgXHRpZihuaW1nW2krN10hPTAgJiYgbmltZ1tpKzNdPT0wICYmIG8zMltpPj4+Ml09PW8zMlsoaT4+PjIpKzFdKSB7XG4gIFx0XHRuMzJbaT4+PjJdPW8zMltpPj4+Ml07XG4gIFx0XHQvL3ZhciBqID0gaSwgYz1wMzJbKGk+Pj4yKS0xXTtcbiAgXHRcdC8vd2hpbGUocDMyW2o+Pj4yXT09YykgeyAgbjMyW2o+Pj4yXT1jOyAgais9NDsgIH1cbiAgXHR9XG4gIH0qL1xuXG59O1xuXG5VUE5HLmVuY29kZS5fZmlsdGVyWmVybyA9IGZ1bmN0aW9uIChpbWcsIGgsIGJwcCwgYnBsLCBkYXRhLCBmaWx0ZXIsIGxldmVsWmVybykge1xuICB2YXIgZmxzID0gW10sXG4gICAgICBmdHJ5ID0gWzAsIDEsIDIsIDMsIDRdO1xuICBpZiAoZmlsdGVyICE9IC0xKSBmdHJ5ID0gW2ZpbHRlcl07ZWxzZSBpZiAoaCAqIGJwbCA+IDUwMDAwMCB8fCBicHAgPT0gMSkgZnRyeSA9IFswXTtcbiAgdmFyIG9wdHM7XG4gIGlmIChsZXZlbFplcm8pIG9wdHMgPSB7XG4gICAgbGV2ZWw6IDBcbiAgfTtcbiAgdmFyIENNUFIgPSBsZXZlbFplcm8gJiYgVVpJUCAhPSBudWxsID8gVVpJUCA6IF9wYWtvLmRlZmF1bHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIFVQTkcuZW5jb2RlLl9maWx0ZXJMaW5lKGRhdGEsIGltZywgeSwgYnBsLCBicHAsIGZ0cnlbaV0pOyAvL3ZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIC8vdmFyIHN6ID0gVVpJUC5GLmRlZmxhdGUoZGF0YSwgbmltZyk7ICBmbHMucHVzaChuaW1nLnNsaWNlKDAsc3opKTtcbiAgICAvL3ZhciBkZmwgPSBwYWtvW1wiZGVmbGF0ZVwiXShkYXRhKSwgZGw9ZGZsLmxlbmd0aC00O1xuICAgIC8vdmFyIGNyYyA9IChkZmxbZGwrM108PDI0KXwoZGZsW2RsKzJdPDwxNil8KGRmbFtkbCsxXTw8OCl8KGRmbFtkbCswXTw8MCk7XG4gICAgLy9jb25zb2xlLmxvZyhjcmMsIFVaSVAuYWRsZXIoZGF0YSwyLGRhdGEubGVuZ3RoLTYpKTtcblxuXG4gICAgZmxzLnB1c2goQ01QUltcImRlZmxhdGVcIl0oZGF0YSwgb3B0cykpO1xuICB9XG5cbiAgdmFyIHRpLFxuICAgICAgdHNpemUgPSAxZTk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbHMubGVuZ3RoOyBpKyspIGlmIChmbHNbaV0ubGVuZ3RoIDwgdHNpemUpIHtcbiAgICB0aSA9IGk7XG4gICAgdHNpemUgPSBmbHNbaV0ubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGZsc1t0aV07XG59O1xuXG5VUE5HLmVuY29kZS5fZmlsdGVyTGluZSA9IGZ1bmN0aW9uIChkYXRhLCBpbWcsIHksIGJwbCwgYnBwLCB0eXBlKSB7XG4gIHZhciBpID0geSAqIGJwbCxcbiAgICAgIGRpID0gaSArIHksXG4gICAgICBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aDtcbiAgZGF0YVtkaV0gPSB0eXBlO1xuICBkaSsrO1xuXG4gIGlmICh0eXBlID09IDApIHtcbiAgICBpZiAoYnBsIDwgNTAwKSBmb3IgKHZhciB4ID0gMDsgeCA8IGJwbDsgeCsrKSBkYXRhW2RpICsgeF0gPSBpbWdbaSArIHhdO2Vsc2UgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoaW1nLmJ1ZmZlciwgaSwgYnBsKSwgZGkpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT0gMSkge1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgYnBwOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF07XG5cbiAgICBmb3IgKHZhciB4ID0gYnBwOyB4IDwgYnBsOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF0gLSBpbWdbaSArIHggLSBicHBdICsgMjU2ICYgMjU1O1xuICB9IGVsc2UgaWYgKHkgPT0gMCkge1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgYnBwOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF07XG5cbiAgICBpZiAodHlwZSA9PSAyKSBmb3IgKHZhciB4ID0gYnBwOyB4IDwgYnBsOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF07XG4gICAgaWYgKHR5cGUgPT0gMykgZm9yICh2YXIgeCA9IGJwcDsgeCA8IGJwbDsgeCsrKSBkYXRhW2RpICsgeF0gPSBpbWdbaSArIHhdIC0gKGltZ1tpICsgeCAtIGJwcF0gPj4gMSkgKyAyNTYgJiAyNTU7XG4gICAgaWYgKHR5cGUgPT0gNCkgZm9yICh2YXIgeCA9IGJwcDsgeCA8IGJwbDsgeCsrKSBkYXRhW2RpICsgeF0gPSBpbWdbaSArIHhdIC0gcGFldGgoaW1nW2kgKyB4IC0gYnBwXSwgMCwgMCkgKyAyNTYgJiAyNTU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGUgPT0gMikge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBicGw7IHgrKykgZGF0YVtkaSArIHhdID0gaW1nW2kgKyB4XSArIDI1NiAtIGltZ1tpICsgeCAtIGJwbF0gJiAyNTU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT0gMykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBicHA7IHgrKykgZGF0YVtkaSArIHhdID0gaW1nW2kgKyB4XSArIDI1NiAtIChpbWdbaSArIHggLSBicGxdID4+IDEpICYgMjU1O1xuXG4gICAgICBmb3IgKHZhciB4ID0gYnBwOyB4IDwgYnBsOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF0gKyAyNTYgLSAoaW1nW2kgKyB4IC0gYnBsXSArIGltZ1tpICsgeCAtIGJwcF0gPj4gMSkgJiAyNTU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT0gNCkge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBicHA7IHgrKykgZGF0YVtkaSArIHhdID0gaW1nW2kgKyB4XSArIDI1NiAtIHBhZXRoKDAsIGltZ1tpICsgeCAtIGJwbF0sIDApICYgMjU1O1xuXG4gICAgICBmb3IgKHZhciB4ID0gYnBwOyB4IDwgYnBsOyB4KyspIGRhdGFbZGkgKyB4XSA9IGltZ1tpICsgeF0gKyAyNTYgLSBwYWV0aChpbWdbaSArIHggLSBicHBdLCBpbWdbaSArIHggLSBicGxdLCBpbWdbaSArIHggLSBicHAgLSBicGxdKSAmIDI1NTtcbiAgICB9XG4gIH1cbn07XG5cblVQTkcuY3JjID0ge1xuICB0YWJsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YWIgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICAgIHZhciBjID0gbjtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgaWYgKGMgJiAxKSBjID0gMHhlZGI4ODMyMCBeIGMgPj4+IDE7ZWxzZSBjID0gYyA+Pj4gMTtcbiAgICAgIH1cblxuICAgICAgdGFiW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFiO1xuICB9KCksXG4gIHVwZGF0ZTogZnVuY3Rpb24gKGMsIGJ1Ziwgb2ZmLCBsZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjID0gVVBORy5jcmMudGFibGVbKGMgXiBidWZbb2ZmICsgaV0pICYgMHhmZl0gXiBjID4+PiA4O1xuXG4gICAgcmV0dXJuIGM7XG4gIH0sXG4gIGNyYzogZnVuY3Rpb24gKGIsIG8sIGwpIHtcbiAgICByZXR1cm4gVVBORy5jcmMudXBkYXRlKDB4ZmZmZmZmZmYsIGIsIG8sIGwpIF4gMHhmZmZmZmZmZjtcbiAgfVxufTtcblxuVVBORy5xdWFudGl6ZSA9IGZ1bmN0aW9uIChhYnVmLCBwcykge1xuICB2YXIgb2ltZyA9IG5ldyBVaW50OEFycmF5KGFidWYpLFxuICAgICAgbmltZyA9IG9pbWcuc2xpY2UoMCksXG4gICAgICBuaW1nMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuICB2YXIgS0QgPSBVUE5HLnF1YW50aXplLmdldEtEdHJlZShuaW1nLCBwcyk7XG4gIHZhciByb290ID0gS0RbMF0sXG4gICAgICBsZWFmcyA9IEtEWzFdO1xuICB2YXIgcGxhbmVEc3QgPSBVUE5HLnF1YW50aXplLnBsYW5lRHN0O1xuICB2YXIgc2IgPSBvaW1nLFxuICAgICAgdGIgPSBuaW1nMzIsXG4gICAgICBsZW4gPSBzYi5sZW5ndGg7XG4gIHZhciBpbmRzID0gbmV3IFVpbnQ4QXJyYXkob2ltZy5sZW5ndGggPj4gMik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHZhciByID0gc2JbaV0gKiAoMSAvIDI1NSksXG4gICAgICAgIGcgPSBzYltpICsgMV0gKiAoMSAvIDI1NSksXG4gICAgICAgIGIgPSBzYltpICsgMl0gKiAoMSAvIDI1NSksXG4gICAgICAgIGEgPSBzYltpICsgM10gKiAoMSAvIDI1NSk7IC8vICBleGFjdCwgYnV0IHRvbyBzbG93IDooXG5cbiAgICB2YXIgbmQgPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qocm9vdCwgciwgZywgYiwgYSk7IC8vdmFyIG5kID0gcm9vdDtcbiAgICAvL3doaWxlKG5kLmxlZnQpIG5kID0gKHBsYW5lRHN0KG5kLmVzdCxyLGcsYixhKTw9MCkgPyBuZC5sZWZ0IDogbmQucmlnaHQ7XG5cbiAgICBpbmRzW2kgPj4gMl0gPSBuZC5pbmQ7XG4gICAgdGJbaSA+PiAyXSA9IG5kLmVzdC5yZ2JhO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhYnVmOiBuaW1nLmJ1ZmZlcixcbiAgICBpbmRzOiBpbmRzLFxuICAgIHBsdGU6IGxlYWZzXG4gIH07XG59O1xuXG5VUE5HLnF1YW50aXplLmdldEtEdHJlZSA9IGZ1bmN0aW9uIChuaW1nLCBwcywgZXJyKSB7XG4gIGlmIChlcnIgPT0gbnVsbCkgZXJyID0gMC4wMDAxO1xuICB2YXIgbmltZzMyID0gbmV3IFVpbnQzMkFycmF5KG5pbWcuYnVmZmVyKTtcbiAgdmFyIHJvb3QgPSB7XG4gICAgaTA6IDAsXG4gICAgaTE6IG5pbWcubGVuZ3RoLFxuICAgIGJzdDogbnVsbCxcbiAgICBlc3Q6IG51bGwsXG4gICAgdGRzdDogMCxcbiAgICBsZWZ0OiBudWxsLFxuICAgIHJpZ2h0OiBudWxsXG4gIH07IC8vIGJhc2ljIHN0YXRpc3RpYywgZXh0cmEgc3RhdGlzdGljXG5cbiAgcm9vdC5ic3QgPSBVUE5HLnF1YW50aXplLnN0YXRzKG5pbWcsIHJvb3QuaTAsIHJvb3QuaTEpO1xuICByb290LmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKHJvb3QuYnN0KTtcbiAgdmFyIGxlYWZzID0gW3Jvb3RdO1xuXG4gIHdoaWxlIChsZWFmcy5sZW5ndGggPCBwcykge1xuICAgIHZhciBtYXhMID0gMCxcbiAgICAgICAgbWkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWFmcy5sZW5ndGg7IGkrKykgaWYgKGxlYWZzW2ldLmVzdC5MID4gbWF4TCkge1xuICAgICAgbWF4TCA9IGxlYWZzW2ldLmVzdC5MO1xuICAgICAgbWkgPSBpO1xuICAgIH1cblxuICAgIGlmIChtYXhMIDwgZXJyKSBicmVhaztcbiAgICB2YXIgbm9kZSA9IGxlYWZzW21pXTtcbiAgICB2YXIgczAgPSBVUE5HLnF1YW50aXplLnNwbGl0UGl4ZWxzKG5pbWcsIG5pbWczMiwgbm9kZS5pMCwgbm9kZS5pMSwgbm9kZS5lc3QuZSwgbm9kZS5lc3QuZU1xMjU1KTtcbiAgICB2YXIgczB3cm9uZyA9IG5vZGUuaTAgPj0gczAgfHwgbm9kZS5pMSA8PSBzMDsgLy9jb25zb2xlLmxvZyhtYXhMLCBsZWFmcy5sZW5ndGgsIG1pKTtcblxuICAgIGlmIChzMHdyb25nKSB7XG4gICAgICBub2RlLmVzdC5MID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBsbiA9IHtcbiAgICAgIGkwOiBub2RlLmkwLFxuICAgICAgaTE6IHMwLFxuICAgICAgYnN0OiBudWxsLFxuICAgICAgZXN0OiBudWxsLFxuICAgICAgdGRzdDogMCxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbFxuICAgIH07XG4gICAgbG4uYnN0ID0gVVBORy5xdWFudGl6ZS5zdGF0cyhuaW1nLCBsbi5pMCwgbG4uaTEpO1xuICAgIGxuLmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKGxuLmJzdCk7XG4gICAgdmFyIHJuID0ge1xuICAgICAgaTA6IHMwLFxuICAgICAgaTE6IG5vZGUuaTEsXG4gICAgICBic3Q6IG51bGwsXG4gICAgICBlc3Q6IG51bGwsXG4gICAgICB0ZHN0OiAwLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHJpZ2h0OiBudWxsXG4gICAgfTtcbiAgICBybi5ic3QgPSB7XG4gICAgICBSOiBbXSxcbiAgICAgIG06IFtdLFxuICAgICAgTjogbm9kZS5ic3QuTiAtIGxuLmJzdC5OXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgcm4uYnN0LlJbaV0gPSBub2RlLmJzdC5SW2ldIC0gbG4uYnN0LlJbaV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykgcm4uYnN0Lm1baV0gPSBub2RlLmJzdC5tW2ldIC0gbG4uYnN0Lm1baV07XG5cbiAgICBybi5lc3QgPSBVUE5HLnF1YW50aXplLmVzdGF0cyhybi5ic3QpO1xuICAgIG5vZGUubGVmdCA9IGxuO1xuICAgIG5vZGUucmlnaHQgPSBybjtcbiAgICBsZWFmc1ttaV0gPSBsbjtcbiAgICBsZWFmcy5wdXNoKHJuKTtcbiAgfVxuXG4gIGxlYWZzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5ic3QuTiAtIGEuYnN0Lk47XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVhZnMubGVuZ3RoOyBpKyspIGxlYWZzW2ldLmluZCA9IGk7XG5cbiAgcmV0dXJuIFtyb290LCBsZWFmc107XG59O1xuXG5VUE5HLnF1YW50aXplLmdldE5lYXJlc3QgPSBmdW5jdGlvbiAobmQsIHIsIGcsIGIsIGEpIHtcbiAgaWYgKG5kLmxlZnQgPT0gbnVsbCkge1xuICAgIG5kLnRkc3QgPSBVUE5HLnF1YW50aXplLmRpc3QobmQuZXN0LnEsIHIsIGcsIGIsIGEpO1xuICAgIHJldHVybiBuZDtcbiAgfVxuXG4gIHZhciBwbGFuZURzdCA9IFVQTkcucXVhbnRpemUucGxhbmVEc3QobmQuZXN0LCByLCBnLCBiLCBhKTtcbiAgdmFyIG5vZGUwID0gbmQubGVmdCxcbiAgICAgIG5vZGUxID0gbmQucmlnaHQ7XG5cbiAgaWYgKHBsYW5lRHN0ID4gMCkge1xuICAgIG5vZGUwID0gbmQucmlnaHQ7XG4gICAgbm9kZTEgPSBuZC5sZWZ0O1xuICB9XG5cbiAgdmFyIGxuID0gVVBORy5xdWFudGl6ZS5nZXROZWFyZXN0KG5vZGUwLCByLCBnLCBiLCBhKTtcbiAgaWYgKGxuLnRkc3QgPD0gcGxhbmVEc3QgKiBwbGFuZURzdCkgcmV0dXJuIGxuO1xuICB2YXIgcm4gPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qobm9kZTEsIHIsIGcsIGIsIGEpO1xuICByZXR1cm4gcm4udGRzdCA8IGxuLnRkc3QgPyBybiA6IGxuO1xufTtcblxuVVBORy5xdWFudGl6ZS5wbGFuZURzdCA9IGZ1bmN0aW9uIChlc3QsIHIsIGcsIGIsIGEpIHtcbiAgdmFyIGUgPSBlc3QuZTtcbiAgcmV0dXJuIGVbMF0gKiByICsgZVsxXSAqIGcgKyBlWzJdICogYiArIGVbM10gKiBhIC0gZXN0LmVNcTtcbn07XG5cblVQTkcucXVhbnRpemUuZGlzdCA9IGZ1bmN0aW9uIChxLCByLCBnLCBiLCBhKSB7XG4gIHZhciBkMCA9IHIgLSBxWzBdLFxuICAgICAgZDEgPSBnIC0gcVsxXSxcbiAgICAgIGQyID0gYiAtIHFbMl0sXG4gICAgICBkMyA9IGEgLSBxWzNdO1xuICByZXR1cm4gZDAgKiBkMCArIGQxICogZDEgKyBkMiAqIGQyICsgZDMgKiBkMztcbn07XG5cblVQTkcucXVhbnRpemUuc3BsaXRQaXhlbHMgPSBmdW5jdGlvbiAobmltZywgbmltZzMyLCBpMCwgaTEsIGUsIGVNcSkge1xuICB2YXIgdmVjRG90ID0gVVBORy5xdWFudGl6ZS52ZWNEb3Q7XG4gIGkxIC09IDQ7XG4gIHZhciBzaGZzID0gMDtcblxuICB3aGlsZSAoaTAgPCBpMSkge1xuICAgIHdoaWxlICh2ZWNEb3QobmltZywgaTAsIGUpIDw9IGVNcSkgaTAgKz0gNDtcblxuICAgIHdoaWxlICh2ZWNEb3QobmltZywgaTEsIGUpID4gZU1xKSBpMSAtPSA0O1xuXG4gICAgaWYgKGkwID49IGkxKSBicmVhaztcbiAgICB2YXIgdCA9IG5pbWczMltpMCA+PiAyXTtcbiAgICBuaW1nMzJbaTAgPj4gMl0gPSBuaW1nMzJbaTEgPj4gMl07XG4gICAgbmltZzMyW2kxID4+IDJdID0gdDtcbiAgICBpMCArPSA0O1xuICAgIGkxIC09IDQ7XG4gIH1cblxuICB3aGlsZSAodmVjRG90KG5pbWcsIGkwLCBlKSA+IGVNcSkgaTAgLT0gNDtcblxuICByZXR1cm4gaTAgKyA0O1xufTtcblxuVVBORy5xdWFudGl6ZS52ZWNEb3QgPSBmdW5jdGlvbiAobmltZywgaSwgZSkge1xuICByZXR1cm4gbmltZ1tpXSAqIGVbMF0gKyBuaW1nW2kgKyAxXSAqIGVbMV0gKyBuaW1nW2kgKyAyXSAqIGVbMl0gKyBuaW1nW2kgKyAzXSAqIGVbM107XG59O1xuXG5VUE5HLnF1YW50aXplLnN0YXRzID0gZnVuY3Rpb24gKG5pbWcsIGkwLCBpMSkge1xuICB2YXIgUiA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIG0gPSBbMCwgMCwgMCwgMF07XG4gIHZhciBOID0gaTEgLSBpMCA+PiAyO1xuXG4gIGZvciAodmFyIGkgPSBpMDsgaSA8IGkxOyBpICs9IDQpIHtcbiAgICB2YXIgciA9IG5pbWdbaV0gKiAoMSAvIDI1NSksXG4gICAgICAgIGcgPSBuaW1nW2kgKyAxXSAqICgxIC8gMjU1KSxcbiAgICAgICAgYiA9IG5pbWdbaSArIDJdICogKDEgLyAyNTUpLFxuICAgICAgICBhID0gbmltZ1tpICsgM10gKiAoMSAvIDI1NSk7IC8vdmFyIHIgPSBuaW1nW2ldLCBnID0gbmltZ1tpKzFdLCBiID0gbmltZ1tpKzJdLCBhID0gbmltZ1tpKzNdO1xuXG4gICAgbVswXSArPSByO1xuICAgIG1bMV0gKz0gZztcbiAgICBtWzJdICs9IGI7XG4gICAgbVszXSArPSBhO1xuICAgIFJbMF0gKz0gciAqIHI7XG4gICAgUlsxXSArPSByICogZztcbiAgICBSWzJdICs9IHIgKiBiO1xuICAgIFJbM10gKz0gciAqIGE7XG4gICAgUls1XSArPSBnICogZztcbiAgICBSWzZdICs9IGcgKiBiO1xuICAgIFJbN10gKz0gZyAqIGE7XG4gICAgUlsxMF0gKz0gYiAqIGI7XG4gICAgUlsxMV0gKz0gYiAqIGE7XG4gICAgUlsxNV0gKz0gYSAqIGE7XG4gIH1cblxuICBSWzRdID0gUlsxXTtcbiAgUls4XSA9IFJbMl07XG4gIFJbOV0gPSBSWzZdO1xuICBSWzEyXSA9IFJbM107XG4gIFJbMTNdID0gUls3XTtcbiAgUlsxNF0gPSBSWzExXTtcbiAgcmV0dXJuIHtcbiAgICBSOiBSLFxuICAgIG06IG0sXG4gICAgTjogTlxuICB9O1xufTtcblxuVVBORy5xdWFudGl6ZS5lc3RhdHMgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgdmFyIFIgPSBzdGF0cy5SLFxuICAgICAgbSA9IHN0YXRzLm0sXG4gICAgICBOID0gc3RhdHMuTjsgLy8gd2hlbiBhbGwgc2FtcGxlcyBhcmUgZXF1YWwsIGJ1dCBOIGlzIGxhcmdlIChtaWxsaW9ucyksIHRoZSBSaiBjYW4gYmUgbm9uLXplcm8gKCAwLjAwMDMuLi4uIC0gcHJlY2lzc2lvbiBlcnJvcilcblxuICB2YXIgbTAgPSBtWzBdLFxuICAgICAgbTEgPSBtWzFdLFxuICAgICAgbTIgPSBtWzJdLFxuICAgICAgbTMgPSBtWzNdLFxuICAgICAgaU4gPSBOID09IDAgPyAwIDogMSAvIE47XG4gIHZhciBSaiA9IFtSWzBdIC0gbTAgKiBtMCAqIGlOLCBSWzFdIC0gbTAgKiBtMSAqIGlOLCBSWzJdIC0gbTAgKiBtMiAqIGlOLCBSWzNdIC0gbTAgKiBtMyAqIGlOLCBSWzRdIC0gbTEgKiBtMCAqIGlOLCBSWzVdIC0gbTEgKiBtMSAqIGlOLCBSWzZdIC0gbTEgKiBtMiAqIGlOLCBSWzddIC0gbTEgKiBtMyAqIGlOLCBSWzhdIC0gbTIgKiBtMCAqIGlOLCBSWzldIC0gbTIgKiBtMSAqIGlOLCBSWzEwXSAtIG0yICogbTIgKiBpTiwgUlsxMV0gLSBtMiAqIG0zICogaU4sIFJbMTJdIC0gbTMgKiBtMCAqIGlOLCBSWzEzXSAtIG0zICogbTEgKiBpTiwgUlsxNF0gLSBtMyAqIG0yICogaU4sIFJbMTVdIC0gbTMgKiBtMyAqIGlOXTtcbiAgdmFyIEEgPSBSaixcbiAgICAgIE0gPSBVUE5HLk00O1xuICB2YXIgYiA9IFswLjUsIDAuNSwgMC41LCAwLjVdLFxuICAgICAgbWkgPSAwLFxuICAgICAgdG1pID0gMDtcbiAgaWYgKE4gIT0gMCkgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgYiA9IE0ubXVsdFZlYyhBLCBiKTtcbiAgICB0bWkgPSBNYXRoLnNxcnQoTS5kb3QoYiwgYikpO1xuICAgIGIgPSBNLnNtbCgxIC8gdG1pLCBiKTtcbiAgICBpZiAoTWF0aC5hYnModG1pIC0gbWkpIDwgMWUtOSkgYnJlYWs7XG4gICAgbWkgPSB0bWk7XG4gIH0gLy9iID0gWzAsMCwxLDBdOyAgbWk9TjtcblxuICB2YXIgcSA9IFttMCAqIGlOLCBtMSAqIGlOLCBtMiAqIGlOLCBtMyAqIGlOXTtcbiAgdmFyIGVNcTI1NSA9IE0uZG90KE0uc21sKDI1NSwgcSksIGIpO1xuICByZXR1cm4ge1xuICAgIENvdjogUmosXG4gICAgcTogcSxcbiAgICBlOiBiLFxuICAgIEw6IG1pLFxuICAgIGVNcTI1NTogZU1xMjU1LFxuICAgIGVNcTogTS5kb3QoYiwgcSksXG4gICAgcmdiYTogKE1hdGgucm91bmQoMjU1ICogcVszXSkgPDwgMjQgfCBNYXRoLnJvdW5kKDI1NSAqIHFbMl0pIDw8IDE2IHwgTWF0aC5yb3VuZCgyNTUgKiBxWzFdKSA8PCA4IHwgTWF0aC5yb3VuZCgyNTUgKiBxWzBdKSA8PCAwKSA+Pj4gMFxuICB9O1xufTtcblxuVVBORy5NNCA9IHtcbiAgbXVsdFZlYzogZnVuY3Rpb24gKG0sIHYpIHtcbiAgICByZXR1cm4gW21bMF0gKiB2WzBdICsgbVsxXSAqIHZbMV0gKyBtWzJdICogdlsyXSArIG1bM10gKiB2WzNdLCBtWzRdICogdlswXSArIG1bNV0gKiB2WzFdICsgbVs2XSAqIHZbMl0gKyBtWzddICogdlszXSwgbVs4XSAqIHZbMF0gKyBtWzldICogdlsxXSArIG1bMTBdICogdlsyXSArIG1bMTFdICogdlszXSwgbVsxMl0gKiB2WzBdICsgbVsxM10gKiB2WzFdICsgbVsxNF0gKiB2WzJdICsgbVsxNV0gKiB2WzNdXTtcbiAgfSxcbiAgZG90OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiB4WzBdICogeVswXSArIHhbMV0gKiB5WzFdICsgeFsyXSAqIHlbMl0gKyB4WzNdICogeVszXTtcbiAgfSxcbiAgc21sOiBmdW5jdGlvbiAoYSwgeSkge1xuICAgIHJldHVybiBbYSAqIHlbMF0sIGEgKiB5WzFdLCBhICogeVsyXSwgYSAqIHlbM11dO1xuICB9XG59O1xuXG5VUE5HLmVuY29kZS5jb25jYXRSR0JBID0gZnVuY3Rpb24gKGJ1ZnMpIHtcbiAgdmFyIHRsZW4gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKykgdGxlbiArPSBidWZzW2ldLmJ5dGVMZW5ndGg7XG5cbiAgdmFyIG5pbWcgPSBuZXcgVWludDhBcnJheSh0bGVuKSxcbiAgICAgIG5vZmYgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2ldKSxcbiAgICAgICAgaWwgPSBpbWcubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbDsgaiArPSA0KSB7XG4gICAgICB2YXIgciA9IGltZ1tqXSxcbiAgICAgICAgICBnID0gaW1nW2ogKyAxXSxcbiAgICAgICAgICBiID0gaW1nW2ogKyAyXSxcbiAgICAgICAgICBhID0gaW1nW2ogKyAzXTtcbiAgICAgIGlmIChhID09IDApIHIgPSBnID0gYiA9IDA7XG4gICAgICBuaW1nW25vZmYgKyBqXSA9IHI7XG4gICAgICBuaW1nW25vZmYgKyBqICsgMV0gPSBnO1xuICAgICAgbmltZ1tub2ZmICsgaiArIDJdID0gYjtcbiAgICAgIG5pbWdbbm9mZiArIGogKyAzXSA9IGE7XG4gICAgfVxuXG4gICAgbm9mZiArPSBpbDtcbiAgfVxuXG4gIHJldHVybiBuaW1nLmJ1ZmZlcjtcbn07XG5cbnZhciBfZGVmYXVsdCA9IFVQTkc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/cjs/UPNG.js\n");

/***/ })

};
;